{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-81e783c350efeacae2813cdd4b1841c792e97ea6",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/ConfigGov.sol": "project/contracts/ConfigGov.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "project/contracts/ConfigGov.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./libraries/Constants.sol\";\n\n/**\n * @title ConfigGov - Governable Parameter Configuration Contract\n * @notice Manages runtime-adjustable system parameters (fees, limits, oracle addresses, etc.)\n * @dev Separated from ConfigCore: Core manages immutable addresses, Gov manages mutable parameters\n *      Governance logic can be upgraded without affecting core architecture\n */\ncontract ConfigGov is Ownable {\n\n    /**\n     * @notice Parameter type enum (uint256 type)\n     * @dev Used for unified management of all system parameters, supports unlimited extension\n     */\n    enum ParamType {\n        MINT_FEE_BP,        // 0 - Minting fee rate (basis points)\n        INTEREST_FEE_BP,    // 1 - Interest fee rate (basis points)\n        MIN_BTB_PRICE,      // 2 - BTB minimum price (18 decimals)\n        MAX_BTB_RATE,       // 3 - BTB maximum interest rate (18 decimals)\n        PCE_MAX_DEVIATION,  // 4 - PCE maximum deviation rate (18 decimals, e.g., 2e16 = 2%)\n        REDEEM_FEE_BP       // 5 - Redemption fee rate (basis points)\n        // Future extensions: LIQUIDATION_FEE, STABILITY_FEE, etc.\n    }\n\n    /**\n     * @notice Address parameter type enum\n     * @dev Used for managing governable oracle addresses, external contract addresses, etc.\n     */\n    enum AddressParamType {\n        PCE_FEED          // 0 - Chainlink PCE oracle address\n        // Future extensions: BACKUP_PCE_FEED, CPI_FEED, etc.\n    }\n\n    // ============ Storage ============\n\n    /// @notice Unified parameter registry (governable fees, limits, and other parameters)\n    mapping(ParamType => uint256) private _params;\n\n    /// @notice Address parameter registry (governable oracle addresses, etc.)\n    mapping(AddressParamType => address) private _addressParams;\n\n    // ============ Events ============\n\n    /// @notice Generic parameter update event (uint256 type)\n    event ParamUpdated(ParamType indexed paramType, uint256 newValue);\n\n    /// @notice Address parameter update event\n    event AddressParamUpdated(AddressParamType indexed paramType, address newValue);\n\n    // ============ Initialization ============\n\n    /**\n     * @notice Constructor - initializes governance parameters\n     * @param initialOwner Contract owner address\n     */\n    constructor(\n        address initialOwner\n    ) Ownable(initialOwner) {\n        require(initialOwner != address(0), \"ConfigGov: zero owner\");\n    }\n\n    // ============ Parameter Management ============\n\n    /**\n     * @notice Sets a single system parameter\n     * @dev Only owner can call, used for updating fees, price limits, and other parameters\n     * @param paramType Parameter type (from ParamType enum)\n     * @param value New parameter value\n     */\n    function setParam(ParamType paramType, uint256 value) external onlyOwner {\n        // Parameter range validation\n        _validateParam(paramType, value);\n\n        _params[paramType] = value;\n        emit ParamUpdated(paramType, value);\n    }\n\n    /**\n     * @notice Validates parameter range\n     * @dev Internal function to ensure parameters are within reasonable bounds\n     * @param paramType Parameter type\n     * @param value Parameter value\n     */\n    function _validateParam(ParamType paramType, uint256 value) private pure {\n        if (paramType == ParamType.MINT_FEE_BP) {\n            require(value >= 1, \"ConfigGov: mint fee too low\");  // Minimum 0.01% (1 basis point)\n            require(value <= 1000, \"ConfigGov: mint fee too high\"); // Maximum 10%\n        } else if (paramType == ParamType.INTEREST_FEE_BP) {\n            require(value >= 1, \"ConfigGov: interest fee too low\");\n            require(value <= 1000, \"ConfigGov: interest fee too high\");\n        } else if (paramType == ParamType.REDEEM_FEE_BP) {\n            require(value >= 1, \"ConfigGov: redeem fee too low\");\n            require(value <= 1000, \"ConfigGov: redeem fee too high\");\n        } else if (paramType == ParamType.MIN_BTB_PRICE) {\n            require(value >= 1e17, \"ConfigGov: min BTB price too low\"); // Minimum 0.1 BTD\n            require(value <= 2e18, \"ConfigGov: min BTB price too high\"); // Maximum 2 BTD\n        } else if (paramType == ParamType.MAX_BTB_RATE) {\n            require(value >= 1e16, \"ConfigGov: max BTB rate too low\"); // Minimum 1% APR\n            require(value <= 2e17, \"ConfigGov: max BTB rate too high\"); // Maximum 20% APR\n        } else if (paramType == ParamType.PCE_MAX_DEVIATION) {\n            require(value >= 1e15, \"ConfigGov: PCE deviation too low\"); // Minimum 0.1%\n            require(value <= 1e17, \"ConfigGov: PCE deviation too high\"); // Maximum 10%\n        }\n    }\n\n    /**\n     * @notice Batch sets multiple system parameters\n     * @dev Only owner can call, array lengths must be equal\n     * @param paramTypes Parameter type array\n     * @param values Corresponding new parameter value array\n     */\n    function setParamsBatch(\n        ParamType[] calldata paramTypes,\n        uint256[] calldata values\n    ) external onlyOwner {\n        require(paramTypes.length == values.length, \"ConfigGov: length mismatch\");\n        for (uint i = 0; i < paramTypes.length; i++) {\n            // Parameter range validation\n            _validateParam(paramTypes[i], values[i]);\n\n            _params[paramTypes[i]] = values[i];\n            emit ParamUpdated(paramTypes[i], values[i]);\n        }\n    }\n\n    /**\n     * @notice Gets the value of a specified system parameter type\n     * @dev Returns 0 if the parameter is not set\n     * @param paramType Parameter type\n     * @return Parameter value\n     */\n    function getParam(ParamType paramType) external view returns (uint256) {\n        return _params[paramType];\n    }\n\n    // ============ Convenience Access Functions ============\n\n    /**\n     * @notice Gets the minting fee rate\n     * @return Minting fee rate (basis points, e.g., 50 = 0.5%)\n     */\n    function mintFeeBP() external view returns (uint256) {\n        return _params[ParamType.MINT_FEE_BP];\n    }\n\n    function interestFeeBP() external view returns (uint256) {\n        return _params[ParamType.INTEREST_FEE_BP];\n    }\n\n    function minBTBPrice() external view returns (uint256) {\n        return _params[ParamType.MIN_BTB_PRICE];\n    }\n\n    function maxBTBRate() external view returns (uint256) {\n        return _params[ParamType.MAX_BTB_RATE];\n    }\n\n    /**\n     * @notice Gets PCE maximum deviation rate\n     * @dev Used to prevent abnormal PCE data fluctuations\n     * @return PCE maximum deviation rate (18 decimals, e.g., 2e16 = 2%)\n     */\n    function pceMaxDeviation() external view returns (uint256) {\n        return _params[ParamType.PCE_MAX_DEVIATION];\n    }\n\n    /**\n     * @notice Gets the redemption fee rate\n     * @dev Fee deducted from user when redeeming BTD\n     * @return Redemption fee rate (basis points, e.g., 50 = 0.5%)\n     */\n    function redeemFeeBP() external view returns (uint256) {\n        return _params[ParamType.REDEEM_FEE_BP];\n    }\n\n    // ============ Address Parameter Management ============\n\n    /**\n     * @notice Sets a single address parameter\n     * @dev Only owner can call, used for updating oracle addresses, etc.\n     * @param paramType Address parameter type (from AddressParamType enum)\n     * @param value New address value\n     */\n    function setAddressParam(AddressParamType paramType, address value) external onlyOwner {\n        require(value != address(0), \"ConfigGov: zero address\");\n        _addressParams[paramType] = value;\n        emit AddressParamUpdated(paramType, value);\n    }\n\n    /**\n     * @notice Batch sets multiple address parameters\n     * @dev Only owner can call, array lengths must be equal\n     * @param paramTypes Address parameter type array\n     * @param values Corresponding new address value array\n     */\n    function setAddressParamsBatch(\n        AddressParamType[] calldata paramTypes,\n        address[] calldata values\n    ) external onlyOwner {\n        require(paramTypes.length == values.length, \"ConfigGov: length mismatch\");\n        for (uint i = 0; i < paramTypes.length; i++) {\n            require(values[i] != address(0), \"ConfigGov: zero address\");\n            _addressParams[paramTypes[i]] = values[i];\n            emit AddressParamUpdated(paramTypes[i], values[i]);\n        }\n    }\n\n    /**\n     * @notice Gets the value of a specified address parameter type\n     * @dev Returns address(0) if the parameter is not set\n     * @param paramType Address parameter type\n     * @return Address value\n     */\n    function getAddressParam(AddressParamType paramType) external view returns (address) {\n        return _addressParams[paramType];\n    }\n\n    /**\n     * @notice Gets PCE Feed oracle address\n     * @return PCE Feed address\n     */\n    function pceFeed() external view returns (address) {\n        return _addressParams[AddressParamType.PCE_FEED];\n    }\n}\n"
      },
      "project/contracts/libraries/Constants.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title Constants - BRS System Global Constants Library\n * @notice Centralized management of system-level immutable constants\n * @dev Uses library + internal constant to ensure compile-time inlining (zero gas overhead)\n *\n * Key features:\n * - internal constant is inlined by the compiler into contracts that use it\n * - Gas cost = 16 gas (same as local constant)\n * - Unified management, single source of truth\n * - Type-safe, compile-time checking\n */\nlibrary Constants {\n    // ============ Precision Constants ============\n\n    /// @notice 18 decimals precision (standard ERC20, USD prices)\n    uint256 internal constant PRECISION_18 = 1e18;\n\n    /// @notice 8 decimals precision (BTC)\n    uint256 internal constant PRECISION_8 = 1e8;\n\n    /// @notice 6 decimals precision (USDC/USDT)\n    uint256 internal constant PRECISION_6 = 1e6;\n\n    // ============ Precision Conversion Scale Constants ============\n\n    /// @notice WBTC (8 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-8) = 1e10, used for explicit precision conversion, avoiding runtime EXP calculation\n    uint256 internal constant SCALE_WBTC_TO_NORM = 1e10;\n\n    /// @notice USDC (6 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-6) = 1e12, used for explicit precision conversion\n    uint256 internal constant SCALE_USDC_TO_NORM = 1e12;\n\n    /// @notice USDT (6 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-6) = 1e12, used for explicit precision conversion (same as USDC)\n    uint256 internal constant SCALE_USDT_TO_NORM = 1e12;\n\n    /// @notice Normalized (18 decimals) to WBTC (8 decimals) scale factor\n    /// @dev 1e8, used for output precision conversion\n    uint256 internal constant SCALE_NORM_TO_WBTC = 1e8;\n\n    /// @notice Normalized (18 decimals) to USDC (6 decimals) scale factor\n    /// @dev 1e6, used for output precision conversion\n    uint256 internal constant SCALE_NORM_TO_USDC = 1e6;\n\n    /// @notice Normalized (18 decimals) to USDT (6 decimals) scale factor\n    /// @dev 1e6, used for output precision conversion (same as USDC)\n    uint256 internal constant SCALE_NORM_TO_USDT = 1e6;\n\n    // ============ Input Parameter Safety Limits ============\n\n    /// @notice Maximum input parameter value (overflow prevention)\n    /// @dev 1e33, two such values multiplied equals 1e66 < type(uint256).max (1.15e77)\n    /// With this design, most multiplication operations don't need safeMulDiv\n    uint256 internal constant MAX_INPUT_AMOUNT = 1e33;\n\n    // ============ Minimum Operation Amount Constants ============\n\n    /// @notice Minimum BTC operation amount per transaction (8 decimals)\n    /// @dev 1 satoshi, prevents dust attacks\n    uint256 internal constant MIN_BTC_AMOUNT = 1;\n\n    /// @notice Minimum ETH operation amount per transaction (18 decimals)\n    /// @dev 1e-8 ETH = 1e10 wei (0.00000001 ETH)\n    uint256 internal constant MIN_ETH_AMOUNT = 1e10;\n\n        /// @notice Minimum USD value for operations (18 decimals)\n    /// @dev Used in Minter, Treasury, and other scenarios involving USD value conversion\n    /// $0.001 USD, prevents dust attacks and precision loss\n    ///\n    /// Use cases:\n    /// - Minter.mintBTD(): Check mint USD value >= $0.001\n    /// - Minter.redeemBTD(): Check redeem USD value >= $0.001\n    /// - Treasury.buyback(): Check buyback USD value >= $0.001\n    uint256 internal constant MIN_USD_VALUE = 1e15;\n\n    /// @notice Minimum operation amount for 6-decimal stablecoins\n    /// @dev 0.001 USDC/USDT = 1000 units (6 decimals), prevents dust attacks\n    /// Applicable to: USDC, USDT\n    uint256 internal constant MIN_STABLECOIN_6_AMOUNT = 1000;\n\n    /// @notice Minimum operation amount for 18-decimal stablecoins\n    /// @dev 0.001 tokens = 1e15 (18 decimals), prevents dust attacks\n    /// Applicable to: BTD, BTB, stBTD, stBTB\n    ///\n    /// Use cases:\n    /// - InterestPool.stake(): Minimum stake amount for BTD/BTB\n    /// - StakingRouter: Minimum stake amount for stBTD/stBTB\n    uint256 internal constant MIN_STABLECOIN_18_AMOUNT = 1e15;\n\n    // ============ Maximum Single Operation Limits (Prevents Hacker Attacks and Overflow) ============\n\n    /// @notice Maximum WBTC amount per single operation\n    /// @dev 10,000 BTC (8 decimals = 10000 * 1e8)\n    /// Prevents hacker attacks and integer overflow, applies to all WBTC transfer/mint/redeem operations\n    uint256 internal constant MAX_WBTC_AMOUNT = 10_000 * 1e8;\n\n    /// @notice Maximum ETH amount per single operation\n    /// @dev 100,000 ETH (18 decimals = 100000 * 1e18)\n    /// Prevents hacker attacks and integer overflow\n    uint256 internal constant MAX_ETH_AMOUNT = 100_000 * 1e18;\n\n    /// @notice Maximum 6-decimal stablecoin amount per single operation\n    /// @dev 1 billion USDC/USDT (6 decimals = 1000000000 * 1e6)\n    /// Prevents hacker attacks and integer overflow\n    /// Applicable to: USDC, USDT\n    uint256 internal constant MAX_STABLECOIN_6_AMOUNT = 1_000_000_000 * 1e6;\n\n    /// @notice Maximum 18-decimal stablecoin amount per single operation\n    /// @dev 1 billion BTD/BTB/stBTD/stBTB (18 decimals = 1000000000 * 1e18)\n    /// Prevents hacker attacks and integer overflow\n    /// Applicable to: BTD, BTB, stBTD, stBTB and other 18-decimal stablecoins\n    uint256 internal constant MAX_STABLECOIN_18_AMOUNT = 1_000_000_000 * 1e18;\n\n    /// @notice Maximum USD value per single operation\n    /// @dev Equivalent to 1 billion USD (18 decimals = 1000000000 * 1e18)\n    /// Prevents hacker attacks and integer overflow, applies to all USD value calculations\n    uint256 internal constant MAX_USD_VALUE = 1_000_000_000 * 1e18;\n\n    /// @notice Percentage base (100%)\n    uint256 internal constant PERCENT_BASE = 100;\n\n    /// @notice Basis points base (10000 = 100.00%)\n    uint256 internal constant BPS_BASE = 10000;\n\n    // ============ Time Constants ============\n\n    /// @notice Seconds per year\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /// @notice Seconds per day\n    uint256 internal constant SECONDS_PER_DAY = 1 days;\n\n    /// @notice Seconds per week\n    uint256 internal constant SECONDS_PER_WEEK = 7 days;\n\n    /// @notice BTC halving cycle (4 years)\n    uint256 internal constant ERA_PERIOD = 4 * 365 days;\n\n    // ============ Inflation Parameter Constants ============\n\n    /// @notice Fixed annual inflation rate - 2%\n    /// @dev Fixed inflation target specified in whitepaper, used for IUSD (Ideal USD) calculation\n    /// 2% = 0.02 = 2e16 (18 decimals)\n    uint256 internal constant ANNUAL_INFLATION_RATE = 2e16;\n\n    /// @notice Monthly growth factor - (1.02)^(1/12)\n    /// @dev Calculated from 2% annual inflation\n    /// Formula: (1 + 0.02)^(1/12) = 1.001651581301920174\n    /// Calculated off-chain with high precision and stored with 18 decimals\n    uint256 internal constant MONTHLY_GROWTH_FACTOR = 1001651581301920174;\n\n    // ============ Supply Constants ============\n\n    /// @notice BRS maximum supply (2.1 billion, tribute to BTC's 21 million)\n    /// @dev Maximum supply of BRS tokens, the only definition in the system\n    uint256 internal constant BRS_MAX_SUPPLY = 2_100_000_000e18;\n}\n"
      }
    }
  }
}