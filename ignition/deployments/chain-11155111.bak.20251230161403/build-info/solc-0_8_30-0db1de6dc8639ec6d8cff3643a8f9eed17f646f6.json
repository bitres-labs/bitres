{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-0db1de6dc8639ec6d8cff3643a8f9eed17f646f6",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/UniswapV2TWAPOracle.sol": "project/contracts/UniswapV2TWAPOracle.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/interfaces/IUniswapV2TWAPOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title IUniswapV2TWAPOracle\n * @notice Uniswap V2 Time-Weighted Average Price (TWAP) oracle interface\n * @dev Defines the standard interface for TWAP Oracle, used to prevent flash loan price manipulation\n */\ninterface IUniswapV2TWAPOracle {\n\n    /**\n     * @notice Get the TWAP price for a trading pair\n     * @param pair Uniswap V2 pair address\n     * @param token0Decimals Decimals of token0\n     * @param token1Decimals Decimals of token1\n     * @return TWAP price (18 decimal precision)\n     * @dev Returns the TWAP price of token1 denominated in token0\n     */\n    function getTWAPPrice(address pair, uint8 token0Decimals, uint8 token1Decimals)\n        external view returns (uint256);\n\n    /**\n     * @notice Check if TWAP is ready\n     * @param pair Uniswap V2 pair address\n     * @return true if TWAP has been initialized and is ready to use\n     * @dev Should check this function before calling getTWAPPrice\n     */\n    function isTWAPReady(address pair) external view returns (bool);\n\n    /**\n     * @notice Update the cumulative price for a trading pair\n     * @param pair Uniswap V2 pair address\n     * @dev Should be called periodically to maintain accurate TWAP data\n     */\n    function update(address pair) external;\n\n    /**\n     * @notice Check if a pair needs TWAP update\n     * @param pair Uniswap V2 pair address\n     * @return true if >= PERIOD has passed since last update\n     */\n    function needsUpdate(address pair) external view returns (bool);\n\n    /**\n     * @notice Update TWAP only if needed (>= PERIOD since last update)\n     * @param pair Uniswap V2 pair address\n     * @return updated True if update was performed\n     * @dev Saves gas by skipping if recently updated\n     */\n    function updateIfNeeded(address pair) external returns (bool updated);\n}\n"
      },
      "project/contracts/UniswapV2TWAPOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./interfaces/IUniswapV2TWAPOracle.sol\";\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint256);\n    function price1CumulativeLast() external view returns (uint256);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}\n\n/// @title UniswapV2TWAPOracle\n/// @notice Time-Weighted Average Price (TWAP) oracle for Uniswap V2\n/// @dev Based on Uniswap's ExampleOracleSimple - reads cumulative prices directly from pair\ncontract UniswapV2TWAPOracle is IUniswapV2TWAPOracle {\n    // TWAP observation period (30 minutes for flash loan protection)\n    uint256 public constant PERIOD = 30 minutes;\n\n    struct Observation {\n        uint32 timestamp;\n        uint256 price0Cumulative;\n        uint256 price1Cumulative;\n    }\n\n    // pair address => [older observation, newer observation]\n    mapping(address => Observation[2]) public pairObservations;\n\n    // Events\n    event ObservationUpdated(address indexed pair, uint256 price0Cumulative, uint256 price1Cumulative, uint32 timestamp);\n\n    /// @notice Get current cumulative prices from pair (handles time elapsed since last trade)\n    /// @dev Based on UniswapV2OracleLibrary.currentCumulativePrices\n    function _currentCumulativePrices(address pair) internal view returns (\n        uint256 price0Cumulative,\n        uint256 price1Cumulative,\n        uint32 blockTimestamp\n    ) {\n        blockTimestamp = uint32(block.timestamp);\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // Get reserves and last update time\n        (uint112 reserve0, uint112 reserve1, uint32 timestampLast) = IUniswapV2Pair(pair).getReserves();\n\n        // If time has elapsed since last pair update, add the pending cumulative price\n        if (timestampLast != blockTimestamp && reserve0 != 0 && reserve1 != 0) {\n            uint32 timeElapsed;\n            unchecked {\n                timeElapsed = blockTimestamp - timestampLast;\n            }\n            // Add pending price accumulation (Q112 format)\n            // IMPORTANT: Cast to uint256 before bit shift to avoid overflow\n            unchecked {\n                price0Cumulative += (uint256(reserve1) << 112) / reserve0 * timeElapsed;\n                price1Cumulative += (uint256(reserve0) << 112) / reserve1 * timeElapsed;\n            }\n        }\n    }\n\n    /// @notice Updates TWAP observation for a trading pair\n    /// @dev Should be called periodically (at least every PERIOD) to maintain valid observations\n    /// @param pair Uniswap V2 Pair contract address\n    function update(address pair) external {\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) =\n            _currentCumulativePrices(pair);\n\n        // Shift observations: [1] -> [0], new -> [1]\n        pairObservations[pair][0] = pairObservations[pair][1];\n        pairObservations[pair][1] = Observation({\n            timestamp: blockTimestamp,\n            price0Cumulative: price0Cumulative,\n            price1Cumulative: price1Cumulative\n        });\n\n        emit ObservationUpdated(pair, price0Cumulative, price1Cumulative, blockTimestamp);\n    }\n\n    /// @notice Gets TWAP price in Q112 format (token1/token0)\n    /// @param pair Uniswap V2 Pair contract address\n    /// @return price TWAP price in Q112 format\n    function getTWAP(address pair) public view returns (uint256) {\n        Observation memory older = pairObservations[pair][0];\n        Observation memory newer = pairObservations[pair][1];\n\n        require(newer.timestamp > 0, \"No observations\");\n        require(older.timestamp > 0, \"Need two observations\");\n\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = newer.timestamp - older.timestamp;\n        }\n        require(timeElapsed >= PERIOD, \"Observation period too short\");\n\n        // Calculate TWAP: (cumulative_new - cumulative_old) / time_elapsed\n        uint256 priceCumulativeDelta;\n        unchecked {\n            priceCumulativeDelta = newer.price0Cumulative - older.price0Cumulative;\n        }\n        return priceCumulativeDelta / timeElapsed;\n    }\n\n    /// @notice Gets TWAP price normalized to 18 decimals\n    /// @param pair Uniswap V2 Pair contract address\n    /// @param token0Decimals Decimals of token0\n    /// @param token1Decimals Decimals of token1\n    /// @return price Price of token0 in token1, normalized to 18 decimals\n    function getTWAPPrice(\n        address pair,\n        uint8 token0Decimals,\n        uint8 token1Decimals\n    ) external view returns (uint256) {\n        uint256 twapQ112 = getTWAP(pair);\n\n        // Convert from Q112 to 18 decimals\n        // twapQ112 is in Q112 format: (reserve1_raw / reserve0_raw) * 2^112\n        // This represents \"raw units of token1 per raw unit of token0\"\n        //\n        // To get price in 18 decimals (whole token1 per whole token0):\n        // price = (twapQ112 / 2^112) * 10^(token0Decimals - token1Decimals) * 10^18\n        //\n        // IMPORTANT: Multiply BEFORE shifting to preserve precision for small prices\n        // e.g., BTD(18)/USDC(6): twapQ112 < 2^112, so shift first would give 0\n        //\n        // For WBTC(8)/USDC(6): price = (twapQ112 * 100 * 1e18) >> 112\n        // For BTD(18)/USDC(6): price = (twapQ112 * 1e12 * 1e18) >> 112\n\n        uint256 price;\n\n        if (token0Decimals >= token1Decimals) {\n            // token0 has more decimals - multiply to scale up\n            // e.g., BTD(18)/USDC(6): multiply by 1e12\n            uint256 decimalAdjust = 10 ** (token0Decimals - token1Decimals);\n            // Multiply first, then shift to preserve precision\n            price = (twapQ112 * decimalAdjust * 1e18) >> 112;\n        } else {\n            // token1 has more decimals - divide to scale down\n            // e.g., USDC(6)/ETH(18): divide by 1e12\n            uint256 decimalAdjust = 10 ** (token1Decimals - token0Decimals);\n            // Multiply by 1e18 first, then shift, then divide\n            price = ((twapQ112 * 1e18) >> 112) / decimalAdjust;\n        }\n\n        return price;\n    }\n\n    /// @notice Checks if TWAP is ready for querying\n    /// @param pair Uniswap V2 Pair contract address\n    /// @return ready True if TWAP can be safely queried\n    function isTWAPReady(address pair) external view returns (bool) {\n        Observation memory older = pairObservations[pair][0];\n        Observation memory newer = pairObservations[pair][1];\n\n        if (newer.timestamp == 0 || older.timestamp == 0) return false;\n\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = newer.timestamp - older.timestamp;\n        }\n        return timeElapsed >= PERIOD;\n    }\n\n    /// @notice Gets observation info for diagnostics\n    /// @param pair Uniswap V2 Pair contract address\n    function getObservationInfo(address pair) external view returns (\n        uint32 olderTimestamp,\n        uint32 newerTimestamp,\n        uint32 timeElapsed\n    ) {\n        Observation memory older = pairObservations[pair][0];\n        Observation memory newer = pairObservations[pair][1];\n\n        olderTimestamp = older.timestamp;\n        newerTimestamp = newer.timestamp;\n        unchecked {\n            timeElapsed = newer.timestamp - older.timestamp;\n        }\n    }\n\n    /// @notice Checks if a pair needs TWAP update (>= PERIOD since last update)\n    /// @param pair Uniswap V2 Pair contract address\n    /// @return True if update is needed\n    function needsUpdate(address pair) public view returns (bool) {\n        Observation memory newer = pairObservations[pair][1];\n        // Needs update if: no observation yet, or >= PERIOD since last\n        return newer.timestamp == 0 || block.timestamp >= newer.timestamp + PERIOD;\n    }\n\n    /// @notice Updates TWAP only if needed (>= PERIOD since last update)\n    /// @dev Saves gas by skipping update if recently updated\n    /// @param pair Uniswap V2 Pair contract address\n    /// @return updated True if update was performed\n    function updateIfNeeded(address pair) external returns (bool updated) {\n        if (needsUpdate(pair)) {\n            (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) =\n                _currentCumulativePrices(pair);\n\n            pairObservations[pair][0] = pairObservations[pair][1];\n            pairObservations[pair][1] = Observation({\n                timestamp: blockTimestamp,\n                price0Cumulative: price0Cumulative,\n                price1Cumulative: price1Cumulative\n            });\n\n            emit ObservationUpdated(pair, price0Cumulative, price1Cumulative, blockTimestamp);\n            return true;\n        }\n        return false;\n    }\n}\n"
      }
    }
  }
}