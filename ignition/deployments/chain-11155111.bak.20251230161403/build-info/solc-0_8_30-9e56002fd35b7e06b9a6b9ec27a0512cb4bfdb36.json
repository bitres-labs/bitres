{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-9e56002fd35b7e06b9a6b9ec27a0512cb4bfdb36",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/StakingRouter.sol": "project/contracts/StakingRouter.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC4626.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC4626.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/interfaces/IFarmingPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IFarmingPool - Standard interface for yield farming contract\n * @notice Defines the core functionality interface for the yield farming contract\n */\ninterface IFarmingPool {\n    enum PoolKind {\n        Single,\n        LP\n    }\n\n    struct PoolInfo {\n        IERC20 lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardTime;\n        uint256 accRewardPerShare;\n        uint256 totalStaked;\n        uint256 cachedLPValuePerToken;  // Cached LP value per token (18 decimal precision USD)\n        uint256 lastPriceUpdate;        // Last price update timestamp\n        PoolKind kind;                  // Pool type\n    }\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n    }\n\n    // --- Mining Operations ---\n    /**\n     * @notice User deposits tokens to specified mining pool\n     * @param _pid Pool ID\n     * @param _amount Deposit amount\n     */\n    function deposit(uint256 _pid, uint256 _amount) external;\n\n    /**\n     * @notice User withdraws tokens from specified mining pool\n     * @param _pid Pool ID\n     * @param _amount Withdrawal amount\n     */\n    function withdraw(uint256 _pid, uint256 _amount) external;\n\n    /**\n     * @notice User claims rewards from specified mining pool\n     * @param _pid Pool ID\n     */\n    function claim(uint256 _pid) external;\n\n    /**\n     * @notice Emergency withdrawal, forfeit rewards and retrieve principal\n     * @param _pid Pool ID\n     */\n    function emergencyWithdraw(uint256 _pid) external;\n\n    // --- Proxy Operations (for Router contract) ---\n    /**\n     * @notice Deposit tokens on behalf of another user (called by Router contract)\n     * @param _pid Pool ID\n     * @param _amount Deposit amount\n     * @param _onBehalfOf Actual beneficiary address\n     */\n    function depositFor(uint256 _pid, uint256 _amount, address _onBehalfOf) external;\n\n    /**\n     * @notice Withdraw tokens on behalf of another user (called by Router contract)\n     * @param _pid Pool ID\n     * @param _amount Withdrawal amount\n     * @param _onBehalfOf Token owner address\n     * @param _to Recipient address\n     */\n    function withdrawFor(uint256 _pid, uint256 _amount, address _onBehalfOf, address _to) external;\n\n    /**\n     * @notice Claim rewards on behalf of another user (called by Router contract)\n     * @param _pid Pool ID\n     * @param _onBehalfOf Actual beneficiary address\n     */\n    function claimFor(uint256 _pid, address _onBehalfOf) external;\n\n    /**\n     * @notice Inject BRS reward tokens into reward pool\n     * @param amount BRS amount\n     */\n    function fundRewards(uint256 amount) external;\n\n    // --- Pool Management ---\n    /**\n     * @notice Add new mining pool\n     * @param _token Staking token (single token or LP token)\n     * @param _allocPoint Allocation points, determines reward distribution weight for this pool\n     * @param _kind Pool type (Single=single token pool, LP=liquidity pool)\n     * @param _withUpdate Whether to update rewards for all pools first\n     */\n    function addPool(IERC20 _token, uint256 _allocPoint, PoolKind _kind, bool _withUpdate) external;\n\n    /**\n     * @notice Add new mining pool (default: don't update other pools)\n     * @param _token Staking token (single token or LP token)\n     * @param _allocPoint Allocation points\n     * @param _kind Pool type\n     */\n    function addPool(IERC20 _token, uint256 _allocPoint, PoolKind _kind) external;\n\n    /**\n     * @notice Batch add multiple mining pools\n     * @param _tokens Array of staking tokens\n     * @param _allocPoints Array of allocation points\n     * @param _kinds Array of pool types\n     */\n    function addPools(\n        IERC20[] calldata _tokens,\n        uint256[] calldata _allocPoints,\n        PoolKind[] calldata _kinds\n    ) external;\n\n    /**\n     * @notice Modify allocation points for specified mining pool\n     * @param _pid Pool ID\n     * @param _allocPoint New allocation points\n     * @param _withUpdate Whether to update rewards for all pools first\n     */\n    function setPool(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;\n\n    // --- Query Functions ---\n    /**\n     * @notice Get total number of mining pools\n     * @return Number of mining pools\n     */\n    function poolLength() external view returns (uint256);\n\n    /**\n     * @notice Query user's pending rewards\n     * @param _pid Pool ID\n     * @param _user User address\n     * @return Pending BRS reward amount\n     */\n    function pendingReward(uint256 _pid, address _user) external view returns (uint256);\n\n    // Auto-generated getter functions (from public storage variables)\n    /**\n     * @notice Get user info for specified pool\n     * @param _pid Pool ID\n     * @param _user User address\n     * @return amount User's staked token amount\n     * @return rewardDebt Debt value used for reward calculation\n     */\n    function userInfo(uint256 _pid, address _user) external view returns (uint256 amount, uint256 rewardDebt);\n\n    /**\n     * @notice Get detailed info for specified pool\n     * @param _pid Pool ID\n     * @return lpToken Staking token contract\n     * @return allocPoint Allocation points\n     * @return lastRewardTime Last reward calculation timestamp\n     * @return accRewardPerShare Accumulated reward per share\n     * @return totalStaked Total staked amount\n     * @return cachedLPValuePerToken Cached LP value per token (18 decimal precision USD)\n     * @return lastPriceUpdate Last price update timestamp\n     * @return kind Pool type\n     */\n    function poolInfo(uint256 _pid) external view returns (\n        IERC20 lpToken,\n        uint256 allocPoint,\n        uint256 lastRewardTime,\n        uint256 accRewardPerShare,\n        uint256 totalStaked,\n        uint256 cachedLPValuePerToken,\n        uint256 lastPriceUpdate,\n        PoolKind kind\n    );\n\n    /**\n     * @notice Get pool type for specified pool\n     * @param _pid Pool ID\n     * @return Pool type (Single or LP)\n     */\n    function poolKind(uint256 _pid) external view returns (PoolKind);\n\n\n    // --- Reward Parameters ---\n    /**\n     * @notice Get current reward rate per second\n     * @return Current BRS reward produced per second\n     */\n    function currentRewardPerSecond() external view returns (uint256);\n\n    /**\n     * @notice Get BRS token contract address\n     * @return BRS token address\n     */\n    function brs() external view returns (address);\n\n    /**\n     * @notice Get mining start time\n     * @return Block timestamp when mining started\n     */\n    function startTime() external view returns (uint256);\n\n    /**\n     * @notice Get total minted BRS\n     * @return Cumulative minted BRS amount\n     */\n    function minted() external view returns (uint256);\n\n    // --- LP Value Management ---\n    /**\n     * @notice Update LP token value cache for specified pool\n     * @param _pid Pool ID\n     */\n    function updateLPValue(uint256 _pid) external;\n\n    /**\n     * @notice Check if specified pool needs LP value update\n     * @param _pid Pool ID\n     * @return needs Whether update is needed\n     * @return timeSinceUpdate Time since last update (seconds)\n     */\n    function needsUpdate(uint256 _pid) external view returns (bool needs, uint256 timeSinceUpdate);\n\n    // --- Events ---\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Claim(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event LPValueUpdated(uint256 indexed pid, uint256 newValuePerToken, uint256 timestamp);\n}\n"
      },
      "project/contracts/libraries/Constants.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title Constants - BRS System Global Constants Library\n * @notice Centralized management of system-level immutable constants\n * @dev Uses library + internal constant to ensure compile-time inlining (zero gas overhead)\n *\n * Key features:\n * - internal constant is inlined by the compiler into contracts that use it\n * - Gas cost = 16 gas (same as local constant)\n * - Unified management, single source of truth\n * - Type-safe, compile-time checking\n */\nlibrary Constants {\n    // ============ Precision Constants ============\n\n    /// @notice 18 decimals precision (standard ERC20, USD prices)\n    uint256 internal constant PRECISION_18 = 1e18;\n\n    /// @notice 8 decimals precision (BTC)\n    uint256 internal constant PRECISION_8 = 1e8;\n\n    /// @notice 6 decimals precision (USDC/USDT)\n    uint256 internal constant PRECISION_6 = 1e6;\n\n    // ============ Precision Conversion Scale Constants ============\n\n    /// @notice WBTC (8 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-8) = 1e10, used for explicit precision conversion, avoiding runtime EXP calculation\n    uint256 internal constant SCALE_WBTC_TO_NORM = 1e10;\n\n    /// @notice USDC (6 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-6) = 1e12, used for explicit precision conversion\n    uint256 internal constant SCALE_USDC_TO_NORM = 1e12;\n\n    /// @notice USDT (6 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-6) = 1e12, used for explicit precision conversion (same as USDC)\n    uint256 internal constant SCALE_USDT_TO_NORM = 1e12;\n\n    /// @notice Normalized (18 decimals) to WBTC (8 decimals) scale factor\n    /// @dev 1e8, used for output precision conversion\n    uint256 internal constant SCALE_NORM_TO_WBTC = 1e8;\n\n    /// @notice Normalized (18 decimals) to USDC (6 decimals) scale factor\n    /// @dev 1e6, used for output precision conversion\n    uint256 internal constant SCALE_NORM_TO_USDC = 1e6;\n\n    /// @notice Normalized (18 decimals) to USDT (6 decimals) scale factor\n    /// @dev 1e6, used for output precision conversion (same as USDC)\n    uint256 internal constant SCALE_NORM_TO_USDT = 1e6;\n\n    // ============ Input Parameter Safety Limits ============\n\n    /// @notice Maximum input parameter value (overflow prevention)\n    /// @dev 1e33, two such values multiplied equals 1e66 < type(uint256).max (1.15e77)\n    /// With this design, most multiplication operations don't need safeMulDiv\n    uint256 internal constant MAX_INPUT_AMOUNT = 1e33;\n\n    // ============ Minimum Operation Amount Constants ============\n\n    /// @notice Minimum BTC operation amount per transaction (8 decimals)\n    /// @dev 1 satoshi, prevents dust attacks\n    uint256 internal constant MIN_BTC_AMOUNT = 1;\n\n    /// @notice Minimum ETH operation amount per transaction (18 decimals)\n    /// @dev 1e-8 ETH = 1e10 wei (0.00000001 ETH)\n    uint256 internal constant MIN_ETH_AMOUNT = 1e10;\n\n        /// @notice Minimum USD value for operations (18 decimals)\n    /// @dev Used in Minter, Treasury, and other scenarios involving USD value conversion\n    /// $0.001 USD, prevents dust attacks and precision loss\n    ///\n    /// Use cases:\n    /// - Minter.mintBTD(): Check mint USD value >= $0.001\n    /// - Minter.redeemBTD(): Check redeem USD value >= $0.001\n    /// - Treasury.buyback(): Check buyback USD value >= $0.001\n    uint256 internal constant MIN_USD_VALUE = 1e15;\n\n    /// @notice Minimum operation amount for 6-decimal stablecoins\n    /// @dev 0.001 USDC/USDT = 1000 units (6 decimals), prevents dust attacks\n    /// Applicable to: USDC, USDT\n    uint256 internal constant MIN_STABLECOIN_6_AMOUNT = 1000;\n\n    /// @notice Minimum operation amount for 18-decimal stablecoins\n    /// @dev 0.001 tokens = 1e15 (18 decimals), prevents dust attacks\n    /// Applicable to: BTD, BTB, stBTD, stBTB\n    ///\n    /// Use cases:\n    /// - InterestPool.stake(): Minimum stake amount for BTD/BTB\n    /// - StakingRouter: Minimum stake amount for stBTD/stBTB\n    uint256 internal constant MIN_STABLECOIN_18_AMOUNT = 1e15;\n\n    // ============ Maximum Single Operation Limits (Prevents Hacker Attacks and Overflow) ============\n\n    /// @notice Maximum WBTC amount per single operation\n    /// @dev 10,000 BTC (8 decimals = 10000 * 1e8)\n    /// Prevents hacker attacks and integer overflow, applies to all WBTC transfer/mint/redeem operations\n    uint256 internal constant MAX_WBTC_AMOUNT = 10_000 * 1e8;\n\n    /// @notice Maximum ETH amount per single operation\n    /// @dev 100,000 ETH (18 decimals = 100000 * 1e18)\n    /// Prevents hacker attacks and integer overflow\n    uint256 internal constant MAX_ETH_AMOUNT = 100_000 * 1e18;\n\n    /// @notice Maximum 6-decimal stablecoin amount per single operation\n    /// @dev 1 billion USDC/USDT (6 decimals = 1000000000 * 1e6)\n    /// Prevents hacker attacks and integer overflow\n    /// Applicable to: USDC, USDT\n    uint256 internal constant MAX_STABLECOIN_6_AMOUNT = 1_000_000_000 * 1e6;\n\n    /// @notice Maximum 18-decimal stablecoin amount per single operation\n    /// @dev 1 billion BTD/BTB/stBTD/stBTB (18 decimals = 1000000000 * 1e18)\n    /// Prevents hacker attacks and integer overflow\n    /// Applicable to: BTD, BTB, stBTD, stBTB and other 18-decimal stablecoins\n    uint256 internal constant MAX_STABLECOIN_18_AMOUNT = 1_000_000_000 * 1e18;\n\n    /// @notice Maximum USD value per single operation\n    /// @dev Equivalent to 1 billion USD (18 decimals = 1000000000 * 1e18)\n    /// Prevents hacker attacks and integer overflow, applies to all USD value calculations\n    uint256 internal constant MAX_USD_VALUE = 1_000_000_000 * 1e18;\n\n    /// @notice Percentage base (100%)\n    uint256 internal constant PERCENT_BASE = 100;\n\n    /// @notice Basis points base (10000 = 100.00%)\n    uint256 internal constant BPS_BASE = 10000;\n\n    // ============ Time Constants ============\n\n    /// @notice Seconds per year\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /// @notice Seconds per day\n    uint256 internal constant SECONDS_PER_DAY = 1 days;\n\n    /// @notice Seconds per week\n    uint256 internal constant SECONDS_PER_WEEK = 7 days;\n\n    /// @notice BTC halving cycle (4 years)\n    uint256 internal constant ERA_PERIOD = 4 * 365 days;\n\n    // ============ Inflation Parameter Constants ============\n\n    /// @notice Fixed annual inflation rate - 2%\n    /// @dev Fixed inflation target specified in whitepaper, used for IUSD (Ideal USD) calculation\n    /// 2% = 0.02 = 2e16 (18 decimals)\n    uint256 internal constant ANNUAL_INFLATION_RATE = 2e16;\n\n    /// @notice Monthly growth factor - (1.02)^(1/12)\n    /// @dev Calculated from 2% annual inflation\n    /// Formula: (1 + 0.02)^(1/12) = 1.001651581301920174\n    /// Calculated off-chain with high precision and stored with 18 decimals\n    uint256 internal constant MONTHLY_GROWTH_FACTOR = 1001651581301920174;\n\n    // ============ Supply Constants ============\n\n    /// @notice BRS maximum supply (2.1 billion, tribute to BTC's 21 million)\n    /// @dev Maximum supply of BRS tokens, the only definition in the system\n    uint256 internal constant BRS_MAX_SUPPLY = 2_100_000_000e18;\n}\n"
      },
      "project/contracts/StakingRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IFarmingPool.sol\";\nimport \"./libraries/Constants.sol\";\n\n/// @title StakingRouter\n/// @notice Users interact with InterestPool/FarmingPool through this unified staking entry to receive dual rewards\n/// @dev Logic:\n///      - BTD/BTB: First deposit to stBTD/stBTB (vault accrues interest), then stake stToken to FarmingPool to earn BRS\n///      - Other pools: Directly stake to FarmingPool, only earn BRS\ncontract StakingRouter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IFarmingPool public immutable farmingPool;\n\n    // stToken vault contracts\n    IERC4626 public immutable stBTD;\n    IERC4626 public immutable stBTB;\n\n    // Pool IDs for stBTD and stBTB in FarmingPool (regular pools, not virtual)\n    uint256 public stBTDPoolId;\n    uint256 public stBTBPoolId;\n\n    // Track user's pool participation for batch operations\n    mapping(address => uint256[]) private userPools;\n\n    event Staked(address indexed user, address indexed token, uint256 amount);\n    event Withdrawn(address indexed user, address indexed token, uint256 amount);\n    event RewardsClaimed(address indexed user, uint256 btdInterest, uint256 btbInterest, uint256 brsReward);\n\n    /** @notice Constructor */\n    constructor(\n        address _farmingPool,    // FarmingPool address\n        address _stBTD,          // stBTD vault\n        address _stBTB,          // stBTB vault\n        uint256 _stBTDPoolId,    // stBTD pool ID in FarmingPool\n        uint256 _stBTBPoolId     // stBTB pool ID in FarmingPool\n    ) Ownable(msg.sender) {\n        require(_farmingPool != address(0), \"Invalid FarmingPool address\");\n        require(_stBTD != address(0), \"Invalid stBTD address\");\n        require(_stBTB != address(0), \"Invalid stBTB address\");\n\n        farmingPool = IFarmingPool(_farmingPool);\n        stBTD = IERC4626(_stBTD);\n        stBTB = IERC4626(_stBTB);\n        stBTDPoolId = _stBTDPoolId;\n        stBTBPoolId = _stBTBPoolId;\n    }\n\n    // --- BTD Staking (Dual Rewards: BTD Interest + BRS) ---\n\n    /// @notice Stakes BTD to earn dual rewards\n    /// @dev Flow: BTD -> deposit to stBTD vault -> stake stBTD to FarmingPool\n    ///      Earns BTD interest (via stBTD appreciation) + BRS mining rewards\n    /// @param amount BTD amount to stake, precision 1e18, must be >= minimum stake amount\n    function stakeBTD(uint256 amount) external nonReentrant {\n        _stakeViaVault(stBTD, stBTDPoolId, amount);\n    }\n\n    /// @notice Redeems BTD\n    /// @dev Flow: withdraw stBTD from FarmingPool -> redeem BTD from vault -> transfer to user\n    ///      Redemption amount includes accumulated BTD interest\n    /// @param amount BTD amount to redeem, precision 1e18\n    function withdrawBTD(uint256 amount) external nonReentrant {\n        _withdrawViaVault(stBTD, stBTDPoolId, amount);\n    }\n\n    // --- BTB Staking (Dual Rewards: BTB Interest + BRS) ---\n\n    /// @notice Stakes BTB to earn dual rewards\n    /// @dev Flow: BTB -> deposit to stBTB vault -> stake stBTB to FarmingPool\n    ///      Earns BTB interest (via stBTB appreciation) + BRS mining rewards\n    /// @param amount BTB amount to stake, precision 1e18, must be >= minimum stake amount\n    function stakeBTB(uint256 amount) external nonReentrant {\n        _stakeViaVault(stBTB, stBTBPoolId, amount);\n    }\n\n    /// @notice Redeems BTB\n    /// @dev Flow: withdraw stBTB from FarmingPool -> redeem BTB from vault -> transfer to user\n    ///      Redemption amount includes accumulated BTB interest\n    /// @param amount BTB amount to redeem, precision 1e18\n    function withdrawBTB(uint256 amount) external nonReentrant {\n        _withdrawViaVault(stBTB, stBTBPoolId, amount);\n    }\n\n    // --- Single Token Staking (BRS Rewards Only) ---\n\n    /// @notice Stakes other tokens to earn BRS rewards\n    /// @dev Supports staking stBTD, stBTB, USDC, USDT, WBTC, BRS, LP tokens, etc.\n    ///      Only earns BRS mining rewards (unlike BTD/BTB which have dual rewards)\n    ///      Note: min/max USD value checks are handled by FarmingPool._deposit\n    /// @param poolId Pool ID in FarmingPool\n    /// @param amount Stake amount, precision depends on token\n    function stakeToken(uint256 poolId, uint256 amount) external nonReentrant {\n        require(amount > 0, \"Amount must be > 0\");\n\n        // Note: Due to different token precisions (6/8/18 decimals),\n        // specific min/max USD value validation is handled by FarmingPool._deposit\n\n        // Get pool token\n        (IERC20 lpToken, , , , , , , ) = farmingPool.poolInfo(poolId);\n\n        // Transfer token from user to this router (using SafeERC20)\n        IERC20(address(lpToken)).safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve and deposit to FarmingPool (on behalf of user)\n        IERC20(address(lpToken)).forceApprove(address(farmingPool), amount);\n        farmingPool.depositFor(poolId, amount, msg.sender);\n\n        // Track user's pool participation\n        _addUserPool(msg.sender, poolId);\n\n        emit Staked(msg.sender, address(lpToken), amount);\n    }\n\n    /// @notice Withdraws staked tokens from specified pool\n    /// @dev Withdraws staked tokens, automatically claims accumulated BRS rewards\n    ///      Note: min USD value check is handled by FarmingPool._withdraw\n    /// @param poolId Pool ID in FarmingPool\n    /// @param amount Withdraw amount\n    function withdrawToken(uint256 poolId, uint256 amount) external nonReentrant {\n        require(amount > 0, \"Amount must be > 0\");\n\n        // Note: Due to different token precisions (6/8/18 decimals),\n        // specific min USD value validation is handled by FarmingPool._withdraw\n\n        // Get pool token\n        (IERC20 lpToken, , , , , , , ) = farmingPool.poolInfo(poolId);\n\n        // Withdraw from FarmingPool (on behalf of user, send to router)\n        farmingPool.withdrawFor(poolId, amount, msg.sender, address(this));\n\n        // Transfer token back to user (using SafeERC20)\n        IERC20(address(lpToken)).safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, address(lpToken), amount);\n    }\n\n    // --- Reward Claiming ---\n\n    // NOTE: BTD/BTB interest is auto-accrued in stBTD/stBTB tokens.\n    // When you withdraw, you automatically receive the appreciated BTD/BTB amount.\n    // No separate interest claiming needed!\n\n    /// @notice Claims BRS rewards from stToken pools\n    /// @dev Claims BRS rewards from stBTD pool and stBTB pool\n    ///      Note: BTD/BTB interest auto-accumulates in stBTD/stBTB shares, no separate claiming needed\n    function claimBRSFromStTokenPools() external nonReentrant {\n        // Claim from stBTD pool (on behalf of user, rewards sent directly to them)\n        try farmingPool.claimFor(stBTDPoolId, msg.sender) {} catch {}\n\n        // Claim from stBTB pool (on behalf of user, rewards sent directly to them)\n        try farmingPool.claimFor(stBTBPoolId, msg.sender) {} catch {}\n    }\n\n    /// @notice Claims BRS rewards from specified pool\n    /// @dev Claims BRS rewards from a single pool without affecting staked principal\n    /// @param poolId Pool ID in FarmingPool\n    function claimBRSFromPool(uint256 poolId) external nonReentrant {\n        // Claim on behalf of user, rewards sent directly to them\n        farmingPool.claimFor(poolId, msg.sender);\n    }\n\n    /// @notice One-click claim all BRS rewards\n    /// @dev Claims BRS rewards from all pools the user participates in\n    ///      BTD/BTB interest auto-accumulates in stBTD/stBTB, no separate claiming needed\n    ///      Rewards sent directly to user via claimFor\n    function claimAll() external nonReentrant {\n        // Claim BRS from stToken pools (rewards sent directly to user)\n        try farmingPool.claimFor(stBTDPoolId, msg.sender) {} catch {}\n        try farmingPool.claimFor(stBTBPoolId, msg.sender) {} catch {}\n\n        // Claim BRS from user's other pools (rewards sent directly to user)\n        uint256[] memory pools = userPools[msg.sender];\n        for (uint256 i = 0; i < pools.length; i++) {\n            try farmingPool.claimFor(pools[i], msg.sender) {} catch {}\n        }\n    }\n\n    // --- View Functions ---\n\n    /// @notice Queries all pending BRS rewards for user\n    /// @dev Aggregates pending BRS rewards from all pools the user participates in\n    ///      Note: BTD/BTB interest is automatically reflected in stBTD/stBTB exchange rate\n    /// @param user User address\n    /// @return pendingBRS Total pending BRS amount, precision 1e18\n    function pendingRewards(address user) external view returns (uint256 pendingBRS) {\n        // Pending BRS from stToken pools\n        pendingBRS = farmingPool.pendingReward(stBTDPoolId, user)\n                   + farmingPool.pendingReward(stBTBPoolId, user);\n\n        // Pending BRS from user's other pools\n        uint256[] memory pools = userPools[user];\n        for (uint256 i = 0; i < pools.length; i++) {\n            pendingBRS += farmingPool.pendingReward(pools[i], user);\n        }\n    }\n\n    /// @notice Queries user's staked BTD/BTB equivalent amounts\n    /// @dev Converts stBTD/stBTB shares to equivalent BTD/BTB amounts (includes accumulated interest)\n    /// @param user User address\n    /// @return stakedBTD BTD equivalent amount (stBTD shares x exchange rate), precision 1e18\n    /// @return stakedBTB BTB equivalent amount (stBTB shares x exchange rate), precision 1e18\n    function stakedAmounts(address user) external view returns (\n        uint256 stakedBTD,\n        uint256 stakedBTB\n    ) {\n        // Get user's stBTD shares in FarmingPool\n        (uint256 stBTDShares, ) = farmingPool.userInfo(stBTDPoolId, user);\n        // Convert stBTD shares to BTD amount\n        stakedBTD = stBTD.convertToAssets(stBTDShares);\n\n        // Get user's stBTB shares in FarmingPool\n        (uint256 stBTBShares, ) = farmingPool.userInfo(stBTBPoolId, user);\n        // Convert stBTB shares to BTB amount\n        stakedBTB = stBTB.convertToAssets(stBTBShares);\n    }\n\n    /// @notice Queries user's staked amount in specified pool\n    /// @dev Returns user's staked amount in FarmingPool specified pool\n    /// @param user User address\n    /// @param poolId Pool ID\n    /// @return Staked amount, precision depends on token\n    function stakedInPool(address user, uint256 poolId) external view returns (uint256) {\n        (uint256 amount, ) = farmingPool.userInfo(poolId, user);\n        return amount;\n    }\n\n    // --- Internal Functions ---\n\n    /// @dev Internal function to stake tokens via ERC4626 vault for dual rewards\n    /// @param vault ERC4626 vault contract (stBTD or stBTB)\n    /// @param poolId Pool ID in FarmingPool\n    /// @param amount Underlying asset amount to stake (BTD or BTB)\n    function _stakeViaVault(\n        IERC4626 vault,\n        uint256 poolId,\n        uint256 amount\n    ) internal {\n        require(amount > 0, \"Amount must be > 0\");\n\n        // Check min/max operation value (BTD/BTB are 18 decimal stablecoins)\n        require(\n            amount >= Constants.MIN_STABLECOIN_18_AMOUNT,\n            \"Stake amount too small\"\n        );\n        require(\n            amount <= Constants.MAX_STABLECOIN_18_AMOUNT,\n            \"Stake amount too large\"\n        );\n\n        address assetAddress = address(vault.asset());\n        IERC20 asset = IERC20(assetAddress);\n\n        // Transfer asset from user to this router (using SafeERC20)\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve vault to take asset (using SafeERC20)\n        asset.forceApprove(address(vault), amount);\n\n        // Deposit asset to vault and receive shares\n        uint256 shares = vault.deposit(amount, address(this));\n\n        // Approve FarmingPool to take vault shares (using SafeERC20)\n        IERC20(address(vault)).forceApprove(address(farmingPool), shares);\n\n        // Stake vault shares in FarmingPool to earn BRS (on behalf of user)\n        farmingPool.depositFor(poolId, shares, msg.sender);\n\n        // Track user's pool participation\n        _addUserPool(msg.sender, poolId);\n\n        emit Staked(msg.sender, assetAddress, amount);\n    }\n\n    /// @dev Internal function to withdraw tokens via ERC4626 vault\n    /// @param vault ERC4626 vault contract (stBTD or stBTB)\n    /// @param poolId Pool ID in FarmingPool\n    /// @param amount Underlying asset amount to withdraw (BTD or BTB)\n    function _withdrawViaVault(\n        IERC4626 vault,\n        uint256 poolId,\n        uint256 amount\n    ) internal {\n        require(amount > 0, \"Amount must be > 0\");\n\n        // Check min operation value (BTD/BTB are 18 decimal stablecoins)\n        require(\n            amount >= Constants.MIN_STABLECOIN_18_AMOUNT,\n            \"Withdraw amount too small\"\n        );\n\n        // Calculate vault shares needed for this amount of asset\n        uint256 shares = vault.previewWithdraw(amount);\n\n        // Withdraw vault shares from FarmingPool (on behalf of user, send to router)\n        farmingPool.withdrawFor(poolId, shares, msg.sender, address(this));\n\n        // Redeem vault shares for asset (send asset directly to user)\n        vault.redeem(shares, msg.sender, address(this));\n\n        emit Withdrawn(msg.sender, address(vault.asset()), amount);\n    }\n\n    function _addUserPool(address user, uint256 poolId) internal {\n        uint256[] storage pools = userPools[user];\n        for (uint256 i = 0; i < pools.length; i++) {\n            if (pools[i] == poolId) return; // Already tracked\n        }\n        pools.push(poolId);\n    }\n}\n"
      }
    }
  }
}