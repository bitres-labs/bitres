{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-ead8c1463bca623b29f7b06c70ff5fc6b9f7618f",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/Treasury.sol": "project/contracts/Treasury.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/ConfigCore.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title ConfigCore\n * @notice Immutable configuration core - stores critical system addresses\n * @dev Cannot be changed after deployment, ensuring system core architecture stability\n * @dev All core addresses are set once via constructor and permanently fixed\n */\ncontract ConfigCore {\n    // ==================== Core Token Addresses (immutable) ====================\n\n    /// @notice WBTC token address - used for collateral to mint BTD\n    /// @dev Cannot be changed after deployment\n    address public immutable WBTC;\n\n    /// @notice BTD stablecoin address - primary stablecoin\n    /// @dev Cannot be changed after deployment\n    address public immutable BTD;\n\n    /// @notice BTB bond token address - redemption bonds\n    /// @dev Cannot be changed after deployment\n    address public immutable BTB;\n\n    /// @notice BRS governance token address - governance token\n    /// @dev Cannot be changed after deployment\n    address public immutable BRS;\n\n    /// @notice WETH token address - Wrapped ETH\n    /// @dev Cannot be changed after deployment\n    address public immutable WETH;\n\n    /// @notice USDC token address - stablecoin reserve\n    /// @dev Cannot be changed after deployment\n    address public immutable USDC;\n\n    /// @notice USDT token address - stablecoin reserve\n    /// @dev Cannot be changed after deployment\n    address public immutable USDT;\n\n    // ==================== Core Contract Addresses (storage - deferred binding) ====================\n    // These 5 contracts have circular dependencies with ConfigCore, so they use storage and are set via setCoreContracts()\n\n    /// @notice Treasury contract address - manages system assets\n    /// @dev Set once via setCoreContracts() and cannot be changed afterward\n    address public TREASURY;\n\n    /// @notice Minter contract address - handles BTD minting and redemption\n    /// @dev Set once via setCoreContracts() and cannot be changed afterward\n    address public MINTER;\n\n    /// @notice Price oracle address - provides WBTC price data\n    /// @dev Set once via setCoreContracts() and cannot be changed afterward\n    address public PRICE_ORACLE;\n\n    /// @notice IUSD manager address - manages Ideal USD inflation adjustments\n    /// @dev Set once via setCoreContracts() and cannot be changed afterward\n    address public IDEAL_USD_MANAGER;\n\n    /// @notice Interest pool address - manages BTD and BTB interest distribution\n    /// @dev Set once via setCoreContracts() and cannot be changed afterward\n    address public INTEREST_POOL;\n\n    /// @notice Flag indicating whether core contracts have been set\n    /// @dev Ensures setCoreContracts() can only be called once\n    bool public coreContractsSet;\n\n    /// @notice Flag indicating whether peripheral contracts have been set\n    /// @dev Ensures setPeripheralContracts() can only be called once\n    bool public peripheralContractsSet;\n\n    // ==================== Price Oracle Data Source Addresses (immutable) ====================\n\n    /// @notice Chainlink BTC/USD price feed address\n    /// @dev Cannot be changed after deployment\n    address public immutable CHAINLINK_BTC_USD;\n\n    /// @notice Chainlink WBTC/BTC price feed address\n    /// @dev Cannot be changed after deployment\n    address public immutable CHAINLINK_WBTC_BTC;\n\n    /// @notice Pyth WBTC price feed address\n    /// @dev Cannot be changed after deployment\n    address public immutable PYTH_WBTC;\n\n    /// @notice Redstone WBTC price feed address\n    /// @dev Cannot be changed after deployment\n    address public immutable REDSTONE_WBTC;\n\n    // ==================== Core Pool Addresses (deferred binding) ====================\n\n    /// @notice Staking router address - handles staking operation routing\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public STAKING_ROUTER;\n\n    /// @notice Farming pool address - BRS liquidity mining\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public FARMING_POOL;\n\n    /// @notice stBTD token address - BTD staking receipt\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public ST_BTD;\n\n    /// @notice stBTB token address - BTB staking receipt\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public ST_BTB;\n\n    /// @notice Governor contract address - DAO governance\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public GOVERNOR;\n\n    /// @notice TWAP oracle address - time-weighted average price oracle\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public TWAP_ORACLE;\n\n    // ==================== Uniswap V2 Pool Addresses (deferred binding) ====================\n\n    /// @notice WBTC-USDC Uniswap V2 pair address\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public POOL_WBTC_USDC;\n\n    /// @notice BTD-USDC Uniswap V2 pair address\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public POOL_BTD_USDC;\n\n    /// @notice BTB-BTD Uniswap V2 pair address\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public POOL_BTB_BTD;\n\n    /// @notice BRS-BTD Uniswap V2 pair address\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public POOL_BRS_BTD;\n\n    /**\n     * @notice Constructor - sets all non-circular-dependency addresses\n     * @dev The 5 core contracts with circular dependencies are set separately via setCoreContracts()\n     */\n    constructor(\n        address _wbtc,                 // WBTC token address\n        address _btd,                  // BTD stablecoin address\n        address _btb,                  // BTB bond token address\n        address _brs,                  // BRS governance token address\n        address _weth,                 // WETH token address\n        address _usdc,                 // USDC token address\n        address _usdt,                 // USDT token address\n        address _chainlinkBtcUsd,      // Chainlink BTC/USD price feed address\n        address _chainlinkWbtcBtc,     // Chainlink WBTC/BTC price feed address\n        address _pythWbtc,             // Pyth WBTC price feed address\n        address _redstoneWbtc          // Redstone WBTC price feed address\n    ) {\n        require(_wbtc != address(0), \"Invalid WBTC\");\n        require(_btd != address(0), \"Invalid BTD\");\n        require(_btb != address(0), \"Invalid BTB\");\n        require(_brs != address(0), \"Invalid BRS\");\n        require(_weth != address(0), \"Invalid WETH\");\n        require(_usdc != address(0), \"Invalid USDC\");\n        require(_usdt != address(0), \"Invalid USDT\");\n        require(_chainlinkBtcUsd != address(0), \"Invalid Chainlink BTC/USD\");\n        require(_chainlinkWbtcBtc != address(0), \"Invalid Chainlink WBTC/BTC\");\n        require(_pythWbtc != address(0), \"Invalid Pyth WBTC\");\n        require(_redstoneWbtc != address(0), \"Invalid Redstone WBTC\");\n\n        WBTC = _wbtc;\n        BTD = _btd;\n        BTB = _btb;\n        BRS = _brs;\n        WETH = _weth;\n        USDC = _usdc;\n        USDT = _usdt;\n        CHAINLINK_BTC_USD = _chainlinkBtcUsd;\n        CHAINLINK_WBTC_BTC = _chainlinkWbtcBtc;\n        PYTH_WBTC = _pythWbtc;\n        REDSTONE_WBTC = _redstoneWbtc;\n    }\n\n    /**\n     * @notice Sets the 5 core contract addresses with circular dependencies\n     * @dev Can only be called once, permanently locked after deployment\n     * @param _treasury Treasury contract address\n     * @param _minter Minter contract address\n     * @param _priceOracle Price oracle address\n     * @param _idealUSDManager IUSD manager address\n     * @param _interestPool Interest pool address\n     */\n    function setCoreContracts(\n        address _treasury,\n        address _minter,\n        address _priceOracle,\n        address _idealUSDManager,\n        address _interestPool\n    ) external {\n        require(!coreContractsSet, \"Core contracts already set\");\n        require(_treasury != address(0), \"Invalid Treasury\");\n        require(_minter != address(0), \"Invalid Minter\");\n        require(_priceOracle != address(0), \"Invalid PriceOracle\");\n        require(_idealUSDManager != address(0), \"Invalid IdealUSDManager\");\n        require(_interestPool != address(0), \"Invalid InterestPool\");\n\n        TREASURY = _treasury;\n        MINTER = _minter;\n        PRICE_ORACLE = _priceOracle;\n        IDEAL_USD_MANAGER = _idealUSDManager;\n        INTEREST_POOL = _interestPool;\n        coreContractsSet = true;\n    }\n\n    /**\n     * @notice Sets peripheral contracts and pools with circular dependencies\n     * @dev Can only be called once, permanently locked after deployment\n     */\n    function setPeripheralContracts(\n        address _stakingRouter,\n        address _farmingPool,\n        address _stBTD,\n        address _stBTB,\n        address _governor,\n        address _twapOracle,\n        address _poolWbtcUsdc,\n        address _poolBtdUsdc,\n        address _poolBtbBtd,\n        address _poolBrsBtd\n    ) external {\n        require(!peripheralContractsSet, \"Peripheral contracts already set\");\n        require(_stakingRouter != address(0), \"Invalid StakingRouter\");\n        require(_farmingPool != address(0), \"Invalid FarmingPool\");\n        require(_stBTD != address(0), \"Invalid stBTD\");\n        require(_stBTB != address(0), \"Invalid stBTB\");\n        require(_governor != address(0), \"Invalid Governor\");\n        require(_twapOracle != address(0), \"Invalid TWAPOracle\");\n        require(_poolWbtcUsdc != address(0), \"Invalid Pool WBTC/USDC\");\n        require(_poolBtdUsdc != address(0), \"Invalid Pool BTD/USDC\");\n        require(_poolBtbBtd != address(0), \"Invalid Pool BTB/BTD\");\n        require(_poolBrsBtd != address(0), \"Invalid Pool BRS/BTD\");\n\n        STAKING_ROUTER = _stakingRouter;\n        FARMING_POOL = _farmingPool;\n        ST_BTD = _stBTD;\n        ST_BTB = _stBTB;\n        GOVERNOR = _governor;\n        TWAP_ORACLE = _twapOracle;\n        POOL_WBTC_USDC = _poolWbtcUsdc;\n        POOL_BTD_USDC = _poolBtdUsdc;\n        POOL_BTB_BTD = _poolBtbBtd;\n        POOL_BRS_BTD = _poolBrsBtd;\n        peripheralContractsSet = true;\n    }\n}\n"
      },
      "project/contracts/interfaces/ITreasury.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title ITreasury - Standard interface for Treasury contract\n * @notice Defines the core functionality interface for the Treasury contract\n */\ninterface ITreasury {\n    // --- Asset Management ---\n    /**\n     * @notice Deposit WBTC from caller (Minter) to treasury\n     * @dev Minter must first receive WBTC from user and approve to Treasury before calling\n     * @param amt WBTC amount\n     */\n    function depositWBTC(uint256 amt) external;\n\n    /**\n     * @notice Withdraw WBTC from treasury to caller (Minter)\n     * @dev Minter is responsible for transferring WBTC to end user\n     * @param amt WBTC amount\n     */\n    function withdrawWBTC(uint256 amt) external;\n\n    /**\n     * @notice Compensate user with BRS tokens from treasury\n     * @param to Recipient address\n     * @param amt BRS amount\n     */\n    function compensate(address to, uint256 amt) external;\n\n    /**\n     * @notice Buyback BRS using BTD from Uniswap\n     * @param btdAmount BTD amount\n     * @param minBRSOut Minimum BRS output amount (slippage protection)\n     */\n    function buybackBRS(uint256 btdAmount, uint256 minBRSOut) external;\n\n    // --- Configuration Management ---\n    /**\n     * @notice Update Uniswap Router address\n     * @param newRouter New Router address\n     */\n    function setRouter(address newRouter) external;\n\n    // --- Query Functions ---\n    function getBalances()\n        external\n        view\n        returns (uint256 wbtcBalance, uint256 brsBalance, uint256 btdBalance);\n\n    function configCore() external view returns (address);\n    function router() external view returns (address);\n\n    // --- Events ---\n    event WBTCDeposited(address indexed from, uint256 amount);\n    event WBTCWithdrawn(address indexed to, uint256 amount);\n    event BRSCompensated(address indexed to, uint256 amount);\n    event BRSBuyback(uint256 btdAmount, uint256 brsReceived);\n}\n"
      },
      "project/contracts/libraries/Constants.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title Constants - BRS System Global Constants Library\n * @notice Centralized management of system-level immutable constants\n * @dev Uses library + internal constant to ensure compile-time inlining (zero gas overhead)\n *\n * Key features:\n * - internal constant is inlined by the compiler into contracts that use it\n * - Gas cost = 16 gas (same as local constant)\n * - Unified management, single source of truth\n * - Type-safe, compile-time checking\n */\nlibrary Constants {\n    // ============ Precision Constants ============\n\n    /// @notice 18 decimals precision (standard ERC20, USD prices)\n    uint256 internal constant PRECISION_18 = 1e18;\n\n    /// @notice 8 decimals precision (BTC)\n    uint256 internal constant PRECISION_8 = 1e8;\n\n    /// @notice 6 decimals precision (USDC/USDT)\n    uint256 internal constant PRECISION_6 = 1e6;\n\n    // ============ Precision Conversion Scale Constants ============\n\n    /// @notice WBTC (8 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-8) = 1e10, used for explicit precision conversion, avoiding runtime EXP calculation\n    uint256 internal constant SCALE_WBTC_TO_NORM = 1e10;\n\n    /// @notice USDC (6 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-6) = 1e12, used for explicit precision conversion\n    uint256 internal constant SCALE_USDC_TO_NORM = 1e12;\n\n    /// @notice USDT (6 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-6) = 1e12, used for explicit precision conversion (same as USDC)\n    uint256 internal constant SCALE_USDT_TO_NORM = 1e12;\n\n    /// @notice Normalized (18 decimals) to WBTC (8 decimals) scale factor\n    /// @dev 1e8, used for output precision conversion\n    uint256 internal constant SCALE_NORM_TO_WBTC = 1e8;\n\n    /// @notice Normalized (18 decimals) to USDC (6 decimals) scale factor\n    /// @dev 1e6, used for output precision conversion\n    uint256 internal constant SCALE_NORM_TO_USDC = 1e6;\n\n    /// @notice Normalized (18 decimals) to USDT (6 decimals) scale factor\n    /// @dev 1e6, used for output precision conversion (same as USDC)\n    uint256 internal constant SCALE_NORM_TO_USDT = 1e6;\n\n    // ============ Input Parameter Safety Limits ============\n\n    /// @notice Maximum input parameter value (overflow prevention)\n    /// @dev 1e33, two such values multiplied equals 1e66 < type(uint256).max (1.15e77)\n    /// With this design, most multiplication operations don't need safeMulDiv\n    uint256 internal constant MAX_INPUT_AMOUNT = 1e33;\n\n    // ============ Minimum Operation Amount Constants ============\n\n    /// @notice Minimum BTC operation amount per transaction (8 decimals)\n    /// @dev 1 satoshi, prevents dust attacks\n    uint256 internal constant MIN_BTC_AMOUNT = 1;\n\n    /// @notice Minimum ETH operation amount per transaction (18 decimals)\n    /// @dev 1e-8 ETH = 1e10 wei (0.00000001 ETH)\n    uint256 internal constant MIN_ETH_AMOUNT = 1e10;\n\n        /// @notice Minimum USD value for operations (18 decimals)\n    /// @dev Used in Minter, Treasury, and other scenarios involving USD value conversion\n    /// $0.001 USD, prevents dust attacks and precision loss\n    ///\n    /// Use cases:\n    /// - Minter.mintBTD(): Check mint USD value >= $0.001\n    /// - Minter.redeemBTD(): Check redeem USD value >= $0.001\n    /// - Treasury.buyback(): Check buyback USD value >= $0.001\n    uint256 internal constant MIN_USD_VALUE = 1e15;\n\n    /// @notice Minimum operation amount for 6-decimal stablecoins\n    /// @dev 0.001 USDC/USDT = 1000 units (6 decimals), prevents dust attacks\n    /// Applicable to: USDC, USDT\n    uint256 internal constant MIN_STABLECOIN_6_AMOUNT = 1000;\n\n    /// @notice Minimum operation amount for 18-decimal stablecoins\n    /// @dev 0.001 tokens = 1e15 (18 decimals), prevents dust attacks\n    /// Applicable to: BTD, BTB, stBTD, stBTB\n    ///\n    /// Use cases:\n    /// - InterestPool.stake(): Minimum stake amount for BTD/BTB\n    /// - StakingRouter: Minimum stake amount for stBTD/stBTB\n    uint256 internal constant MIN_STABLECOIN_18_AMOUNT = 1e15;\n\n    // ============ Maximum Single Operation Limits (Prevents Hacker Attacks and Overflow) ============\n\n    /// @notice Maximum WBTC amount per single operation\n    /// @dev 10,000 BTC (8 decimals = 10000 * 1e8)\n    /// Prevents hacker attacks and integer overflow, applies to all WBTC transfer/mint/redeem operations\n    uint256 internal constant MAX_WBTC_AMOUNT = 10_000 * 1e8;\n\n    /// @notice Maximum ETH amount per single operation\n    /// @dev 100,000 ETH (18 decimals = 100000 * 1e18)\n    /// Prevents hacker attacks and integer overflow\n    uint256 internal constant MAX_ETH_AMOUNT = 100_000 * 1e18;\n\n    /// @notice Maximum 6-decimal stablecoin amount per single operation\n    /// @dev 1 billion USDC/USDT (6 decimals = 1000000000 * 1e6)\n    /// Prevents hacker attacks and integer overflow\n    /// Applicable to: USDC, USDT\n    uint256 internal constant MAX_STABLECOIN_6_AMOUNT = 1_000_000_000 * 1e6;\n\n    /// @notice Maximum 18-decimal stablecoin amount per single operation\n    /// @dev 1 billion BTD/BTB/stBTD/stBTB (18 decimals = 1000000000 * 1e18)\n    /// Prevents hacker attacks and integer overflow\n    /// Applicable to: BTD, BTB, stBTD, stBTB and other 18-decimal stablecoins\n    uint256 internal constant MAX_STABLECOIN_18_AMOUNT = 1_000_000_000 * 1e18;\n\n    /// @notice Maximum USD value per single operation\n    /// @dev Equivalent to 1 billion USD (18 decimals = 1000000000 * 1e18)\n    /// Prevents hacker attacks and integer overflow, applies to all USD value calculations\n    uint256 internal constant MAX_USD_VALUE = 1_000_000_000 * 1e18;\n\n    /// @notice Percentage base (100%)\n    uint256 internal constant PERCENT_BASE = 100;\n\n    /// @notice Basis points base (10000 = 100.00%)\n    uint256 internal constant BPS_BASE = 10000;\n\n    // ============ Time Constants ============\n\n    /// @notice Seconds per year\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /// @notice Seconds per day\n    uint256 internal constant SECONDS_PER_DAY = 1 days;\n\n    /// @notice Seconds per week\n    uint256 internal constant SECONDS_PER_WEEK = 7 days;\n\n    /// @notice BTC halving cycle (4 years)\n    uint256 internal constant ERA_PERIOD = 4 * 365 days;\n\n    // ============ Inflation Parameter Constants ============\n\n    /// @notice Fixed annual inflation rate - 2%\n    /// @dev Fixed inflation target specified in whitepaper, used for IUSD (Ideal USD) calculation\n    /// 2% = 0.02 = 2e16 (18 decimals)\n    uint256 internal constant ANNUAL_INFLATION_RATE = 2e16;\n\n    /// @notice Monthly growth factor - (1.02)^(1/12)\n    /// @dev Calculated from 2% annual inflation\n    /// Formula: (1 + 0.02)^(1/12) = 1.001651581301920174\n    /// Calculated off-chain with high precision and stored with 18 decimals\n    uint256 internal constant MONTHLY_GROWTH_FACTOR = 1001651581301920174;\n\n    // ============ Supply Constants ============\n\n    /// @notice BRS maximum supply (2.1 billion, tribute to BTC's 21 million)\n    /// @dev Maximum supply of BRS tokens, the only definition in the system\n    uint256 internal constant BRS_MAX_SUPPLY = 2_100_000_000e18;\n}\n"
      },
      "project/contracts/Treasury.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./ConfigCore.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./libraries/Constants.sol\";\n\ninterface IUniswapV2Router {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n}\n\n/**\n * @title Treasury - Bitres System Treasury Contract\n * @notice Manages WBTC/BTD/BRS assets, provides liquidity support for Minter\n * @dev Core functions: WBTC deposit/withdraw, BRS compensation, BTD buyback BRS\n */\ncontract Treasury is Ownable, ReentrancyGuard, ITreasury {\n    using SafeERC20 for IERC20;\n\n    ConfigCore public immutable core;\n    address public override router;\n\n    /// @notice Router address update event\n    /// @param oldRouter Old Router address\n    /// @param newRouter New Router address\n    event RouterUpdated(address indexed oldRouter, address indexed newRouter);\n\n    /**\n     * @notice Constructor\n     * @dev Initializes treasury with owner, Config contract and Uniswap Router\n     */\n    constructor(\n        address initialOwner,  // Contract owner address, cannot be zero address\n        address _core,         // ConfigCore contract address, cannot be zero address\n        address routerAddr     // Uniswap V2 Router address (for swap), cannot be zero address\n    ) Ownable(initialOwner) {\n        require(initialOwner != address(0), \"Treasury: invalid owner\");\n        require(_core != address(0), \"Treasury: invalid core\");\n        require(routerAddr != address(0), \"Treasury: invalid router\");\n        core = ConfigCore(_core);\n        router = routerAddr;\n    }\n\n    /**\n     * @notice Modifier allowing only Minter contract to call\n     * @dev Protects core functions like WBTC deposit/withdraw and BRS compensation\n     * @dev Production must strictly limit - only Minter can call\n     */\n    modifier onlyMint() {\n        require(\n            msg.sender == core.MINTER(),\n            \"Treasury: only Minter\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Get ConfigCore contract address\n     * @dev Implements ITreasury interface\n     * @return ConfigCore contract address\n     */\n    function configCore() public view override returns (address) {\n        return address(core);\n    }\n\n    /**\n     * @notice Get WBTC token contract instance\n     * @dev Reads WBTC address from ConfigCore\n     * @return WBTC token contract interface\n     */\n    function WBTC() internal view returns (IERC20) {\n        return IERC20(core.WBTC());\n    }\n\n    /**\n     * @notice Get BRS token contract instance\n     * @dev Reads BRS address from ConfigCore\n     * @return BRS token contract interface\n     */\n    function BRS() internal view returns (IERC20) {\n        return IERC20(core.BRS());\n    }\n\n    /**\n     * @notice Get BTD token contract instance\n     * @dev Reads BTD address from ConfigCore\n     * @return BTD token contract interface\n     */\n    function BTD() internal view returns (IERC20) {\n        return IERC20(core.BTD());\n    }\n\n    /**\n     * @notice Deposit WBTC to treasury\n     * @dev Only Minter can call, used for storing collateral when minting BTD\n     * @dev Security: onlyMint modifier, reentrancy guard, amount validation, anti-hack limits\n     * @param amt WBTC amount (8 decimals)\n     */\n    function depositWBTC(uint256 amt) external override onlyMint nonReentrant {\n        require(amt >= Constants.MIN_BTC_AMOUNT, \"Treasury: amount too small\");\n        require(amt <= Constants.MAX_WBTC_AMOUNT, \"Treasury: exceeds max WBTC\");\n        WBTC().safeTransferFrom(msg.sender, address(this), amt);\n        emit ITreasury.WBTCDeposited(msg.sender, amt);\n    }\n\n    /**\n     * @notice Withdraw WBTC from treasury\n     * @dev Only Minter can call, used for returning collateral when redeeming BTD\n     * @dev Security: onlyMint modifier, reentrancy guard, balance check, anti-hack limits\n     * @param amt WBTC amount (8 decimals)\n     */\n    function withdrawWBTC(uint256 amt) external override onlyMint nonReentrant {\n        require(amt >= Constants.MIN_BTC_AMOUNT, \"Treasury: amount too small\");\n        require(amt <= Constants.MAX_WBTC_AMOUNT, \"Treasury: exceeds max WBTC\");\n        require(WBTC().balanceOf(address(this)) >= amt, \"Treasury: insufficient WBTC\");\n        WBTC().safeTransfer(msg.sender, amt);\n        emit ITreasury.WBTCWithdrawn(msg.sender, amt);\n    }\n\n    /**\n     * @notice Compensate users with BRS\n     * @dev Only Minter can call, used for compensation when CR<100%, actual payout limited by treasury BRS balance\n     * @dev Security: onlyMint modifier, reentrancy guard, address validation, amount validation, balance clamping\n     * @param to Address receiving compensation\n     * @param amt Requested BRS compensation amount (18 decimals), actual payout may be less\n     */\n    function compensate(address to, uint256 amt) external override onlyMint nonReentrant {\n        require(to != address(0), \"Treasury: zero address\");\n        require(amt >= Constants.MIN_STABLECOIN_18_AMOUNT, \"Treasury: amount too small\");\n        require(amt <= Constants.MAX_STABLECOIN_18_AMOUNT, \"Treasury: exceeds max BRS\");\n        uint256 balance = BRS().balanceOf(address(this));\n        uint256 payout = amt > balance ? balance : amt;\n        if (payout > 0) {\n            BRS().safeTransfer(to, payout);\n            emit ITreasury.BRSCompensated(to, payout);\n        }\n    }\n\n    /**\n     * @notice Buyback BRS with BTD on Uniswap\n     * @dev Only owner can call, used to replenish treasury BRS reserves when market conditions allow\n     * @dev Security: onlyOwner modifier, reentrancy guard, amount validation, slippage protection\n     * @param btdAmount BTD amount for buyback (18 decimals)\n     * @param minBRSOut Minimum BRS to receive (18 decimals), slippage protection\n     */\n    function buybackBRS(uint256 btdAmount, uint256 minBRSOut) external override onlyOwner nonReentrant {\n        require(btdAmount >= Constants.MIN_STABLECOIN_18_AMOUNT, \"Treasury: BTD amount too small\");\n        require(btdAmount <= Constants.MAX_STABLECOIN_18_AMOUNT, \"Treasury: BTD amount too large\");\n        require(minBRSOut >= Constants.MIN_STABLECOIN_18_AMOUNT, \"Treasury: minBRSOut too small\");\n        require(minBRSOut <= Constants.MAX_STABLECOIN_18_AMOUNT, \"Treasury: minBRSOut too large\");\n        require(BTD().balanceOf(address(this)) >= btdAmount, \"Treasury: insufficient BTD\");\n\n        BTD().forceApprove(router, btdAmount);\n        address[] memory path = new address[](2);\n        path[0] = core.BTD();\n        path[1] = core.BRS();\n\n        uint256 beforeBal = BRS().balanceOf(address(this));\n        IUniswapV2Router(router).swapExactTokensForTokens(\n            btdAmount,\n            minBRSOut,\n            path,\n            address(this),\n            block.timestamp + 600\n        );\n        uint256 received = BRS().balanceOf(address(this)) - beforeBal;\n        emit ITreasury.BRSBuyback(btdAmount, received);\n    }\n\n    /**\n     * @notice Set Uniswap Router address\n     * @dev Only owner can call, used to update or fix Router configuration\n     * @param newRouter New Uniswap V2 Router address, cannot be zero address\n     */\n    function setRouter(address newRouter) external override onlyOwner {\n        require(newRouter != address(0), \"Treasury: invalid router\");\n        address old = router;\n        router = newRouter;\n        emit RouterUpdated(old, newRouter);\n    }\n\n    /**\n     * @notice Query all token balances in treasury\n     * @dev Returns WBTC, BRS, BTD balances at once\n     * @return wbtcBalance WBTC balance (8 decimals)\n     * @return brsBalance BRS balance (18 decimals)\n     * @return btdBalance BTD balance (18 decimals)\n     */\n    function getBalances()\n        external\n        view\n        override\n        returns (uint256 wbtcBalance, uint256 brsBalance, uint256 btdBalance)\n    {\n        wbtcBalance = WBTC().balanceOf(address(this));\n        brsBalance = BRS().balanceOf(address(this));\n        btdBalance = BTD().balanceOf(address(this));\n    }\n}\n"
      }
    }
  }
}