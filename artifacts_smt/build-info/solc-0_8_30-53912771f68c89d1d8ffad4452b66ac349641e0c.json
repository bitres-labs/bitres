{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-53912771f68c89d1d8ffad4452b66ac349641e0c",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/BRS.sol": "project/contracts/BRS.sol",
    "contracts/BTB.sol": "project/contracts/BTB.sol",
    "contracts/BTD.sol": "project/contracts/BTD.sol",
    "contracts/ConfigCore.sol": "project/contracts/ConfigCore.sol",
    "contracts/ConfigGov.sol": "project/contracts/ConfigGov.sol",
    "contracts/extensions/ERC20BlocklistUpgradeable.sol": "project/contracts/extensions/ERC20BlocklistUpgradeable.sol",
    "contracts/extensions/ERC20CustodianUpgradeable.sol": "project/contracts/extensions/ERC20CustodianUpgradeable.sol",
    "contracts/FarmingPool.sol": "project/contracts/FarmingPool.sol",
    "contracts/Governor.sol": "project/contracts/Governor.sol",
    "contracts/IdealUSDManager.sol": "project/contracts/IdealUSDManager.sol",
    "contracts/InterestPool.sol": "project/contracts/InterestPool.sol",
    "contracts/interfaces/IAggregatorV3.sol": "project/contracts/interfaces/IAggregatorV3.sol",
    "contracts/interfaces/IFarmingPool.sol": "project/contracts/interfaces/IFarmingPool.sol",
    "contracts/interfaces/IFunctionsRouter.sol": "project/contracts/interfaces/IFunctionsRouter.sol",
    "contracts/interfaces/IIdealUSDManager.sol": "project/contracts/interfaces/IIdealUSDManager.sol",
    "contracts/interfaces/IInterestPool.sol": "project/contracts/interfaces/IInterestPool.sol",
    "contracts/interfaces/IMintableERC20.sol": "project/contracts/interfaces/IMintableERC20.sol",
    "contracts/interfaces/IMinter.sol": "project/contracts/interfaces/IMinter.sol",
    "contracts/interfaces/IPriceOracle.sol": "project/contracts/interfaces/IPriceOracle.sol",
    "contracts/interfaces/ITreasury.sol": "project/contracts/interfaces/ITreasury.sol",
    "contracts/interfaces/IUniswapV2Callee.sol": "project/contracts/interfaces/IUniswapV2Callee.sol",
    "contracts/interfaces/IUniswapV2Factory.sol": "project/contracts/interfaces/IUniswapV2Factory.sol",
    "contracts/interfaces/IUniswapV2Pair.sol": "project/contracts/interfaces/IUniswapV2Pair.sol",
    "contracts/interfaces/IUniswapV2TWAPOracle.sol": "project/contracts/interfaces/IUniswapV2TWAPOracle.sol",
    "contracts/libraries/CollateralMath.sol": "project/contracts/libraries/CollateralMath.sol",
    "contracts/libraries/Constants.sol": "project/contracts/libraries/Constants.sol",
    "contracts/libraries/FeedValidation.sol": "project/contracts/libraries/FeedValidation.sol",
    "contracts/libraries/InterestMath.sol": "project/contracts/libraries/InterestMath.sol",
    "contracts/libraries/IUSDMath.sol": "project/contracts/libraries/IUSDMath.sol",
    "contracts/libraries/MintLogic.sol": "project/contracts/libraries/MintLogic.sol",
    "contracts/libraries/OracleMath.sol": "project/contracts/libraries/OracleMath.sol",
    "contracts/libraries/PriceBlend.sol": "project/contracts/libraries/PriceBlend.sol",
    "contracts/libraries/RedeemLogic.sol": "project/contracts/libraries/RedeemLogic.sol",
    "contracts/libraries/RewardMath.sol": "project/contracts/libraries/RewardMath.sol",
    "contracts/local/MockAggregatorV3.sol": "project/contracts/local/MockAggregatorV3.sol",
    "contracts/local/MockFunctionsRouter.sol": "project/contracts/local/MockFunctionsRouter.sol",
    "contracts/local/MockIUSDManager.sol": "project/contracts/local/MockIUSDManager.sol",
    "contracts/local/MockPriceOracle.sol": "project/contracts/local/MockPriceOracle.sol",
    "contracts/local/MockPyth.sol": "project/contracts/local/MockPyth.sol",
    "contracts/local/MockRedstone.sol": "project/contracts/local/MockRedstone.sol",
    "contracts/local/MockUSDC.sol": "project/contracts/local/MockUSDC.sol",
    "contracts/local/MockUSDT.sol": "project/contracts/local/MockUSDT.sol",
    "contracts/local/MockWBTC.sol": "project/contracts/local/MockWBTC.sol",
    "contracts/local/MockWETH.sol": "project/contracts/local/MockWETH.sol",
    "contracts/local/UniswapV2Pair.sol": "project/contracts/local/UniswapV2Pair.sol",
    "contracts/Minter.sol": "project/contracts/Minter.sol",
    "contracts/PriceOracle.sol": "project/contracts/PriceOracle.sol",
    "contracts/StakingRouter.sol": "project/contracts/StakingRouter.sol",
    "contracts/stBTB.sol": "project/contracts/stBTB.sol",
    "contracts/stBTD.sol": "project/contracts/stBTD.sol",
    "contracts/Treasury.sol": "project/contracts/Treasury.sol",
    "contracts/UniswapV2TWAPOracle.sol": "project/contracts/UniswapV2TWAPOracle.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "modelChecker": {
        "engine": "chc",
        "targets": [
          "assert",
          "underflow",
          "overflow",
          "divByZero"
        ],
        "timeout": 60000,
        "contracts": {
          "contracts/libraries/CollateralMath.sol": [
            "CollateralMath"
          ],
          "contracts/libraries/InterestMath.sol": [
            "InterestMath"
          ],
          "contracts/libraries/IUSDMath.sol": [
            "IUSDMath"
          ],
          "contracts/libraries/OracleMath.sol": [
            "OracleMath"
          ],
          "contracts/libraries/RewardMath.sol": [
            "RewardMath"
          ]
        }
      },
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@chainlink/contracts/=npm/@chainlink/contracts@1.4.0/",
        "project/:@chainlink/contracts/=npm/@chainlink/contracts@1.4.0/",
        "project/:@chainlink/contracts/=npm/@chainlink/contracts@1.4.0/",
        "project/:@chainlink/contracts/=npm/@chainlink/contracts@1.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@uniswap/v2-core/=npm/@uniswap/v2-core@1.0.1/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@chainlink/contracts@1.4.0/src/v0.8/functions/v1_0_0/interfaces/IFunctionsClient.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Chainlink Functions client interface.\ninterface IFunctionsClient {\n  /// @notice Chainlink Functions response handler called by the Functions Router\n  /// during fullilment from the designated transmitter node in an OCR round.\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\n  /// @param response Aggregated response from the request's source code.\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\n  /// @dev Either response or error parameter will be set, but never both.\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\n}\n"
      },
      "npm/@chainlink/contracts@1.4.0/src/v0.8/functions/v1_0_0/interfaces/IFunctionsRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Router interface.\ninterface IFunctionsRouter {\n  /// @notice The identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  /// @return id - bytes32 id that can be passed to the \"getContractById\" of the Router\n  function getAllowListId() external view returns (bytes32);\n\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  function setAllowListId(bytes32 allowListId) external;\n\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\n  /// @return adminFee\n  function getAdminFee() external view returns (uint72 adminFee);\n\n  /// @notice Sends a request using the provided subscriptionId\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequest(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Sends a request to the proposed contracts\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequestToProposed(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Fulfill the request by:\n  /// - calling back the data that the Oracle returned to the client contract\n  /// - pay the DON for processing the request\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\n  /// @param response response data from DON consensus\n  /// @param err error from DON consensus\n  /// @param juelsPerGas - current rate of juels/gas\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\n  /// @param transmitter - The Node that transmitted the OCR report\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\n  /// @return fulfillResult -\n  /// @return callbackGasCostJuels -\n  function fulfill(\n    bytes memory response,\n    bytes memory err,\n    uint96 juelsPerGas,\n    uint96 costWithoutFulfillment,\n    address transmitter,\n    FunctionsResponse.Commitment memory commitment\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\n\n  /// @notice Validate requested gas limit is below the subscription max.\n  /// @param subscriptionId subscription ID\n  /// @param callbackGasLimit desired callback gas limit\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\n\n  /// @notice Get the current contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current contract address\n  function getContractById(bytes32 id) external view returns (address);\n\n  /// @notice Get the proposed next contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current or proposed contract address\n  function getProposedContractById(bytes32 id) external view returns (address);\n\n  /// @notice Return the latest proprosal set\n  /// @return ids The identifiers of the contracts to update\n  /// @return to The addresses of the contracts that will be updated to\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\n\n  /// @notice Proposes one or more updates to the contract routes\n  /// @dev Only callable by owner\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\n\n  /// @notice Updates the current contract routes to the proposed contracts\n  /// @dev Only callable by owner\n  function updateContracts() external;\n\n  /// @dev Puts the system into an emergency stopped state.\n  /// @dev Only callable by owner\n  function pause() external;\n\n  /// @dev Takes the system out of an emergency stopped state.\n  /// @dev Only callable by owner\n  function unpause() external;\n}\n"
      },
      "npm/@chainlink/contracts@1.4.0/src/v0.8/functions/v1_0_0/libraries/FunctionsResponse.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Library of types that are used for fulfillment of a Functions request\nlibrary FunctionsResponse {\n  // Used to send request information from the Router to the Coordinator\n  struct RequestMeta {\n    bytes data; // ══════════════════╸ CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\n    bytes32 flags; // ═══════════════╸ Per-subscription flags\n    address requestingContract; // ══╗ The client contract that is sending the request\n    uint96 availableBalance; // ═════╝ Common LINK balance of the subscription that is controlled by the Router to be used for all consumer requests.\n    uint72 adminFee; // ═════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint64 subscriptionId; //        ║ Identifier of the billing subscription that will be charged for the request\n    uint64 initiatedRequests; //     ║ The number of requests that have been started\n    uint32 callbackGasLimit; //      ║ The amount of gas that the callback to the consuming contract will be given\n    uint16 dataVersion; // ══════════╝ The version of the structure of the CBOR encoded request data\n    uint64 completedRequests; // ════╗ The number of requests that have successfully completed or timed out\n    address subscriptionOwner; // ═══╝ The owner of the billing subscription\n  }\n\n  enum FulfillResult {\n    FULFILLED, // 0\n    USER_CALLBACK_ERROR, // 1\n    INVALID_REQUEST_ID, // 2\n    COST_EXCEEDS_COMMITMENT, // 3\n    INSUFFICIENT_GAS_PROVIDED, // 4\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\n    INVALID_COMMITMENT // 6\n  }\n\n  struct Commitment {\n    bytes32 requestId; // ═════════════════╸ A unique identifier for a Chainlink Functions request\n    address coordinator; // ═══════════════╗ The Coordinator contract that manages the DON that is servicing a request\n    uint96 estimatedTotalCostJuels; // ════╝ The maximum cost in Juels (1e18) of LINK that will be charged to fulfill a request\n    address client; // ════════════════════╗ The client contract that sent the request\n    uint64 subscriptionId; //              ║ Identifier of the billing subscription that will be charged for the request\n    uint32 callbackGasLimit; // ═══════════╝ The amount of gas that the callback to the consuming contract will be given\n    uint72 adminFee; // ═══════════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint72 donFee; //                      ║ Fee (in Juels of LINK) that will be split between Node Operators for servicing a request\n    uint40 gasOverheadBeforeCallback; //   ║ Represents the average gas execution cost before the fulfillment callback.\n    uint40 gasOverheadAfterCallback; //    ║ Represents the average gas execution cost after the fulfillment callback.\n    uint32 timeoutTimestamp; // ═══════════╝ The timestamp at which a request will be eligible to be timed out\n  }\n}\n"
      },
      "npm/@chainlink/contracts@1.4.0/src/v0.8/shared/access/ConfirmedOwner.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
      },
      "npm/@chainlink/contracts@1.4.0/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
      },
      "npm/@chainlink/contracts@1.4.0/src/v0.8/shared/interfaces/IOwnable.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/access/AccessControlUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/governance/extensions/GovernorCountingSimpleUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorCountingSimple.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for simple, 3 options, vote counting.\n */\nabstract contract GovernorCountingSimpleUpgradeable is Initializable, GovernorUpgradeable {\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address voter => bool) hasVoted;\n    }\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorCountingSimple\n    struct GovernorCountingSimpleStorage {\n        mapping(uint256 proposalId => ProposalVote) _proposalVotes;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorCountingSimple\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorCountingSimpleStorageLocation = 0xa1cefa0f43667ef127a258e673c94202a79b656e62899531c4376d87a7f39800;\n\n    function _getGovernorCountingSimpleStorage() private pure returns (GovernorCountingSimpleStorage storage $) {\n        assembly {\n            $.slot := GovernorCountingSimpleStorageLocation\n        }\n    }\n\n    function __GovernorCountingSimple_init() internal onlyInitializing {\n    }\n\n    function __GovernorCountingSimple_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IGovernor\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    /// @inheritdoc IGovernor\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        return $._proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);\n    }\n\n    /// @inheritdoc GovernorUpgradeable\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory // params\n    ) internal virtual override returns (uint256) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        if (proposalVote.hasVoted[account]) {\n            revert GovernorAlreadyCastVote(account);\n        }\n        proposalVote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalVote.againstVotes += totalWeight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalVote.forVotes += totalWeight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalVote.abstainVotes += totalWeight;\n        } else {\n            revert GovernorInvalidVoteType();\n        }\n\n        return totalWeight;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/governance/extensions/GovernorSettingsUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorSettings.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for settings updatable through governance.\n */\nabstract contract GovernorSettingsUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorSettings\n    struct GovernorSettingsStorage {\n        // amount of token\n        uint256 _proposalThreshold;\n        // timepoint: limited to uint48 in core (same as clock() type)\n        uint48 _votingDelay;\n        // duration: limited to uint32 in core\n        uint32 _votingPeriod;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorSettings\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorSettingsStorageLocation = 0x00d7616c8fe29c6c2fbe1d0c5bc8f2faa4c35b43746e70b24b4d532752affd00;\n\n    function _getGovernorSettingsStorage() private pure returns (GovernorSettingsStorage storage $) {\n        assembly {\n            $.slot := GovernorSettingsStorageLocation\n        }\n    }\n\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /**\n     * @dev Initialize the governance parameters.\n     */\n    function __GovernorSettings_init(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        __GovernorSettings_init_unchained(initialVotingDelay, initialVotingPeriod, initialProposalThreshold);\n    }\n\n    function __GovernorSettings_init_unchained(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        _setVotingDelay(initialVotingDelay);\n        _setVotingPeriod(initialVotingPeriod);\n        _setProposalThreshold(initialProposalThreshold);\n    }\n\n    /// @inheritdoc IGovernor\n    function votingDelay() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._votingDelay;\n    }\n\n    /// @inheritdoc IGovernor\n    function votingPeriod() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._votingPeriod;\n    }\n\n    /// @inheritdoc GovernorUpgradeable\n    function proposalThreshold() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._proposalThreshold;\n    }\n\n    /**\n     * @dev Update the voting delay. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function setVotingDelay(uint48 newVotingDelay) public virtual onlyGovernance {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    /**\n     * @dev Update the voting period. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function setVotingPeriod(uint32 newVotingPeriod) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /**\n     * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    /**\n     * @dev Internal setter for the voting delay.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function _setVotingDelay(uint48 newVotingDelay) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        emit VotingDelaySet($._votingDelay, newVotingDelay);\n        $._votingDelay = newVotingDelay;\n    }\n\n    /**\n     * @dev Internal setter for the voting period.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function _setVotingPeriod(uint32 newVotingPeriod) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        if (newVotingPeriod == 0) {\n            revert GovernorInvalidVotingPeriod(0);\n        }\n        emit VotingPeriodSet($._votingPeriod, newVotingPeriod);\n        $._votingPeriod = newVotingPeriod;\n    }\n\n    /**\n     * @dev Internal setter for the proposal threshold.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        emit ProposalThresholdSet($._proposalThreshold, newProposalThreshold);\n        $._proposalThreshold = newProposalThreshold;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/governance/extensions/GovernorStorageUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorStorage.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that implements storage of proposal details. This modules also provides primitives for\n * the enumerability of proposals.\n *\n * Use cases for this module include:\n * - UIs that explore the proposal state without relying on event indexing.\n * - Using only the proposalId as an argument in the {Governor-queue} and {Governor-execute} functions for L2 chains\n *   where storage is cheap compared to calldata.\n */\nabstract contract GovernorStorageUpgradeable is Initializable, GovernorUpgradeable {\n    struct ProposalDetails {\n        address[] targets;\n        uint256[] values;\n        bytes[] calldatas;\n        bytes32 descriptionHash;\n    }\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorStorage\n    struct GovernorStorageStorage {\n        uint256[] _proposalIds;\n        mapping(uint256 proposalId => ProposalDetails) _proposalDetails;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorStorage\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorStorageStorageLocation = 0x7fd223d3380145bd26132714391e777c488a0df7ac2dd4b66419d8549fb3a600;\n\n    function _getGovernorStorageStorage() private pure returns (GovernorStorageStorage storage $) {\n        assembly {\n            $.slot := GovernorStorageStorageLocation\n        }\n    }\n\n    function __GovernorStorage_init() internal onlyInitializing {\n    }\n\n    function __GovernorStorage_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Hook into the proposing mechanism\n     */\n    function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal virtual override returns (uint256) {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        uint256 proposalId = super._propose(targets, values, calldatas, description, proposer);\n\n        // store\n        $._proposalIds.push(proposalId);\n        $._proposalDetails[proposalId] = ProposalDetails({\n            targets: targets,\n            values: values,\n            calldatas: calldatas,\n            descriptionHash: keccak256(bytes(description))\n        });\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Version of {IGovernor-queue} with only `proposalId` as an argument.\n     */\n    function queue(uint256 proposalId) public virtual {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using storage is more efficient than memory\n        ProposalDetails storage details = $._proposalDetails[proposalId];\n        queue(details.targets, details.values, details.calldatas, details.descriptionHash);\n    }\n\n    /**\n     * @dev Version of {IGovernor-execute} with only `proposalId` as an argument.\n     */\n    function execute(uint256 proposalId) public payable virtual {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using storage is more efficient than memory\n        ProposalDetails storage details = $._proposalDetails[proposalId];\n        execute(details.targets, details.values, details.calldatas, details.descriptionHash);\n    }\n\n    /**\n     * @dev ProposalId version of {IGovernor-cancel}.\n     */\n    function cancel(uint256 proposalId) public virtual {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using storage is more efficient than memory\n        ProposalDetails storage details = $._proposalDetails[proposalId];\n        cancel(details.targets, details.values, details.calldatas, details.descriptionHash);\n    }\n\n    /**\n     * @dev Returns the number of stored proposals.\n     */\n    function proposalCount() public view virtual returns (uint256) {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        return $._proposalIds.length;\n    }\n\n    /**\n     * @dev Returns the details of a proposalId. Reverts if `proposalId` is not a known proposal.\n     */\n    function proposalDetails(\n        uint256 proposalId\n    )\n        public\n        view\n        virtual\n        returns (address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n    {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using memory is more efficient than storage\n        ProposalDetails memory details = $._proposalDetails[proposalId];\n        if (details.descriptionHash == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n        return (details.targets, details.values, details.calldatas, details.descriptionHash);\n    }\n\n    /**\n     * @dev Returns the details (including the proposalId) of a proposal given its sequential index.\n     */\n    function proposalDetailsAt(\n        uint256 index\n    )\n        public\n        view\n        virtual\n        returns (\n            uint256 proposalId,\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory calldatas,\n            bytes32 descriptionHash\n        )\n    {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        proposalId = $._proposalIds[index];\n        (targets, values, calldatas, descriptionHash) = proposalDetails(proposalId);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/governance/extensions/GovernorTimelockControlUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorTimelockControl.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {TimelockControllerUpgradeable} from \"../TimelockControllerUpgradeable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a\n * delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The\n * {Governor} needs the proposer (and ideally the executor and canceller) roles for the {Governor} to work properly.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible from a proposal, unless executed via {Governor-relay}.\n *\n * WARNING: Setting up the TimelockController to have additional proposers or cancelers besides the governor is very\n * risky, as it grants them the ability to: 1) execute operations as the timelock, and thus possibly performing\n * operations or accessing funds that are expected to only be accessible through a vote, and 2) block governance\n * proposals that have been approved by the voters, effectively executing a Denial of Service attack.\n */\nabstract contract GovernorTimelockControlUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorTimelockControl\n    struct GovernorTimelockControlStorage {\n        TimelockControllerUpgradeable _timelock;\n        mapping(uint256 proposalId => bytes32) _timelockIds;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorTimelockControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorTimelockControlStorageLocation = 0x0d5829787b8befdbc6044ef7457d8a95c2a04bc99235349f1a212c063e59d400;\n\n    function _getGovernorTimelockControlStorage() private pure returns (GovernorTimelockControlStorage storage $) {\n        assembly {\n            $.slot := GovernorTimelockControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        __GovernorTimelockControl_init_unchained(timelockAddress);\n    }\n\n    function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-state} function that considers the status reported by the timelock.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        ProposalState currentState = super.state(proposalId);\n\n        if (currentState != ProposalState.Queued) {\n            return currentState;\n        }\n\n        bytes32 queueid = $._timelockIds[proposalId];\n        if ($._timelock.isOperationPending(queueid)) {\n            return ProposalState.Queued;\n        } else if ($._timelock.isOperationDone(queueid)) {\n            // This can happen if the proposal is executed directly on the timelock.\n            return ProposalState.Executed;\n        } else {\n            // This can happen if the proposal is canceled directly on the timelock.\n            return ProposalState.Canceled;\n        }\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual returns (address) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        return address($._timelock);\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function _queueOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint48) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        uint256 delay = $._timelock.getMinDelay();\n\n        bytes32 salt = _timelockSalt(descriptionHash);\n        $._timelockIds[proposalId] = $._timelock.hashOperationBatch(targets, values, calldatas, 0, salt);\n        $._timelock.scheduleBatch(targets, values, calldatas, 0, salt, delay);\n\n        return SafeCast.toUint48(block.timestamp + delay);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_executeOperations} function that runs the already queued proposal\n     * through the timelock.\n     */\n    function _executeOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        // execute\n        $._timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, _timelockSalt(descriptionHash));\n        // cleanup for refund\n        delete $._timelockIds[proposalId];\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_cancel} function to cancel the timelocked proposal if it has already\n     * been queued.\n     */\n    // This function can reenter through the external call to the timelock, but we assume the timelock is trusted and\n    // well behaved (according to TimelockController) and this will not happen.\n    // slither-disable-next-line reentrancy-no-eth\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        bytes32 timelockId = $._timelockIds[proposalId];\n        if (timelockId != 0) {\n            // cancel\n            $._timelock.cancel(timelockId);\n            // cleanup\n            delete $._timelockIds[proposalId];\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        return address($._timelock);\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled, and executed through governance proposals.\n     *\n     * CAUTION: It is not recommended to change the timelock while there are other queued governance proposals.\n     */\n    function updateTimelock(TimelockControllerUpgradeable newTimelock) external virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        emit TimelockChange(address($._timelock), address(newTimelock));\n        $._timelock = newTimelock;\n    }\n\n    /**\n     * @dev Computes the {TimelockController} operation salt.\n     *\n     * It is computed with the governor address itself to avoid collisions across governor instances using the\n     * same timelock.\n     */\n    function _timelockSalt(bytes32 descriptionHash) private view returns (bytes32) {\n        return bytes20(address(this)) ^ descriptionHash;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorVotesQuorumFraction.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorVotesUpgradeable} from \"./GovernorVotesUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a\n * fraction of the total supply.\n */\nabstract contract GovernorVotesQuorumFractionUpgradeable is Initializable, GovernorVotesUpgradeable {\n    using Checkpoints for Checkpoints.Trace208;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorVotesQuorumFraction\n    struct GovernorVotesQuorumFractionStorage {\n        Checkpoints.Trace208 _quorumNumeratorHistory;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorVotesQuorumFraction\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorVotesQuorumFractionStorageLocation = 0xe770710421fd2cad75ad828c61aa98f2d77d423a440b67872d0f65554148e000;\n\n    function _getGovernorVotesQuorumFractionStorage() private pure returns (GovernorVotesQuorumFractionStorage storage $) {\n        assembly {\n            $.slot := GovernorVotesQuorumFractionStorageLocation\n        }\n    }\n\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n\n    /**\n     * @dev The quorum set is not a valid fraction.\n     */\n    error GovernorInvalidQuorumFraction(uint256 quorumNumerator, uint256 quorumDenominator);\n\n    /**\n     * @dev Initialize quorum as a fraction of the token's total supply.\n     *\n     * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is\n     * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be\n     * customized by overriding {quorumDenominator}.\n     */\n    function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {\n        __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);\n    }\n\n    function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }\n\n    /**\n     * @dev Returns the current quorum numerator. See {quorumDenominator}.\n     */\n    function quorumNumerator() public view virtual returns (uint256) {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        return $._quorumNumeratorHistory.latest();\n    }\n\n    /**\n     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.\n     */\n    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        return _optimisticUpperLookupRecent($._quorumNumeratorHistory, timepoint);\n    }\n\n    /**\n     * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.\n     */\n    function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.\n     */\n    function quorum(uint256 timepoint) public view virtual override returns (uint256) {\n        return Math.mulDiv(token().getPastTotalSupply(timepoint), quorumNumerator(timepoint), quorumDenominator());\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - Must be called through a governance proposal.\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        uint256 denominator = quorumDenominator();\n        if (newQuorumNumerator > denominator) {\n            revert GovernorInvalidQuorumFraction(newQuorumNumerator, denominator);\n        }\n\n        uint256 oldQuorumNumerator = quorumNumerator();\n        $._quorumNumeratorHistory.push(clock(), SafeCast.toUint208(newQuorumNumerator));\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }\n\n    /**\n     * @dev Returns the numerator at a specific timepoint.\n     */\n    function _optimisticUpperLookupRecent(\n        Checkpoints.Trace208 storage ckpts,\n        uint256 timepoint\n    ) internal view returns (uint256) {\n        // If trace is empty, key and value are both equal to 0.\n        // In that case `key <= timepoint` is true, and it is ok to return 0.\n        (, uint48 key, uint208 value) = ckpts.latestCheckpoint();\n        return key <= timepoint ? value : ckpts.upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/governance/extensions/GovernorVotesUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorVotes.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport {IERC5805} from \"@openzeppelin/contracts/interfaces/IERC5805.sol\";\nimport {Time} from \"@openzeppelin/contracts/utils/types/Time.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes}\n * token.\n */\nabstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorVotes\n    struct GovernorVotesStorage {\n        IERC5805 _token;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorVotes\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorVotesStorageLocation = 0x3ba4977254e415696610a40ebf2258dbfa0ec6a2ff64e84bfe715ff16977cc00;\n\n    function _getGovernorVotesStorage() private pure returns (GovernorVotesStorage storage $) {\n        assembly {\n            $.slot := GovernorVotesStorageLocation\n        }\n    }\n\n    function __GovernorVotes_init(IVotes tokenAddress) internal onlyInitializing {\n        __GovernorVotes_init_unchained(tokenAddress);\n    }\n\n    function __GovernorVotes_init_unchained(IVotes tokenAddress) internal onlyInitializing {\n        GovernorVotesStorage storage $ = _getGovernorVotesStorage();\n        $._token = IERC5805(address(tokenAddress));\n    }\n\n    /**\n     * @dev The token that voting power is sourced from.\n     */\n    function token() public view virtual returns (IERC5805) {\n        GovernorVotesStorage storage $ = _getGovernorVotesStorage();\n        return $._token;\n    }\n\n    /**\n     * @dev Clock (as specified in ERC-6372) is set to match the token's clock. Fallback to block numbers if the token\n     * does not implement ERC-6372.\n     */\n    function clock() public view virtual override returns (uint48) {\n        try token().clock() returns (uint48 timepoint) {\n            return timepoint;\n        } catch {\n            return Time.blockNumber();\n        }\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in ERC-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        try token().CLOCK_MODE() returns (string memory clockmode) {\n            return clockmode;\n        } catch {\n            return \"mode=blocknumber&from=default\";\n        }\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 timepoint,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token().getPastVotes(account, timepoint);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/governance/GovernorUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/Governor.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {EIP712Upgradeable} from \"../utils/cryptography/EIP712Upgradeable.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {DoubleEndedQueue} from \"@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {NoncesUpgradeable} from \"../utils/NoncesUpgradeable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended through various modules.\n *\n * This contract is abstract and requires several functions to be implemented in various modules:\n *\n * - A counting module must implement {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {_getVotes}\n * - Additionally, {votingPeriod}, {votingDelay}, and {quorum} must also be implemented\n */\nabstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, NoncesUpgradeable, IGovernor, IERC721Receiver, IERC1155Receiver {\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\n\n    bytes32 public constant BALLOT_TYPEHASH =\n        keccak256(\"Ballot(uint256 proposalId,uint8 support,address voter,uint256 nonce)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\n            \"ExtendedBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason,bytes params)\"\n        );\n\n    struct ProposalCore {\n        address proposer;\n        uint48 voteStart;\n        uint32 voteDuration;\n        bool executed;\n        bool canceled;\n        uint48 etaSeconds;\n    }\n\n    bytes32 private constant ALL_PROPOSAL_STATES_BITMAP = bytes32((2 ** (uint8(type(ProposalState).max) + 1)) - 1);\n    /// @custom:storage-location erc7201:openzeppelin.storage.Governor\n    struct GovernorStorage {\n        string _name;\n\n        mapping(uint256 proposalId => ProposalCore) _proposals;\n\n        // This queue keeps track of the governor operating on itself. Calls to functions protected by the {onlyGovernance}\n        // modifier needs to be whitelisted in this queue. Whitelisting is set in {execute}, consumed by the\n        // {onlyGovernance} modifier and eventually reset after {_executeOperations} completes. This ensures that the\n        // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n        DoubleEndedQueue.Bytes32Deque _governanceCall;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Governor\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorStorageLocation = 0x7c712897014dbe49c045ef1299aa2d5f9e67e48eea4403efa21f1e0f3ac0cb00;\n\n    function _getGovernorStorage() private pure returns (GovernorStorage storage $) {\n        assembly {\n            $.slot := GovernorStorageLocation\n        }\n    }\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        _checkGovernance();\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    function __Governor_init(string memory name_) internal onlyInitializing {\n        __EIP712_init_unchained(name_, version());\n        __Governor_init_unchained(name_);\n    }\n\n    function __Governor_init_unchained(string memory name_) internal onlyInitializing {\n        GovernorStorage storage $ = _getGovernorStorage();\n        $._name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IGovernor).interfaceId ||\n            interfaceId == type(IGovernor).interfaceId ^ IGovernor.getProposalId.selector ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IGovernor\n    function name() public view virtual returns (string memory) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._name;\n    }\n\n    /// @inheritdoc IGovernor\n    function version() public view virtual returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /// @inheritdoc IGovernor\n    function getProposalId(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public view virtual returns (uint256) {\n        return hashProposal(targets, values, calldatas, descriptionHash);\n    }\n\n    /// @inheritdoc IGovernor\n    function state(uint256 proposalId) public view virtual returns (ProposalState) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        // We read the struct fields into the stack at once so Solidity emits a single SLOAD\n        ProposalCore storage proposal = $._proposals[proposalId];\n        bool proposalExecuted = proposal.executed;\n        bool proposalCanceled = proposal.canceled;\n\n        if (proposalExecuted) {\n            return ProposalState.Executed;\n        }\n\n        if (proposalCanceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n\n        uint256 currentTimepoint = clock();\n\n        if (snapshot >= currentTimepoint) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= currentTimepoint) {\n            return ProposalState.Active;\n        } else if (!_quorumReached(proposalId) || !_voteSucceeded(proposalId)) {\n            return ProposalState.Defeated;\n        } else if (proposalEta(proposalId) == 0) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].voteStart;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].voteStart + $._proposals[proposalId].voteDuration;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalProposer(uint256 proposalId) public view virtual returns (address) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].proposer;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].etaSeconds;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalNeedsQueuing(uint256) public view virtual returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev Reverts if the `msg.sender` is not the executor. In case the executor is not this contract\n     * itself, the function reverts if `msg.data` is not whitelisted as a result of an {execute}\n     * operation. See {onlyGovernance}.\n     */\n    function _checkGovernance() internal virtual {\n        GovernorStorage storage $ = _getGovernorStorage();\n        if (_executor() != _msgSender()) {\n            revert GovernorOnlyExecutor(_msgSender());\n        }\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while ($._governanceCall.popFront() != msgDataHash) {}\n        }\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.\n     */\n    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory params\n    ) internal virtual returns (uint256);\n\n    /**\n     * @dev Hook that should be called every time the tally for a proposal is updated.\n     *\n     * Note: This function must run successfully. Reverts will result in the bricking of governance\n     */\n    function _tallyUpdated(uint256 proposalId) internal virtual {}\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256) {\n        address proposer = _msgSender();\n\n        // check description restriction\n        if (!_isValidDescriptionForProposer(proposer, description)) {\n            revert GovernorRestrictedProposer(proposer);\n        }\n\n        // check proposal threshold\n        uint256 votesThreshold = proposalThreshold();\n        if (votesThreshold > 0) {\n            uint256 proposerVotes = getVotes(proposer, clock() - 1);\n            if (proposerVotes < votesThreshold) {\n                revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);\n            }\n        }\n\n        return _propose(targets, values, calldatas, description, proposer);\n    }\n\n    /**\n     * @dev Internal propose mechanism. Can be overridden to add more logic on proposal creation.\n     *\n     * Emits a {IGovernor-ProposalCreated} event.\n     */\n    function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal virtual returns (uint256 proposalId) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        proposalId = getProposalId(targets, values, calldatas, keccak256(bytes(description)));\n\n        if (targets.length != values.length || targets.length != calldatas.length || targets.length == 0) {\n            revert GovernorInvalidProposalLength(targets.length, calldatas.length, values.length);\n        }\n        if ($._proposals[proposalId].voteStart != 0) {\n            revert GovernorUnexpectedProposalState(proposalId, state(proposalId), bytes32(0));\n        }\n\n        uint256 snapshot = clock() + votingDelay();\n        uint256 duration = votingPeriod();\n\n        ProposalCore storage proposal = $._proposals[proposalId];\n        proposal.proposer = proposer;\n        proposal.voteStart = SafeCast.toUint48(snapshot);\n        proposal.voteDuration = SafeCast.toUint32(duration);\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            snapshot + duration,\n            description\n        );\n\n        // Using a named return variable to avoid stack too deep errors\n    }\n\n    /// @inheritdoc IGovernor\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Succeeded));\n\n        uint48 etaSeconds = _queueOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        if (etaSeconds != 0) {\n            $._proposals[proposalId].etaSeconds = etaSeconds;\n            emit ProposalQueued(proposalId, etaSeconds);\n        } else {\n            revert GovernorQueueNotImplemented();\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal queuing mechanism. Can be overridden (without a super call) to modify the way queuing is\n     * performed (for example adding a vault/timelock).\n     *\n     * This is empty by default, and must be overridden to implement queuing.\n     *\n     * This function returns a timestamp that describes the expected ETA for execution. If the returned value is 0\n     * (which is the default value), the core will consider queueing did not succeed, and the public {queue} function\n     * will revert.\n     *\n     * NOTE: Calling this function directly will NOT check the current state of the proposal, or emit the\n     * `ProposalQueued` event. Queuing a proposal should be done using {queue}.\n     */\n    function _queueOperations(\n        uint256 /*proposalId*/,\n        address[] memory /*targets*/,\n        uint256[] memory /*values*/,\n        bytes[] memory /*calldatas*/,\n        bytes32 /*descriptionHash*/\n    ) internal virtual returns (uint48) {\n        return 0;\n    }\n\n    /// @inheritdoc IGovernor\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(\n            proposalId,\n            _encodeStateBitmap(ProposalState.Succeeded) | _encodeStateBitmap(ProposalState.Queued)\n        );\n\n        // mark as executed before calls to avoid reentrancy\n        $._proposals[proposalId].executed = true;\n\n        // before execute: register governance call in queue.\n        if (_executor() != address(this)) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                if (targets[i] == address(this)) {\n                    $._governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n\n        _executeOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        // after execute: cleanup governance call queue.\n        if (_executor() != address(this) && !$._governanceCall.empty()) {\n            $._governanceCall.clear();\n        }\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden (without a super call) to modify the way execution is\n     * performed (for example adding a vault/timelock).\n     *\n     * NOTE: Calling this function directly will NOT check the current state of the proposal, set the executed flag to\n     * true or emit the `ProposalExecuted` event. Executing a proposal should be done using {execute}.\n     */\n    function _executeOperations(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            Address.verifyCallResult(success, returndata);\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        // The proposalId will be recomputed in the `_cancel` call further down. However we need the value before we\n        // do the internal call, because we need to check the proposal state BEFORE the internal `_cancel` call\n        // changes it. The `getProposalId` duplication has a cost that is limited, and that we accept.\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        address caller = _msgSender();\n        if (!_validateCancel(proposalId, caller)) revert GovernorUnableToCancel(proposalId, caller);\n\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Internal cancel mechanism with minimal restrictions. A proposal can be cancelled in any state other than\n     * Canceled, Expired, or Executed. Once cancelled a proposal can't be re-submitted.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(\n            proposalId,\n            ALL_PROPOSAL_STATES_BITMAP ^\n                _encodeStateBitmap(ProposalState.Canceled) ^\n                _encodeStateBitmap(ProposalState.Expired) ^\n                _encodeStateBitmap(ProposalState.Executed)\n        );\n\n        $._proposals[proposalId].canceled = true;\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /// @inheritdoc IGovernor\n    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        return _getVotes(account, timepoint, _defaultParams());\n    }\n\n    /// @inheritdoc IGovernor\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual returns (uint256) {\n        return _getVotes(account, timepoint, params);\n    }\n\n    /// @inheritdoc IGovernor\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) public virtual returns (uint256) {\n        if (!_validateVoteSig(proposalId, support, voter, signature)) {\n            revert GovernorInvalidSignature(voter);\n        }\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string calldata reason,\n        bytes memory params,\n        bytes memory signature\n    ) public virtual returns (uint256) {\n        if (!_validateExtendedVoteSig(proposalId, support, voter, reason, params, signature)) {\n            revert GovernorInvalidSignature(voter);\n        }\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /// @dev Validate the `signature` used in {castVoteBySig} function.\n    function _validateVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) internal virtual returns (bool) {\n        return\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter)))),\n                signature\n            );\n    }\n\n    /// @dev Validate the `signature` used in {castVoteWithReasonAndParamsBySig} function.\n    function _validateExtendedVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string memory reason,\n        bytes memory params,\n        bytes memory signature\n    ) internal virtual returns (bool) {\n        return\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(\n                    keccak256(\n                        abi.encode(\n                            EXTENDED_BALLOT_TYPEHASH,\n                            proposalId,\n                            support,\n                            voter,\n                            _useNonce(voter),\n                            keccak256(bytes(reason)),\n                            keccak256(params)\n                        )\n                    )\n                ),\n                signature\n            );\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return _castVote(proposalId, account, support, reason, _defaultParams());\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Active));\n\n        uint256 totalWeight = _getVotes(account, proposalSnapshot(proposalId), params);\n        uint256 votedWeight = _countVote(proposalId, account, support, totalWeight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, votedWeight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, votedWeight, reason, params);\n        }\n\n        _tallyUpdated(proposalId);\n\n        return votedWeight;\n    }\n\n    /**\n     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor\n     * is some contract other than the governor itself, like when using a timelock, this function can be invoked\n     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.\n     * Note that if the executor is simply the governor itself, use of `relay` is redundant.\n     */\n    function relay(address target, uint256 value, bytes calldata data) external payable virtual onlyGovernance {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        Address.verifyCallResult(success, returndata);\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev Encodes a `ProposalState` into a `bytes32` representation where each bit enabled corresponds to\n     * the underlying position in the `ProposalState` enum. For example:\n     *\n     * 0x000...10000\n     *   ^^^^^^------ ...\n     *         ^----- Succeeded\n     *          ^---- Defeated\n     *           ^--- Canceled\n     *            ^-- Active\n     *             ^- Pending\n     */\n    function _encodeStateBitmap(ProposalState proposalState) internal pure returns (bytes32) {\n        return bytes32(1 << uint8(proposalState));\n    }\n\n    /**\n     * @dev Check that the current state of a proposal matches the requirements described by the `allowedStates` bitmap.\n     * This bitmap should be built using `_encodeStateBitmap`.\n     *\n     * If requirements are not met, reverts with a {GovernorUnexpectedProposalState} error.\n     */\n    function _validateStateBitmap(uint256 proposalId, bytes32 allowedStates) internal view returns (ProposalState) {\n        ProposalState currentState = state(proposalId);\n        if (_encodeStateBitmap(currentState) & allowedStates == bytes32(0)) {\n            revert GovernorUnexpectedProposalState(proposalId, currentState, allowedStates);\n        }\n        return currentState;\n    }\n\n    /*\n     * @dev Check if the proposer is authorized to submit a proposal with the given description.\n     *\n     * If the proposal description ends with `#proposer=0x???`, where `0x???` is an address written as a hex string\n     * (case insensitive), then the submission of this proposal will only be authorized to said address.\n     *\n     * This is used for frontrunning protection. By adding this pattern at the end of their proposal, one can ensure\n     * that no other address can submit the same proposal. An attacker would have to either remove or change that part,\n     * which would result in a different proposal id.\n     *\n     * If the description does not match this pattern, it is unrestricted and anyone can submit it. This includes:\n     * - If the `0x???` part is not a valid hex string.\n     * - If the `0x???` part is a valid hex string, but does not contain exactly 40 hex digits.\n     * - If it ends with the expected suffix followed by newlines or other whitespace.\n     * - If it ends with some other similar suffix, e.g. `#other=abc`.\n     * - If it does not end with any such suffix.\n     */\n    function _isValidDescriptionForProposer(\n        address proposer,\n        string memory description\n    ) internal view virtual returns (bool) {\n        unchecked {\n            uint256 length = bytes(description).length;\n\n            // Length is too short to contain a valid proposer suffix\n            if (length < 52) {\n                return true;\n            }\n\n            // Extract what would be the `#proposer=` marker beginning the suffix\n            bytes10 marker = bytes10(_unsafeReadBytesOffset(bytes(description), length - 52));\n\n            // If the marker is not found, there is no proposer suffix to check\n            if (marker != bytes10(\"#proposer=\")) {\n                return true;\n            }\n\n            // Check that the last 42 characters (after the marker) are a properly formatted address.\n            (bool success, address recovered) = Strings.tryParseAddress(description, length - 42, length);\n            return !success || recovered == proposer;\n        }\n    }\n\n    /**\n     * @dev Check if the `caller` can cancel the proposal with the given `proposalId`.\n     *\n     * The default implementation allows the proposal proposer to cancel the proposal during the pending state.\n     */\n    function _validateCancel(uint256 proposalId, address caller) internal view virtual returns (bool) {\n        return (state(proposalId) == ProposalState.Pending) && caller == proposalProposer(proposalId);\n    }\n\n    /// @inheritdoc IERC6372\n    function clock() public view virtual returns (uint48);\n\n    /// @inheritdoc IERC6372\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory);\n\n    /// @inheritdoc IGovernor\n    function votingDelay() public view virtual returns (uint256);\n\n    /// @inheritdoc IGovernor\n    function votingPeriod() public view virtual returns (uint256);\n\n    /// @inheritdoc IGovernor\n    function quorum(uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/governance/TimelockControllerUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.20;\n\nimport {AccessControlUpgradeable} from \"../access/AccessControlUpgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"../token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {ERC1155HolderUpgradeable} from \"../token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n */\ncontract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.TimelockController\n    struct TimelockControllerStorage {\n        mapping(bytes32 id => uint256) _timestamps;\n        uint256 _minDelay;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.TimelockController\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant TimelockControllerStorageLocation = 0x9a37c2aa9d186a0969ff8a8267bf4e07e864c2f2768f5040949e28a624fb3600;\n\n    function _getTimelockControllerStorage() private pure returns (TimelockControllerStorage storage $) {\n        assembly {\n            $.slot := TimelockControllerStorageLocation\n        }\n    }\n\n    enum OperationState {\n        Unset,\n        Waiting,\n        Ready,\n        Done\n    }\n\n    /**\n     * @dev Mismatch between the parameters length for an operation call.\n     */\n    error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);\n\n    /**\n     * @dev The schedule operation doesn't meet the minimum delay.\n     */\n    error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);\n\n    /**\n     * @dev The current state of an operation is not as required.\n     * The `expectedStates` is a bitmap with the bits enabled for each OperationState enum position\n     * counting from right to left.\n     *\n     * See {_encodeStateBitmap}.\n     */\n    error TimelockUnexpectedOperationState(bytes32 operationId, bytes32 expectedStates);\n\n    /**\n     * @dev The predecessor to an operation not yet done.\n     */\n    error TimelockUnexecutedPredecessor(bytes32 predecessorId);\n\n    /**\n     * @dev The caller account is not authorized.\n     */\n    error TimelockUnauthorizedCaller(address caller);\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\n     */\n    event CallSalt(bytes32 indexed id, bytes32 salt);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) public virtual initializer {\n        __TimelockController_init(minDelay, proposers, executors, admin);\n    }\n    /**\n     * @dev Initializes the contract with the following parameters:\n     *\n     * - `minDelay`: initial minimum delay in seconds for operations\n     * - `proposers`: accounts to be granted proposer and canceller roles\n     * - `executors`: accounts to be granted executor role\n     * - `admin`: optional account to be granted admin role; disable with zero address\n     *\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\n     * without being subject to delay, but this role should be subsequently renounced in favor of\n     * administration through timelocked proposals. Previous versions of this contract would assign\n     * this admin to the deployer automatically and should be renounced as well.\n     */\n    function __TimelockController_init(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        __TimelockController_init_unchained(minDelay, proposers, executors, admin);\n    }\n\n    function __TimelockController_init_unchained(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        // self administration\n        _grantRole(DEFAULT_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _grantRole(PROPOSER_ROLE, proposers[i]);\n            _grantRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _grantRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        $._minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable virtual {}\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlUpgradeable, ERC1155HolderUpgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id corresponds to a registered operation. This\n     * includes both Waiting, Ready, and Done operations.\n     */\n    function isOperation(bytes32 id) public view returns (bool) {\n        return getOperationState(id) != OperationState.Unset;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n     */\n    function isOperationPending(bytes32 id) public view returns (bool) {\n        OperationState state = getOperationState(id);\n        return state == OperationState.Waiting || state == OperationState.Ready;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n     */\n    function isOperationReady(bytes32 id) public view returns (bool) {\n        return getOperationState(id) == OperationState.Ready;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view returns (bool) {\n        return getOperationState(id) == OperationState.Done;\n    }\n\n    /**\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        return $._timestamps[id];\n    }\n\n    /**\n     * @dev Returns operation state.\n     */\n    function getOperationState(bytes32 id) public view virtual returns (OperationState) {\n        uint256 timestamp = getTimestamp(id);\n        if (timestamp == 0) {\n            return OperationState.Unset;\n        } else if (timestamp == _DONE_TIMESTAMP) {\n            return OperationState.Done;\n        } else if (timestamp > block.timestamp) {\n            return OperationState.Waiting;\n        } else {\n            return OperationState.Ready;\n        }\n    }\n\n    /**\n     * @dev Returns the minimum delay in seconds for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        return $._minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        if (targets.length != values.length || targets.length != payloads.length) {\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\n        }\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to become valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (isOperation(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset));\n        }\n        uint256 minDelay = getMinDelay();\n        if (delay < minDelay) {\n            revert TimelockInsufficientDelay(delay, minDelay);\n        }\n        $._timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (!isOperationPending(id)) {\n            revert TimelockUnexpectedOperationState(\n                id,\n                _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready)\n            );\n        }\n        delete $._timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        if (targets.length != values.length || targets.length != payloads.length) {\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\n        }\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        Address.verifyCallResult(success, returndata);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        if (!isOperationReady(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\n        }\n        if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {\n            revert TimelockUnexecutedPredecessor(predecessor);\n        }\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (!isOperationReady(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\n        }\n        $._timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        address sender = _msgSender();\n        if (sender != address(this)) {\n            revert TimelockUnauthorizedCaller(sender);\n        }\n        emit MinDelayChange($._minDelay, newDelay);\n        $._minDelay = newDelay;\n    }\n\n    /**\n     * @dev Encodes a `OperationState` into a `bytes32` representation where each bit enabled corresponds to\n     * the underlying position in the `OperationState` enum. For example:\n     *\n     * 0x000...1000\n     *   ^^^^^^----- ...\n     *         ^---- Done\n     *          ^--- Ready\n     *           ^-- Waiting\n     *            ^- Unset\n     */\n    function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) {\n        return bytes32(1 << uint8(operationState));\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/proxy/utils/UUPSUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.22;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC-1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/token/ERC1155/utils/ERC1155HolderUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n */\nabstract contract ERC1155HolderUpgradeable is Initializable, ERC165Upgradeable, IERC1155Receiver {\n    function __ERC1155Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/token/ERC20/ERC20Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/token/ERC721/utils/ERC721HolderUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\n * {IERC721-setApprovalForAll}.\n */\nabstract contract ERC721HolderUpgradeable is Initializable, IERC721Receiver {\n    function __ERC721Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/utils/ContextUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/utils/cryptography/EIP712Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: The upgradeable version of this contract does not use an immutable cache and recomputes the domain separator\n * each time {_domainSeparatorV4} is called. That is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        /// @custom:oz-renamed-from _HASHED_NAME\n        bytes32 _hashedName;\n        /// @custom:oz-renamed-from _HASHED_VERSION\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n\n        // Reset prior values in storage if upgrading\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /// @inheritdoc IERC5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require($._hashedName == 0 && $._hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/utils/introspection/ERC165Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/utils/NoncesUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract NoncesUpgradeable is Initializable {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Nonces\n    struct NoncesStorage {\n        mapping(address account => uint256) _nonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Nonces\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;\n\n    function _getNoncesStorage() private pure returns (NoncesStorage storage $) {\n        assembly {\n            $.slot := NoncesStorageLocation\n        }\n    }\n\n    function __Nonces_init() internal onlyInitializing {\n    }\n\n    function __Nonces_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        return $._nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return $._nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/access/AccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/access/IAccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/governance/IGovernor.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/IGovernor.sol)\n\npragma solidity >=0.8.4;\n\nimport {IERC165} from \"../interfaces/IERC165.sol\";\nimport {IERC6372} from \"../interfaces/IERC6372.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * NOTE: Event parameters lack the `indexed` keyword for compatibility with GovernorBravo events.\n * Making event parameters `indexed` affects how events are decoded, potentially breaking existing indexers.\n */\ninterface IGovernor is IERC165, IERC6372 {\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Empty proposal or a mismatch between the parameters length for a proposal call.\n     */\n    error GovernorInvalidProposalLength(uint256 targets, uint256 calldatas, uint256 values);\n\n    /**\n     * @dev The vote was already cast.\n     */\n    error GovernorAlreadyCastVote(address voter);\n\n    /**\n     * @dev Token deposits are disabled in this contract.\n     */\n    error GovernorDisabledDeposit();\n\n    /**\n     * @dev The `account` is not the governance executor.\n     */\n    error GovernorOnlyExecutor(address account);\n\n    /**\n     * @dev The `proposalId` doesn't exist.\n     */\n    error GovernorNonexistentProposal(uint256 proposalId);\n\n    /**\n     * @dev The current state of a proposal is not the required for performing an operation.\n     * The `expectedStates` is a bitmap with the bits enabled for each ProposalState enum position\n     * counting from right to left.\n     *\n     * NOTE: If `expectedState` is `bytes32(0)`, the proposal is expected to not be in any state (i.e. not exist).\n     * This is the case when a proposal that is expected to be unset is already initiated (the proposal is duplicated).\n     *\n     * See {Governor-_encodeStateBitmap}.\n     */\n    error GovernorUnexpectedProposalState(uint256 proposalId, ProposalState current, bytes32 expectedStates);\n\n    /**\n     * @dev The voting period set is not a valid period.\n     */\n    error GovernorInvalidVotingPeriod(uint256 votingPeriod);\n\n    /**\n     * @dev The `proposer` does not have the required votes to create a proposal.\n     */\n    error GovernorInsufficientProposerVotes(address proposer, uint256 votes, uint256 threshold);\n\n    /**\n     * @dev The `proposer` is not allowed to create a proposal.\n     */\n    error GovernorRestrictedProposer(address proposer);\n\n    /**\n     * @dev The vote type used is not valid for the corresponding counting module.\n     */\n    error GovernorInvalidVoteType();\n\n    /**\n     * @dev The provided params buffer is not supported by the counting module.\n     */\n    error GovernorInvalidVoteParams();\n\n    /**\n     * @dev Queue operation is not implemented for this governor. Execute should be called directly.\n     */\n    error GovernorQueueNotImplemented();\n\n    /**\n     * @dev The proposal hasn't been queued yet.\n     */\n    error GovernorNotQueuedProposal(uint256 proposalId);\n\n    /**\n     * @dev The proposal has already been queued.\n     */\n    error GovernorAlreadyQueuedProposal(uint256 proposalId);\n\n    /**\n     * @dev The provided signature is not valid for the expected `voter`.\n     * If the `voter` is a contract, the signature is not valid using {IERC1271-isValidSignature}.\n     */\n    error GovernorInvalidSignature(address voter);\n\n    /**\n     * @dev The given `account` is unable to cancel the proposal with given `proposalId`.\n     */\n    error GovernorUnableToCancel(uint256 proposalId, address account);\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 voteStart,\n        uint256 voteEnd,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is queued.\n     */\n    event ProposalQueued(uint256 proposalId, uint256 etaSeconds);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast without params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @dev Emitted when a vote is cast with params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     * `params` are additional encoded parameters. Their interpretation  also depends on the voting module used.\n     */\n    event VoteCastWithParams(\n        address indexed voter,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason,\n        bytes params\n    );\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the EIP-712 domain separator).\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the EIP-712 domain separator). Default: \"1\"\n     */\n    function version() external view returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique\n     * name that describes the behavior. For example:\n     *\n     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.\n     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() external view returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details.\n     *\n     * NOTE: For all off-chain and external calls, use {getProposalId}.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external pure returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Function used to get the proposal id from the proposal details.\n     */\n    function getProposalId(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) external view returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev The number of votes required in order for a voter to become a proposer.\n     */\n    function proposalThreshold() external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the\n     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the\n     * following block.\n     */\n    function proposalSnapshot(uint256 proposalId) external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is\n     * possible to cast a vote during this block.\n     */\n    function proposalDeadline(uint256 proposalId) external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev The account that created a proposal.\n     */\n    function proposalProposer(uint256 proposalId) external view returns (address);\n\n    /**\n     * @notice module:core\n     * @dev The time when a queued proposal becomes executable (\"ETA\"). Unlike {proposalSnapshot} and\n     * {proposalDeadline}, this doesn't use the governor clock, and instead relies on the executor's clock which may be\n     * different. In most cases this will be a timestamp.\n     */\n    function proposalEta(uint256 proposalId) external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Whether a proposal needs to be queued before execution.\n     */\n    function proposalNeedsQueuing(uint256 proposalId) external view returns (bool);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends\n     * on the clock (see ERC-6372) this contract uses.\n     *\n     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a\n     * proposal starts.\n     *\n     * NOTE: While this interface returns a uint256, timepoints are stored as uint48 following the ERC-6372 clock type.\n     * Consequently this value must fit in a uint48 (when added to the current clock). See {IERC6372-clock}.\n     */\n    function votingDelay() external view returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay between the vote start and vote end. The unit this duration is expressed in depends on the clock\n     * (see ERC-6372) this contract uses.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     *\n     * NOTE: This value is stored when the proposal is submitted so that possible changes to the value do not affect\n     * proposals that have already been submitted. The type used to save it is a uint32. Consequently, while this\n     * interface returns a uint256, the value it returns should fit in a uint32.\n     */\n    function votingPeriod() external view returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the\n     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).\n     */\n    function quorum(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) external view returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns whether `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) external view returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a\n     * duration specified by {IGovernor-votingPeriod}.\n     *\n     * Emits a {ProposalCreated} event.\n     *\n     * NOTE: The state of the Governor and `targets` may change between the proposal creation and its execution.\n     * This may be the result of third party actions on the targeted contracts, or other governor proposals.\n     * For example, the balance of this contract could be updated or its access control permissions may be modified,\n     * possibly compromising the proposal's ability to execute successfully (e.g. the governor doesn't have enough\n     * value to cover a proposal with multiple transfers).\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256 proposalId);\n\n    /**\n     * @dev Queue a proposal. Some governors require this step to be performed before execution can happen. If queuing\n     * is not necessary, this function may revert.\n     * Queuing a proposal requires the quorum to be reached, the vote to be successful, and the deadline to be reached.\n     *\n     * Emits a {ProposalQueued} event.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached. Depending on the governor it might also be required that the proposal was queued and\n     * that some delay passed.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * NOTE: Some modules can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external payable returns (uint256 proposalId);\n\n    /**\n     * @dev Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e.\n     * before the vote starts.\n     *\n     * Emits a {ProposalCanceled} event.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the voter's signature, including ERC-1271 signature support.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters using the voter's signature,\n     * including ERC-1271 signature support.\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string calldata reason,\n        bytes memory params,\n        bytes memory signature\n    ) external returns (uint256 balance);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/governance/utils/IVotes.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/utils/IVotes.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n */\ninterface IVotes {\n    /**\n     * @dev The signature used has expired.\n     */\n    error VotesExpiredSignature(uint256 expiry);\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of voting units.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/draft-IERC1822.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev ERC-1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/draft-IERC6093.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1271.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1271.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @dev Interface of the ERC-1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with `hash`\n     */\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1967.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1967.sol)\n\npragma solidity >=0.4.11;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC4626.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC4626.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC5267.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC5267.sol)\n\npragma solidity >=0.4.16;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC5805.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC5805.sol)\n\npragma solidity >=0.8.4;\n\nimport {IVotes} from \"../governance/utils/IVotes.sol\";\nimport {IERC6372} from \"./IERC6372.sol\";\n\ninterface IERC5805 is IERC6372, IVotes {}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC6372.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC6372.sol)\n\npragma solidity >=0.4.16;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC7913.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC7913.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @dev Signature verifier interface.\n */\ninterface IERC7913SignatureVerifier {\n    /**\n     * @dev Verifies `signature` as a valid signature of `hash` by `key`.\n     *\n     * MUST return the bytes4 magic value IERC7913SignatureVerifier.verify.selector if the signature is valid.\n     * SHOULD return 0xffffffff or revert if the signature is not valid.\n     * SHOULD return 0xffffffff or revert if the key is empty\n     */\n    function verify(bytes calldata key, bytes32 hash, bytes calldata signature) external view returns (bytes4);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/proxy/beacon/IBeacon.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/proxy/ERC1967/ERC1967Utils.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.21;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This library provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\n */\nlibrary ERC1967Utils {\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit IERC1967.Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit IERC1967.BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC1155/IERC1155Receiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/ERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/ERC20Burnable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/ERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC-20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /// @inheritdoc IERC20Permit\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /// @inheritdoc IERC20Permit\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /// @inheritdoc IERC20Permit\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/ERC4626.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";\nimport {SafeERC20} from \"../utils/SafeERC20.sol\";\nimport {IERC4626} from \"../../../interfaces/IERC4626.sol\";\nimport {Math} from \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC-4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC-20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC-20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation introduces configurable virtual assets and shares to help developers mitigate that risk.\n * The `_decimalsOffset()` corresponds to an offset in the decimal representation between the underlying asset's decimals\n * and the vault decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which\n * itself determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default\n * offset (0) makes it non-profitable even if an attacker is able to capture value from multiple user deposits, as a result\n * of the value being captured by the virtual shares (out of the attacker's donation) matching the attacker's expected gains.\n * With a larger offset, the attack becomes orders of magnitude more expensive than it is profitable. More details about the\n * underlying math can be found xref:ROOT:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _underlyingDecimals;\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC-20 or ERC-777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _underlyingDecimals + _decimalsOffset();\n    }\n\n    /// @inheritdoc IERC4626\n    function asset() public view virtual returns (address) {\n        return address(_asset);\n    }\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view virtual returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If asset() is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(IERC20(asset()), caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(IERC20(asset()), receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/IERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC721/IERC721Receiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Bytes.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Bytes.sol)\n\npragma solidity ^0.8.24;\n\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Bytes operations.\n */\nlibrary Bytes {\n    /**\n     * @dev Forward search for `s` in `buffer`\n     * * If `s` is present in the buffer, returns the index of the first instance\n     * * If `s` is not present in the buffer, returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf[Javascript's `Array.indexOf`]\n     */\n    function indexOf(bytes memory buffer, bytes1 s) internal pure returns (uint256) {\n        return indexOf(buffer, s, 0);\n    }\n\n    /**\n     * @dev Forward search for `s` in `buffer` starting at position `pos`\n     * * If `s` is present in the buffer (at or after `pos`), returns the index of the next instance\n     * * If `s` is not present in the buffer (at or after `pos`), returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf[Javascript's `Array.indexOf`]\n     */\n    function indexOf(bytes memory buffer, bytes1 s, uint256 pos) internal pure returns (uint256) {\n        uint256 length = buffer.length;\n        for (uint256 i = pos; i < length; ++i) {\n            if (bytes1(_unsafeReadBytesOffset(buffer, i)) == s) {\n                return i;\n            }\n        }\n        return type(uint256).max;\n    }\n\n    /**\n     * @dev Backward search for `s` in `buffer`\n     * * If `s` is present in the buffer, returns the index of the last instance\n     * * If `s` is not present in the buffer, returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf[Javascript's `Array.lastIndexOf`]\n     */\n    function lastIndexOf(bytes memory buffer, bytes1 s) internal pure returns (uint256) {\n        return lastIndexOf(buffer, s, type(uint256).max);\n    }\n\n    /**\n     * @dev Backward search for `s` in `buffer` starting at position `pos`\n     * * If `s` is present in the buffer (at or before `pos`), returns the index of the previous instance\n     * * If `s` is not present in the buffer (at or before `pos`), returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf[Javascript's `Array.lastIndexOf`]\n     */\n    function lastIndexOf(bytes memory buffer, bytes1 s, uint256 pos) internal pure returns (uint256) {\n        unchecked {\n            uint256 length = buffer.length;\n            for (uint256 i = Math.min(Math.saturatingAdd(pos, 1), length); i > 0; --i) {\n                if (bytes1(_unsafeReadBytesOffset(buffer, i - 1)) == s) {\n                    return i - 1;\n                }\n            }\n            return type(uint256).max;\n        }\n    }\n\n    /**\n     * @dev Copies the content of `buffer`, from `start` (included) to the end of `buffer` into a new bytes object in\n     * memory.\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice[Javascript's `Array.slice`]\n     */\n    function slice(bytes memory buffer, uint256 start) internal pure returns (bytes memory) {\n        return slice(buffer, start, buffer.length);\n    }\n\n    /**\n     * @dev Copies the content of `buffer`, from `start` (included) to `end` (excluded) into a new bytes object in\n     * memory.\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice[Javascript's `Array.slice`]\n     */\n    function slice(bytes memory buffer, uint256 start, uint256 end) internal pure returns (bytes memory) {\n        // sanitize\n        uint256 length = buffer.length;\n        end = Math.min(end, length);\n        start = Math.min(start, end);\n\n        // allocate and copy\n        bytes memory result = new bytes(end - start);\n        assembly (\"memory-safe\") {\n            mcopy(add(result, 0x20), add(add(buffer, 0x20), start), sub(end, start))\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/cryptography/ECDSA.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly (\"memory-safe\") {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/cryptography/EIP712.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    // slither-disable-next-line constable-states\n    string private _nameFallback;\n    // slither-disable-next-line constable-states\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /// @inheritdoc IERC5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/cryptography/MessageHashUtils.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Variant of {toDataWithIntendedValidatorHash-address-bytes} optimized for cases where `data` is a bytes32.\n     */\n    function toDataWithIntendedValidatorHash(\n        address validator,\n        bytes32 messageHash\n    ) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, hex\"19_00\")\n            mstore(0x02, shl(96, validator))\n            mstore(0x16, messageHash)\n            digest := keccak256(0x00, 0x36)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/cryptography/SignatureChecker.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.24;\n\nimport {ECDSA} from \"./ECDSA.sol\";\nimport {IERC1271} from \"../../interfaces/IERC1271.sol\";\nimport {IERC7913SignatureVerifier} from \"../../interfaces/IERC7913.sol\";\nimport {Bytes} from \"../../utils/Bytes.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support:\n *\n * * ECDSA signatures from externally owned accounts (EOAs)\n * * ERC-1271 signatures from smart contract wallets like Argent and Safe Wallet (previously Gnosis Safe)\n * * ERC-7913 signatures from keys that do not have an Ethereum address of their own\n *\n * See https://eips.ethereum.org/EIPS/eip-1271[ERC-1271] and https://eips.ethereum.org/EIPS/eip-7913[ERC-7913].\n */\nlibrary SignatureChecker {\n    using Bytes for bytes;\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer has code, the\n     * signature is validated against it using ERC-1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     *\n     * NOTE: For an extended version of this function that supports ERC-7913 signatures, see {isValidSignatureNow-bytes-bytes32-bytes-}.\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        if (signer.code.length == 0) {\n            (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);\n            return err == ECDSA.RecoverError.NoError && recovered == signer;\n        } else {\n            return isValidERC1271SignatureNow(signer, hash, signature);\n        }\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC-1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n\n    /**\n     * @dev Verifies a signature for a given ERC-7913 signer and hash.\n     *\n     * The signer is a `bytes` object that is the concatenation of an address and optionally a key:\n     * `verifier || key`. A signer must be at least 20 bytes long.\n     *\n     * Verification is done as follows:\n     *\n     * * If `signer.length < 20`: verification fails\n     * * If `signer.length == 20`: verification is done using {isValidSignatureNow}\n     * * Otherwise: verification is done using {IERC7913SignatureVerifier}\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(\n        bytes memory signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        if (signer.length < 20) {\n            return false;\n        } else if (signer.length == 20) {\n            return isValidSignatureNow(address(bytes20(signer)), hash, signature);\n        } else {\n            (bool success, bytes memory result) = address(bytes20(signer)).staticcall(\n                abi.encodeCall(IERC7913SignatureVerifier.verify, (signer.slice(20), hash, signature))\n            );\n            return (success &&\n                result.length >= 32 &&\n                abi.decode(result, (bytes32)) == bytes32(IERC7913SignatureVerifier.verify.selector));\n        }\n    }\n\n    /**\n     * @dev Verifies multiple ERC-7913 `signatures` for a given `hash` using a set of `signers`.\n     * Returns `false` if the number of signers and signatures is not the same.\n     *\n     * The signers should be ordered by their `keccak256` hash to ensure efficient duplication check. Unordered\n     * signers are supported, but the uniqueness check will be more expensive.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function areValidSignaturesNow(\n        bytes32 hash,\n        bytes[] memory signers,\n        bytes[] memory signatures\n    ) internal view returns (bool) {\n        if (signers.length != signatures.length) return false;\n\n        bytes32 lastId = bytes32(0);\n\n        for (uint256 i = 0; i < signers.length; ++i) {\n            bytes memory signer = signers[i];\n\n            // If one of the signatures is invalid, reject the batch\n            if (!isValidSignatureNow(signer, hash, signatures[i])) return false;\n\n            bytes32 id = keccak256(signer);\n            // If the current signer ID is greater than all previous IDs, then this is a new signer.\n            if (lastId < id) {\n                lastId = id;\n            } else {\n                // If this signer id is not greater than all the previous ones, verify that it is not a duplicate of a previous one\n                // This loop is never executed if the signers are ordered by id.\n                for (uint256 j = 0; j < i; ++j) {\n                    if (id == keccak256(signers[j])) return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/SafeCast.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/SignedMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Nonces.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Panic.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Pausable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ShortStrings.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        assembly (\"memory-safe\") {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {toShortStringWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {toShortStringWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/StorageSlot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Strings.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(add(buffer, 0x20), length)\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/structs/Checkpoints.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/structs/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\n\n/**\n * @dev This library defines the `Trace*` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.Trace*` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n */\nlibrary Checkpoints {\n    /**\n     * @dev A value was attempted to be inserted on a past checkpoint.\n     */\n    error CheckpointUnorderedInsertion();\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint32).max` key set will disable the\n     * library.\n     */\n    function push(\n        Trace224 storage self,\n        uint32 key,\n        uint224 value\n    ) internal returns (uint224 oldValue, uint224 newValue) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimized to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoints.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace224 storage self, uint32 pos) internal view returns (Checkpoint224 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint224 value\n    ) private returns (uint224 oldValue, uint224 newValue) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            Checkpoint224 storage last = _unsafeAccess(self, pos - 1);\n            uint32 lastKey = last._key;\n            uint224 lastValue = last._value;\n\n            // Checkpoint keys must be non-decreasing.\n            if (lastKey > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (lastKey == key) {\n                last._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (lastValue, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace208 {\n        Checkpoint208[] _checkpoints;\n    }\n\n    struct Checkpoint208 {\n        uint48 _key;\n        uint208 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace208 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint48).max` key set will disable the\n     * library.\n     */\n    function push(\n        Trace208 storage self,\n        uint48 key,\n        uint208 value\n    ) internal returns (uint208 oldValue, uint208 newValue) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimized to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace208 storage self) internal view returns (uint208) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace208 storage self) internal view returns (bool exists, uint48 _key, uint208 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint208 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoints.\n     */\n    function length(Trace208 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace208 storage self, uint32 pos) internal view returns (Checkpoint208 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint208 value\n    ) private returns (uint208 oldValue, uint208 newValue) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            Checkpoint208 storage last = _unsafeAccess(self, pos - 1);\n            uint48 lastKey = last._key;\n            uint208 lastValue = last._value;\n\n            // Checkpoint keys must be non-decreasing.\n            if (lastKey > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (lastKey == key) {\n                last._value = value;\n            } else {\n                self.push(Checkpoint208({_key: key, _value: value}));\n            }\n            return (lastValue, value);\n        } else {\n            self.push(Checkpoint208({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint208[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint208 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint96).max` key set will disable the\n     * library.\n     */\n    function push(\n        Trace160 storage self,\n        uint96 key,\n        uint160 value\n    ) internal returns (uint160 oldValue, uint160 newValue) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimized to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoints.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace160 storage self, uint32 pos) internal view returns (Checkpoint160 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint160 value\n    ) private returns (uint160 oldValue, uint160 newValue) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            Checkpoint160 storage last = _unsafeAccess(self, pos - 1);\n            uint96 lastKey = last._key;\n            uint160 lastValue = last._value;\n\n            // Checkpoint keys must be non-decreasing.\n            if (lastKey > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (lastKey == key) {\n                last._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (lastValue, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/structs/DoubleEndedQueue.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/structs/DoubleEndedQueue.sol)\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```solidity\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n */\nlibrary DoubleEndedQueue {\n    /**\n     * @dev Indices are 128 bits so begin and end are packed in a single storage slot for efficient access.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * The first item is at data[begin] and the last item is at data[end - 1]. This range can wrap around.\n     */\n    struct Bytes32Deque {\n        uint128 _begin;\n        uint128 _end;\n        mapping(uint128 index => bytes32) _data;\n    }\n\n    /**\n     * @dev Inserts an item at the end of the queue.\n     *\n     * Reverts with {Panic-RESOURCE_ERROR} if the queue is full.\n     */\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n        unchecked {\n            uint128 backIndex = deque._end;\n            if (backIndex + 1 == deque._begin) Panic.panic(Panic.RESOURCE_ERROR);\n            deque._data[backIndex] = value;\n            deque._end = backIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the end of the queue and returns it.\n     *\n     * Reverts with {Panic-EMPTY_ARRAY_POP} if the queue is empty.\n     */\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        unchecked {\n            uint128 backIndex = deque._end;\n            if (backIndex == deque._begin) Panic.panic(Panic.EMPTY_ARRAY_POP);\n            --backIndex;\n            value = deque._data[backIndex];\n            delete deque._data[backIndex];\n            deque._end = backIndex;\n        }\n    }\n\n    /**\n     * @dev Inserts an item at the beginning of the queue.\n     *\n     * Reverts with {Panic-RESOURCE_ERROR} if the queue is full.\n     */\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n        unchecked {\n            uint128 frontIndex = deque._begin - 1;\n            if (frontIndex == deque._end) Panic.panic(Panic.RESOURCE_ERROR);\n            deque._data[frontIndex] = value;\n            deque._begin = frontIndex;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the beginning of the queue and returns it.\n     *\n     * Reverts with {Panic-EMPTY_ARRAY_POP} if the queue is empty.\n     */\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        unchecked {\n            uint128 frontIndex = deque._begin;\n            if (frontIndex == deque._end) Panic.panic(Panic.EMPTY_ARRAY_POP);\n            value = deque._data[frontIndex];\n            delete deque._data[frontIndex];\n            deque._begin = frontIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Returns the item at the beginning of the queue.\n     *\n     * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the queue is empty.\n     */\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        return deque._data[deque._begin];\n    }\n\n    /**\n     * @dev Returns the item at the end of the queue.\n     *\n     * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the queue is empty.\n     */\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        unchecked {\n            return deque._data[deque._end - 1];\n        }\n    }\n\n    /**\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n     * `length(deque) - 1`.\n     *\n     * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the index is out of bounds.\n     */\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n        if (index >= length(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        // By construction, length is a uint128, so the check above ensures that index can be safely downcast to uint128\n        unchecked {\n            return deque._data[deque._begin + uint128(index)];\n        }\n    }\n\n    /**\n     * @dev Resets the queue back to being empty.\n     *\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n     * out on potential gas refunds.\n     */\n    function clear(Bytes32Deque storage deque) internal {\n        deque._begin = 0;\n        deque._end = 0;\n    }\n\n    /**\n     * @dev Returns the number of items in the queue.\n     */\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\n        unchecked {\n            return uint256(deque._end - deque._begin);\n        }\n    }\n\n    /**\n     * @dev Returns true if the queue is empty.\n     */\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\n        return deque._end == deque._begin;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/types/Time.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/types/Time.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\nimport {SafeCast} from \"../math/SafeCast.sol\";\n\n/**\n * @dev This library provides helpers for manipulating time-related objects.\n *\n * It uses the following types:\n * - `uint48` for timepoints\n * - `uint32` for durations\n *\n * While the library doesn't provide specific types for timepoints and duration, it does provide:\n * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point\n * - additional helper functions\n */\nlibrary Time {\n    using Time for *;\n\n    /**\n     * @dev Get the block timestamp as a Timepoint.\n     */\n    function timestamp() internal view returns (uint48) {\n        return SafeCast.toUint48(block.timestamp);\n    }\n\n    /**\n     * @dev Get the block number as a Timepoint.\n     */\n    function blockNumber() internal view returns (uint48) {\n        return SafeCast.toUint48(block.number);\n    }\n\n    // ==================================================== Delay =====================================================\n    /**\n     * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the\n     * future. The \"effect\" timepoint describes when the transitions happens from the \"old\" value to the \"new\" value.\n     * This allows updating the delay applied to some operation while keeping some guarantees.\n     *\n     * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for\n     * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set\n     * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should\n     * still apply for some time.\n     *\n     *\n     * The `Delay` type is 112 bits long, and packs the following:\n     *\n     * ```\n     *   | [uint48]: effect date (timepoint)\n     *   |           | [uint32]: value before (duration)\n     *   ↓           ↓       ↓ [uint32]: value after (duration)\n     * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC\n     * ```\n     *\n     * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently\n     * supported.\n     */\n    type Delay is uint112;\n\n    /**\n     * @dev Wrap a duration into a Delay to add the one-step \"update in the future\" feature\n     */\n    function toDelay(uint32 duration) internal pure returns (Delay) {\n        return Delay.wrap(duration);\n    }\n\n    /**\n     * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled\n     * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.\n     */\n    function _getFullAt(\n        Delay self,\n        uint48 timepoint\n    ) private pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        (valueBefore, valueAfter, effect) = self.unpack();\n        return effect <= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the\n     * effect timepoint is 0, then the pending value should not be considered.\n     */\n    function getFull(Delay self) internal view returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        return _getFullAt(self, timestamp());\n    }\n\n    /**\n     * @dev Get the current value.\n     */\n    function get(Delay self) internal view returns (uint32) {\n        (uint32 delay, , ) = self.getFull();\n        return delay;\n    }\n\n    /**\n     * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to\n     * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the\n     * new delay becomes effective.\n     */\n    function withUpdate(\n        Delay self,\n        uint32 newValue,\n        uint32 minSetback\n    ) internal view returns (Delay updatedDelay, uint48 effect) {\n        uint32 value = self.get();\n        uint32 setback = uint32(Math.max(minSetback, value > newValue ? value - newValue : 0));\n        effect = timestamp() + setback;\n        return (pack(value, newValue, effect), effect);\n    }\n\n    /**\n     * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).\n     */\n    function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        uint112 raw = Delay.unwrap(self);\n\n        valueAfter = uint32(raw);\n        valueBefore = uint32(raw >> 32);\n        effect = uint48(raw >> 64);\n\n        return (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev pack the components into a Delay object.\n     */\n    function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {\n        return Delay.wrap((uint112(effect) << 64) | (uint112(valueBefore) << 32) | uint112(valueAfter));\n    }\n}\n"
      },
      "npm/@uniswap/v2-core@1.0.1/contracts/interfaces/IUniswapV2Pair.sol": {
        "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
      },
      "project/contracts/BRS.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.5.0\npragma solidity ^0.8.27;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\n/**\n * @title BRS - Bitres Governance and Equity Token\n * @notice Governance token for the Bitres system, total supply 2.1 billion, minted at deployment\n * @dev Supports EIP-2612 Permit for gasless approvals\n *      Fixed total supply of 2,100,000,000 BRS, cannot be minted or burned after deployment\n *      Use cases:\n *      1. Governance voting: Holders can participate in on-chain governance proposals\n *      2. Revenue sharing: Part of protocol fees distributed to BRS holders\n *      3. System backstop: Used to compensate redeemers when collateral ratio is insufficient\n */\ncontract BRS is ERC20, ERC20Permit {\n    /** @notice Constructor, mints all 2.1 billion BRS to the specified recipient */\n    constructor(\n        address recipient  // Address to receive all BRS (typically multisig or distribution contract)\n    )\n        ERC20(\"Bitres\", \"BRS\")\n        ERC20Permit(\"Bitres\")\n    {\n        _mint(recipient, 2100000000 * 10 ** decimals());\n    }\n}\n"
      },
      "project/contracts/BTB.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.5.0\npragma solidity ^0.8.27;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title BTB - Bitcoin Bond Token\n * @notice Bond token for the Bitres system, issued as compensation to BTD redeemers when collateral ratio is insufficient\n * @dev Supports EIP-2612 Permit for gasless approvals\n *      When system collateral ratio recovers above 100%, BTB holders can redeem 1:1 for BTD\n *      Uses AccessControl for minting permissions, allowing multiple contracts (Minter, InterestPool) to mint\n *      After deployment, grant MINTER_ROLE to required contracts, then admin should renounce DEFAULT_ADMIN_ROLE\n */\ncontract BTB is ERC20, ERC20Burnable, AccessControl, ERC20Permit {\n    /// @notice Minter role identifier\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    /**\n     * @notice Constructor\n     * @param defaultAdmin Initial admin address (typically deployer, used to assign roles then renounce)\n     */\n    constructor(\n        address defaultAdmin\n    )\n        ERC20(\"Bitcoin Bond\", \"BTB\")\n        ERC20Permit(\"Bitcoin Bond\")\n    {\n        require(defaultAdmin != address(0), \"BTB: zero admin\");\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n    }\n\n    /**\n     * @notice Mint BTB (only MINTER_ROLE can call)\n     * @dev Can be called by Minter contract or InterestPool contract\n     * @param to Recipient address\n     * @param amount Mint amount (18 decimals)\n     */\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n}\n"
      },
      "project/contracts/BTD.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.5.0\npragma solidity ^0.8.27;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title BTD - Bitcoin Dollar Stablecoin\n * @notice Core stablecoin of the Bitres system, pegged to Ideal USD (IUSD), minted with WBTC collateral\n * @dev Supports EIP-2612 Permit for gasless approvals\n *      Uses AccessControl for minting permissions, allowing multiple contracts (Minter, InterestPool) to mint\n *      After deployment, grant MINTER_ROLE to required contracts, then admin should renounce DEFAULT_ADMIN_ROLE\n */\ncontract BTD is ERC20, ERC20Burnable, AccessControl, ERC20Permit {\n    /// @notice Minter role identifier\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    /**\n     * @notice Constructor\n     * @param defaultAdmin Initial admin address (typically deployer, used to assign roles then renounce)\n     */\n    constructor(\n        address defaultAdmin\n    )\n        ERC20(\"Bitcoin Dollar\", \"BTD\")\n        ERC20Permit(\"Bitcoin Dollar\")\n    {\n        require(defaultAdmin != address(0), \"BTD: zero admin\");\n        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n    }\n\n    /**\n     * @notice Mint BTD (only MINTER_ROLE can call)\n     * @dev Can be called by Minter contract or InterestPool contract\n     * @param to Recipient address\n     * @param amount Mint amount (18 decimals)\n     */\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n}\n"
      },
      "project/contracts/ConfigCore.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title ConfigCore\n * @notice Immutable configuration core - stores critical system addresses\n * @dev Cannot be changed after deployment, ensuring system core architecture stability\n * @dev All core addresses are set once via constructor and permanently fixed\n */\ncontract ConfigCore {\n    // ==================== Core Token Addresses (immutable) ====================\n\n    /// @notice WBTC token address - used for collateral to mint BTD\n    /// @dev Cannot be changed after deployment\n    address public immutable WBTC;\n\n    /// @notice BTD stablecoin address - primary stablecoin\n    /// @dev Cannot be changed after deployment\n    address public immutable BTD;\n\n    /// @notice BTB bond token address - redemption bonds\n    /// @dev Cannot be changed after deployment\n    address public immutable BTB;\n\n    /// @notice BRS governance token address - governance token\n    /// @dev Cannot be changed after deployment\n    address public immutable BRS;\n\n    /// @notice WETH token address - Wrapped ETH\n    /// @dev Cannot be changed after deployment\n    address public immutable WETH;\n\n    /// @notice USDC token address - stablecoin reserve\n    /// @dev Cannot be changed after deployment\n    address public immutable USDC;\n\n    /// @notice USDT token address - stablecoin reserve\n    /// @dev Cannot be changed after deployment\n    address public immutable USDT;\n\n    // ==================== Core Contract Addresses (storage - deferred binding) ====================\n    // These 5 contracts have circular dependencies with ConfigCore, so they use storage and are set via setCoreContracts()\n\n    /// @notice Treasury contract address - manages system assets\n    /// @dev Set once via setCoreContracts() and cannot be changed afterward\n    address public TREASURY;\n\n    /// @notice Minter contract address - handles BTD minting and redemption\n    /// @dev Set once via setCoreContracts() and cannot be changed afterward\n    address public MINTER;\n\n    /// @notice Price oracle address - provides WBTC price data\n    /// @dev Set once via setCoreContracts() and cannot be changed afterward\n    address public PRICE_ORACLE;\n\n    /// @notice IUSD manager address - manages Ideal USD inflation adjustments\n    /// @dev Set once via setCoreContracts() and cannot be changed afterward\n    address public IDEAL_USD_MANAGER;\n\n    /// @notice Interest pool address - manages BTD and BTB interest distribution\n    /// @dev Set once via setCoreContracts() and cannot be changed afterward\n    address public INTEREST_POOL;\n\n    /// @notice Flag indicating whether core contracts have been set\n    /// @dev Ensures setCoreContracts() can only be called once\n    bool public coreContractsSet;\n\n    /// @notice Flag indicating whether peripheral contracts have been set\n    /// @dev Ensures setPeripheralContracts() can only be called once\n    bool public peripheralContractsSet;\n\n    // ==================== Price Oracle Data Source Addresses (immutable) ====================\n\n    /// @notice Chainlink BTC/USD price feed address\n    /// @dev Cannot be changed after deployment\n    address public immutable CHAINLINK_BTC_USD;\n\n    /// @notice Chainlink WBTC/BTC price feed address\n    /// @dev Cannot be changed after deployment\n    address public immutable CHAINLINK_WBTC_BTC;\n\n    /// @notice Pyth WBTC price feed address\n    /// @dev Cannot be changed after deployment\n    address public immutable PYTH_WBTC;\n\n    /// @notice Redstone WBTC price feed address\n    /// @dev Cannot be changed after deployment\n    address public immutable REDSTONE_WBTC;\n\n    // ==================== Core Pool Addresses (deferred binding) ====================\n\n    /// @notice Staking router address - handles staking operation routing\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public STAKING_ROUTER;\n\n    /// @notice Farming pool address - BRS liquidity mining\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public FARMING_POOL;\n\n    /// @notice stBTD token address - BTD staking receipt\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public ST_BTD;\n\n    /// @notice stBTB token address - BTB staking receipt\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public ST_BTB;\n\n    /// @notice Governor contract address - DAO governance\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public GOVERNOR;\n\n    /// @notice TWAP oracle address - time-weighted average price oracle\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public TWAP_ORACLE;\n\n    // ==================== Uniswap V2 Pool Addresses (deferred binding) ====================\n\n    /// @notice WBTC-USDC Uniswap V2 pair address\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public POOL_WBTC_USDC;\n\n    /// @notice BTD-USDC Uniswap V2 pair address\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public POOL_BTD_USDC;\n\n    /// @notice BTB-BTD Uniswap V2 pair address\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public POOL_BTB_BTD;\n\n    /// @notice BRS-BTD Uniswap V2 pair address\n    /// @dev Set once via setPeripheralContracts() and cannot be changed afterward\n    address public POOL_BRS_BTD;\n\n    /**\n     * @notice Constructor - sets all non-circular-dependency addresses\n     * @dev The 5 core contracts with circular dependencies are set separately via setCoreContracts()\n     */\n    constructor(\n        address _wbtc,                 // WBTC token address\n        address _btd,                  // BTD stablecoin address\n        address _btb,                  // BTB bond token address\n        address _brs,                  // BRS governance token address\n        address _weth,                 // WETH token address\n        address _usdc,                 // USDC token address\n        address _usdt,                 // USDT token address\n        address _chainlinkBtcUsd,      // Chainlink BTC/USD price feed address\n        address _chainlinkWbtcBtc,     // Chainlink WBTC/BTC price feed address\n        address _pythWbtc,             // Pyth WBTC price feed address\n        address _redstoneWbtc          // Redstone WBTC price feed address\n    ) {\n        require(_wbtc != address(0), \"Invalid WBTC\");\n        require(_btd != address(0), \"Invalid BTD\");\n        require(_btb != address(0), \"Invalid BTB\");\n        require(_brs != address(0), \"Invalid BRS\");\n        require(_weth != address(0), \"Invalid WETH\");\n        require(_usdc != address(0), \"Invalid USDC\");\n        require(_usdt != address(0), \"Invalid USDT\");\n        require(_chainlinkBtcUsd != address(0), \"Invalid Chainlink BTC/USD\");\n        require(_chainlinkWbtcBtc != address(0), \"Invalid Chainlink WBTC/BTC\");\n        require(_pythWbtc != address(0), \"Invalid Pyth WBTC\");\n        require(_redstoneWbtc != address(0), \"Invalid Redstone WBTC\");\n\n        WBTC = _wbtc;\n        BTD = _btd;\n        BTB = _btb;\n        BRS = _brs;\n        WETH = _weth;\n        USDC = _usdc;\n        USDT = _usdt;\n        CHAINLINK_BTC_USD = _chainlinkBtcUsd;\n        CHAINLINK_WBTC_BTC = _chainlinkWbtcBtc;\n        PYTH_WBTC = _pythWbtc;\n        REDSTONE_WBTC = _redstoneWbtc;\n    }\n\n    /**\n     * @notice Sets the 5 core contract addresses with circular dependencies\n     * @dev Can only be called once, permanently locked after deployment\n     * @param _treasury Treasury contract address\n     * @param _minter Minter contract address\n     * @param _priceOracle Price oracle address\n     * @param _idealUSDManager IUSD manager address\n     * @param _interestPool Interest pool address\n     */\n    function setCoreContracts(\n        address _treasury,\n        address _minter,\n        address _priceOracle,\n        address _idealUSDManager,\n        address _interestPool\n    ) external {\n        require(!coreContractsSet, \"Core contracts already set\");\n        require(_treasury != address(0), \"Invalid Treasury\");\n        require(_minter != address(0), \"Invalid Minter\");\n        require(_priceOracle != address(0), \"Invalid PriceOracle\");\n        require(_idealUSDManager != address(0), \"Invalid IdealUSDManager\");\n        require(_interestPool != address(0), \"Invalid InterestPool\");\n\n        TREASURY = _treasury;\n        MINTER = _minter;\n        PRICE_ORACLE = _priceOracle;\n        IDEAL_USD_MANAGER = _idealUSDManager;\n        INTEREST_POOL = _interestPool;\n        coreContractsSet = true;\n    }\n\n    /**\n     * @notice Sets peripheral contracts and pools with circular dependencies\n     * @dev Can only be called once, permanently locked after deployment\n     */\n    function setPeripheralContracts(\n        address _stakingRouter,\n        address _farmingPool,\n        address _stBTD,\n        address _stBTB,\n        address _governor,\n        address _twapOracle,\n        address _poolWbtcUsdc,\n        address _poolBtdUsdc,\n        address _poolBtbBtd,\n        address _poolBrsBtd\n    ) external {\n        require(!peripheralContractsSet, \"Peripheral contracts already set\");\n        require(_stakingRouter != address(0), \"Invalid StakingRouter\");\n        require(_farmingPool != address(0), \"Invalid FarmingPool\");\n        require(_stBTD != address(0), \"Invalid stBTD\");\n        require(_stBTB != address(0), \"Invalid stBTB\");\n        require(_governor != address(0), \"Invalid Governor\");\n        require(_twapOracle != address(0), \"Invalid TWAPOracle\");\n        require(_poolWbtcUsdc != address(0), \"Invalid Pool WBTC/USDC\");\n        require(_poolBtdUsdc != address(0), \"Invalid Pool BTD/USDC\");\n        require(_poolBtbBtd != address(0), \"Invalid Pool BTB/BTD\");\n        require(_poolBrsBtd != address(0), \"Invalid Pool BRS/BTD\");\n\n        STAKING_ROUTER = _stakingRouter;\n        FARMING_POOL = _farmingPool;\n        ST_BTD = _stBTD;\n        ST_BTB = _stBTB;\n        GOVERNOR = _governor;\n        TWAP_ORACLE = _twapOracle;\n        POOL_WBTC_USDC = _poolWbtcUsdc;\n        POOL_BTD_USDC = _poolBtdUsdc;\n        POOL_BTB_BTD = _poolBtbBtd;\n        POOL_BRS_BTD = _poolBrsBtd;\n        peripheralContractsSet = true;\n    }\n}\n"
      },
      "project/contracts/ConfigGov.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./libraries/Constants.sol\";\n\n/**\n * @title ConfigGov - Governable Parameter Configuration Contract\n * @notice Manages runtime-adjustable system parameters (fees, limits, oracle addresses, etc.)\n * @dev Separated from ConfigCore: Core manages immutable addresses, Gov manages mutable parameters\n *      Governance logic can be upgraded without affecting core architecture\n */\ncontract ConfigGov is Ownable {\n\n    /**\n     * @notice Parameter type enum (uint256 type)\n     * @dev Used for unified management of all system parameters, supports unlimited extension\n     */\n    enum ParamType {\n        MINT_FEE_BP,        // 0 - Minting fee rate (basis points)\n        INTEREST_FEE_BP,    // 1 - Interest fee rate (basis points)\n        MIN_BTB_PRICE,      // 2 - BTB minimum price (18 decimals)\n        MAX_BTB_RATE,       // 3 - BTB maximum interest rate (basis points)\n        PCE_MAX_DEVIATION,  // 4 - PCE maximum deviation rate (18 decimals, e.g., 2e16 = 2%)\n        REDEEM_FEE_BP,      // 5 - Redemption fee rate (basis points)\n        MAX_BTD_RATE        // 6 - BTD maximum interest rate (basis points)\n        // Future extensions: LIQUIDATION_FEE, STABILITY_FEE, etc.\n    }\n\n    /**\n     * @notice Address parameter type enum\n     * @dev Used for managing governable oracle addresses, external contract addresses, etc.\n     */\n    enum AddressParamType {\n        PCE_FEED          // 0 - Chainlink PCE oracle address\n        // Future extensions: BACKUP_PCE_FEED, CPI_FEED, etc.\n    }\n\n    // ============ Storage ============\n\n    /// @notice Unified parameter registry (governable fees, limits, and other parameters)\n    mapping(ParamType => uint256) private _params;\n\n    /// @notice Address parameter registry (governable oracle addresses, etc.)\n    mapping(AddressParamType => address) private _addressParams;\n\n    // ============ Events ============\n\n    /// @notice Generic parameter update event (uint256 type)\n    event ParamUpdated(ParamType indexed paramType, uint256 newValue);\n\n    /// @notice Address parameter update event\n    event AddressParamUpdated(AddressParamType indexed paramType, address newValue);\n\n    // ============ Initialization ============\n\n    /**\n     * @notice Constructor - initializes governance parameters\n     * @param initialOwner Contract owner address\n     */\n    constructor(\n        address initialOwner\n    ) Ownable(initialOwner) {\n        require(initialOwner != address(0), \"ConfigGov: zero owner\");\n    }\n\n    // ============ Parameter Management ============\n\n    /**\n     * @notice Sets a single system parameter\n     * @dev Only owner can call, used for updating fees, price limits, and other parameters\n     * @param paramType Parameter type (from ParamType enum)\n     * @param value New parameter value\n     */\n    function setParam(ParamType paramType, uint256 value) external onlyOwner {\n        // Parameter range validation\n        _validateParam(paramType, value);\n\n        _params[paramType] = value;\n        emit ParamUpdated(paramType, value);\n    }\n\n    /**\n     * @notice Validates parameter range\n     * @dev Internal function to ensure parameters are within reasonable bounds\n     * @param paramType Parameter type\n     * @param value Parameter value\n     */\n    function _validateParam(ParamType paramType, uint256 value) private pure {\n        if (paramType == ParamType.MINT_FEE_BP) {\n            require(value >= 1, \"ConfigGov: mint fee too low\");  // Minimum 0.01% (1 basis point)\n            require(value <= 1000, \"ConfigGov: mint fee too high\"); // Maximum 10%\n        } else if (paramType == ParamType.INTEREST_FEE_BP) {\n            require(value >= 1, \"ConfigGov: interest fee too low\");\n            require(value <= 1000, \"ConfigGov: interest fee too high\");\n        } else if (paramType == ParamType.REDEEM_FEE_BP) {\n            require(value >= 1, \"ConfigGov: redeem fee too low\");\n            require(value <= 1000, \"ConfigGov: redeem fee too high\");\n        } else if (paramType == ParamType.MIN_BTB_PRICE) {\n            require(value >= 1e17, \"ConfigGov: min BTB price too low\"); // Minimum 0.1 BTD\n            require(value <= 2e18, \"ConfigGov: min BTB price too high\"); // Maximum 2 BTD\n        } else if (paramType == ParamType.MAX_BTB_RATE) {\n            require(value >= 100, \"ConfigGov: max BTB rate too low\"); // Minimum 1% APR (100 bps)\n            require(value <= 2000, \"ConfigGov: max BTB rate too high\"); // Maximum 20% APR (2000 bps)\n        } else if (paramType == ParamType.MAX_BTD_RATE) {\n            require(value >= 100, \"ConfigGov: max BTD rate too low\"); // Minimum 1% APR (100 bps)\n            require(value <= 2000, \"ConfigGov: max BTD rate too high\"); // Maximum 20% APR (2000 bps)\n        } else if (paramType == ParamType.PCE_MAX_DEVIATION) {\n            require(value >= 1e15, \"ConfigGov: PCE deviation too low\"); // Minimum 0.1%\n            require(value <= 1e17, \"ConfigGov: PCE deviation too high\"); // Maximum 10%\n        }\n    }\n\n    /**\n     * @notice Batch sets multiple system parameters\n     * @dev Only owner can call, array lengths must be equal\n     * @param paramTypes Parameter type array\n     * @param values Corresponding new parameter value array\n     */\n    function setParamsBatch(\n        ParamType[] calldata paramTypes,\n        uint256[] calldata values\n    ) external onlyOwner {\n        require(paramTypes.length == values.length, \"ConfigGov: length mismatch\");\n        for (uint i = 0; i < paramTypes.length; i++) {\n            // Parameter range validation\n            _validateParam(paramTypes[i], values[i]);\n\n            _params[paramTypes[i]] = values[i];\n            emit ParamUpdated(paramTypes[i], values[i]);\n        }\n    }\n\n    /**\n     * @notice Gets the value of a specified system parameter type\n     * @dev Returns 0 if the parameter is not set\n     * @param paramType Parameter type\n     * @return Parameter value\n     */\n    function getParam(ParamType paramType) external view returns (uint256) {\n        return _params[paramType];\n    }\n\n    // ============ Convenience Access Functions ============\n\n    /**\n     * @notice Gets the minting fee rate\n     * @return Minting fee rate (basis points, e.g., 50 = 0.5%)\n     */\n    function mintFeeBP() external view returns (uint256) {\n        return _params[ParamType.MINT_FEE_BP];\n    }\n\n    function interestFeeBP() external view returns (uint256) {\n        return _params[ParamType.INTEREST_FEE_BP];\n    }\n\n    function minBTBPrice() external view returns (uint256) {\n        return _params[ParamType.MIN_BTB_PRICE];\n    }\n\n    function maxBTBRate() external view returns (uint256) {\n        return _params[ParamType.MAX_BTB_RATE];\n    }\n\n    /**\n     * @notice Gets BTD maximum interest rate\n     * @dev Used to cap BTD deposit rate per whitepaper\n     * @return BTD maximum interest rate (basis points, e.g., 2000 = 20%)\n     */\n    function maxBTDRate() external view returns (uint256) {\n        return _params[ParamType.MAX_BTD_RATE];\n    }\n\n    /**\n     * @notice Gets PCE maximum deviation rate\n     * @dev Used to prevent abnormal PCE data fluctuations\n     * @return PCE maximum deviation rate (18 decimals, e.g., 2e16 = 2%)\n     */\n    function pceMaxDeviation() external view returns (uint256) {\n        return _params[ParamType.PCE_MAX_DEVIATION];\n    }\n\n    /**\n     * @notice Gets the redemption fee rate\n     * @dev Fee deducted from user when redeeming BTD\n     * @return Redemption fee rate (basis points, e.g., 50 = 0.5%)\n     */\n    function redeemFeeBP() external view returns (uint256) {\n        return _params[ParamType.REDEEM_FEE_BP];\n    }\n\n    // ============ Address Parameter Management ============\n\n    /**\n     * @notice Sets a single address parameter\n     * @dev Only owner can call, used for updating oracle addresses, etc.\n     * @param paramType Address parameter type (from AddressParamType enum)\n     * @param value New address value\n     */\n    function setAddressParam(AddressParamType paramType, address value) external onlyOwner {\n        require(value != address(0), \"ConfigGov: zero address\");\n        _addressParams[paramType] = value;\n        emit AddressParamUpdated(paramType, value);\n    }\n\n    /**\n     * @notice Batch sets multiple address parameters\n     * @dev Only owner can call, array lengths must be equal\n     * @param paramTypes Address parameter type array\n     * @param values Corresponding new address value array\n     */\n    function setAddressParamsBatch(\n        AddressParamType[] calldata paramTypes,\n        address[] calldata values\n    ) external onlyOwner {\n        require(paramTypes.length == values.length, \"ConfigGov: length mismatch\");\n        for (uint i = 0; i < paramTypes.length; i++) {\n            require(values[i] != address(0), \"ConfigGov: zero address\");\n            _addressParams[paramTypes[i]] = values[i];\n            emit AddressParamUpdated(paramTypes[i], values[i]);\n        }\n    }\n\n    /**\n     * @notice Gets the value of a specified address parameter type\n     * @dev Returns address(0) if the parameter is not set\n     * @param paramType Address parameter type\n     * @return Address value\n     */\n    function getAddressParam(AddressParamType paramType) external view returns (address) {\n        return _addressParams[paramType];\n    }\n\n    /**\n     * @notice Gets PCE Feed oracle address\n     * @return PCE Feed address\n     */\n    function pceFeed() external view returns (address) {\n        return _addressParams[AddressParamType.PCE_FEED];\n    }\n}\n"
      },
      "project/contracts/extensions/ERC20BlocklistUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20Upgradeable} that allows to implement a blocklist\n * mechanism that can be managed by an authorized account with the\n * {_blockUser} and {_unblockUser} functions.\n *\n * This is the upgradeable version of OpenZeppelin Community's ERC20Blocklist.\n *\n * The blocklist provides the guarantee to the contract owner\n * (e.g. a DAO or a well-configured multisig) that any account won't be\n * able to execute transfers or approvals to other entities to operate\n * on its behalf if {_blockUser} was not called with such account as an\n * argument. Similarly, the account will be unblocked again if\n * {_unblockUser} is called.\n */\nabstract contract ERC20BlocklistUpgradeable is Initializable, ERC20Upgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20Blocklist\n    struct ERC20BlocklistStorage {\n        mapping(address user => bool) _blocked;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20Blocklist\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20BlocklistStorageLocation =\n        0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567800;\n\n    function _getERC20BlocklistStorage() private pure returns (ERC20BlocklistStorage storage $) {\n        assembly {\n            $.slot := ERC20BlocklistStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when a user is blocked.\n     */\n    event UserBlocked(address indexed user);\n\n    /**\n     * @dev Emitted when a user is unblocked.\n     */\n    event UserUnblocked(address indexed user);\n\n    /**\n     * @dev The operation failed because the user is blocked.\n     */\n    error ERC20Blocked(address user);\n\n    function __ERC20Blocklist_init() internal onlyInitializing {\n    }\n\n    function __ERC20Blocklist_init_unchained() internal onlyInitializing {\n    }\n\n    /**\n     * @dev Returns the blocked status of an account.\n     */\n    function blocked(address account) public virtual returns (bool) {\n        ERC20BlocklistStorage storage $ = _getERC20BlocklistStorage();\n        return $._blocked[account];\n    }\n\n    /**\n     * @dev Blocks a user from receiving and transferring tokens, including minting and burning.\n     */\n    function _blockUser(address user) internal virtual returns (bool) {\n        bool isBlocked = blocked(user);\n        if (!isBlocked) {\n            ERC20BlocklistStorage storage $ = _getERC20BlocklistStorage();\n            $._blocked[user] = true;\n            emit UserBlocked(user);\n        }\n        return isBlocked;\n    }\n\n    /**\n     * @dev Unblocks a user from receiving and transferring tokens, including minting and burning.\n     */\n    function _unblockUser(address user) internal virtual returns (bool) {\n        bool isBlocked = blocked(user);\n        if (isBlocked) {\n            ERC20BlocklistStorage storage $ = _getERC20BlocklistStorage();\n            $._blocked[user] = false;\n            emit UserUnblocked(user);\n        }\n        return isBlocked;\n    }\n\n    /**\n     * @dev See {ERC20-_update}.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override {\n        if (blocked(from)) revert ERC20Blocked(from);\n        if (blocked(to)) revert ERC20Blocked(to);\n        super._update(from, to, value);\n    }\n\n    /**\n     * @dev See {ERC20-_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual override {\n        if (blocked(owner)) revert ERC20Blocked(owner);\n        super._approve(owner, spender, value, emitEvent);\n    }\n}\n"
      },
      "project/contracts/extensions/ERC20CustodianUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20Upgradeable} that allows to implement a custodian\n * mechanism that can be managed by an authorized account with the\n * {freeze} function.\n *\n * This is the upgradeable version of OpenZeppelin Community's ERC20Custodian.\n *\n * This mechanism allows a custodian (e.g. a DAO or a\n * well-configured multisig) to freeze and unfreeze the balance\n * of a user.\n *\n * The frozen balance is not available for transfers or approvals\n * to other entities to operate on its behalf. The frozen balance\n * can be reduced by calling {freeze} again with a lower amount.\n */\nabstract contract ERC20CustodianUpgradeable is Initializable, ERC20Upgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20Custodian\n    struct ERC20CustodianStorage {\n        mapping(address user => uint256 amount) _frozen;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20Custodian\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20CustodianStorageLocation =\n        0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcd00;\n\n    function _getERC20CustodianStorage() private pure returns (ERC20CustodianStorage storage $) {\n        assembly {\n            $.slot := ERC20CustodianStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when tokens are frozen for a user.\n     * @param user The address of the user whose tokens were frozen.\n     * @param amount The amount of tokens that were frozen.\n     */\n    event TokensFrozen(address indexed user, uint256 amount);\n\n    /**\n     * @dev Emitted when tokens are unfrozen for a user.\n     * @param user The address of the user whose tokens were unfrozen.\n     * @param amount The amount of tokens that were unfrozen.\n     */\n    event TokensUnfrozen(address indexed user, uint256 amount);\n\n    /**\n     * @dev The operation failed because the user has insufficient unfrozen balance.\n     */\n    error ERC20InsufficientUnfrozenBalance(address user);\n\n    /**\n     * @dev The operation failed because the user has insufficient frozen balance.\n     */\n    error ERC20InsufficientFrozenBalance(address user);\n\n    /**\n     * @dev Error thrown when a non-custodian account attempts to perform a custodian-only operation.\n     */\n    error ERC20NotCustodian();\n\n    /**\n     * @dev Modifier to restrict access to custodian accounts only.\n     */\n    modifier onlyCustodian() {\n        if (!_isCustodian(_msgSender())) revert ERC20NotCustodian();\n        _;\n    }\n\n    function __ERC20Custodian_init() internal onlyInitializing {\n    }\n\n    function __ERC20Custodian_init_unchained() internal onlyInitializing {\n    }\n\n    /**\n     * @dev Returns the amount of tokens frozen for a user.\n     */\n    function frozen(address user) public view virtual returns (uint256) {\n        ERC20CustodianStorage storage $ = _getERC20CustodianStorage();\n        return $._frozen[user];\n    }\n\n    /**\n     * @dev Adjusts the amount of tokens frozen for a user.\n     * @param user The address of the user whose tokens to freeze.\n     * @param amount The amount of tokens frozen.\n     *\n     * Requirements:\n     *\n     * - The user must have sufficient unfrozen balance.\n     */\n    function freeze(address user, uint256 amount) external virtual onlyCustodian {\n        if (availableBalance(user) < amount) revert ERC20InsufficientUnfrozenBalance(user);\n        ERC20CustodianStorage storage $ = _getERC20CustodianStorage();\n        $._frozen[user] = amount;\n        emit TokensFrozen(user, amount);\n    }\n\n    /**\n     * @dev Returns the available (unfrozen) balance of an account.\n     * @param account The address to query the available balance of.\n     * @return available The amount of tokens available for transfer.\n     */\n    function availableBalance(address account) public view returns (uint256 available) {\n        available = balanceOf(account) - frozen(account);\n    }\n\n    /**\n     * @dev Checks if the user is a custodian.\n     * @param user The address of the user to check.\n     * @return True if the user is authorized, false otherwise.\n     */\n    function _isCustodian(address user) internal view virtual returns (bool);\n\n    function _update(address from, address to, uint256 value) internal virtual override {\n        if (from != address(0) && availableBalance(from) < value) revert ERC20InsufficientUnfrozenBalance(from);\n        super._update(from, to, value);\n    }\n}\n"
      },
      "project/contracts/FarmingPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IFarmingPool.sol\";\nimport \"./ConfigCore.sol\";\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./libraries/RewardMath.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/// @notice Minimal Farm contract: responsible for distributing pre-minted BRS, no longer has minting or pause privileges\ncontract FarmingPool is Ownable, ReentrancyGuard, IFarmingPool {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n    ConfigCore public immutable core;\n\n    uint256 public immutable override startTime;\n    uint256 public override minted; // Track distributed rewards, maintain interface compatibility\n\n    IFarmingPool.PoolInfo[] private _poolInfo;\n    mapping(uint256 => mapping(address => IFarmingPool.UserInfo)) private _userInfo;\n    uint256 public totalAllocPoint;\n\n    address[] public fundAddrs;\n    uint256[] public fundShares; // Percentage (base 100)\n    uint256 public constant SHARE_BASE = 100;\n\n    event RewardsFunded(address indexed from, uint256 amount);\n\n    /** @notice Constructor */\n    constructor(\n        address owner_,                   // Admin address\n        address rewardToken_,             // Reward token (BRS)\n        address _core,                    // ConfigCore contract\n        address[] memory initialFunds,    // Initial fund addresses\n        uint256[] memory initialShares    // Fund shares (base 100)\n    ) Ownable(owner_) {\n        require(owner_ != address(0), \"FarmingPool: invalid owner\");\n        require(rewardToken_ != address(0), \"FarmingPool: zero reward\");\n        require(_core != address(0), \"FarmingPool: zero core\");\n        rewardToken = IERC20(rewardToken_);\n        core = ConfigCore(_core);\n        startTime = block.timestamp;\n        _setFunds(initialFunds, initialShares);\n    }\n\n    // ============ Fund Management ============\n\n    /// @notice Gets BRS reward token address\n    /// @dev For interface compatibility\n    /// @return BRS token contract address\n    function brs() external view override returns (address) {\n        return address(rewardToken);\n    }\n\n    /// @notice Fund provider injects reward tokens\n    /// @dev Anyone can call to inject BRS rewards into FarmingPool\n    /// @param amount Amount of BRS to inject, precision 1e18\n    function fundRewards(uint256 amount) external {\n        require(amount > 0, \"FarmingPool: amount zero\");\n        rewardToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit RewardsFunded(msg.sender, amount);\n    }\n\n    /// @notice Sets fund shares\n    /// @dev Only contract owner can call, sets reward distribution ratio to funds\n    /// @param addrs Fund address array\n    /// @param shares Share ratio array (base 100), total cannot exceed 100\n    function setFunds(address[] calldata addrs, uint256[] calldata shares) external onlyOwner {\n        _setFunds(addrs, shares);\n    }\n\n    function _setFunds(address[] memory addrs, uint256[] memory shares) internal {\n        require(addrs.length == shares.length, \"FarmingPool: length mismatch\");\n        uint256 sum;\n        for (uint256 i = 0; i < shares.length; i++) {\n            sum += shares[i];\n        }\n        require(sum <= SHARE_BASE, \"FarmingPool: shares exceed 100%\");\n        fundAddrs = addrs;\n        fundShares = shares;\n    }\n\n    // ============ Pool Management ============\n\n    /// @notice Gets pool count\n    /// @dev Returns the total number of pools currently added\n    /// @return Total pool count\n    function poolLength() external view override returns (uint256) {\n        return _poolInfo.length;\n    }\n\n    /// @notice Gets pool detailed information\n    /// @dev Returns all configuration parameters and status for the specified pool\n    /// @param pid Pool ID\n    /// @return lpToken Staking token address\n    /// @return allocPoint Allocation points (determines reward weight)\n    /// @return lastRewardTime Timestamp of last reward calculation\n    /// @return accRewardPerShare Accumulated reward per share, precision 1e18\n    /// @return totalStaked Total staked amount\n    /// @return cachedLPValuePerToken Cached LP token unit price (LP pools only)\n    /// @return lastPriceUpdate Timestamp of last price update\n    /// @return kind Pool type (LP or single token)\n    function poolInfo(uint256 pid)\n        external\n        view\n        override\n        returns (\n            IERC20 lpToken,\n            uint256 allocPoint,\n            uint256 lastRewardTime,\n            uint256 accRewardPerShare,\n            uint256 totalStaked,\n            uint256 cachedLPValuePerToken,\n            uint256 lastPriceUpdate,\n            PoolKind kind\n        )\n    {\n        IFarmingPool.PoolInfo storage pool = _poolInfo[pid];\n        return (\n            pool.lpToken,\n            pool.allocPoint,\n            pool.lastRewardTime,\n            pool.accRewardPerShare,\n            pool.totalStaked,\n            pool.cachedLPValuePerToken,\n            pool.lastPriceUpdate,\n            pool.kind\n        );\n    }\n\n    /// @notice Gets pool type\n    /// @dev Returns whether the pool is an LP pool or single token pool\n    /// @param pid Pool ID\n    /// @return Pool type (LP or Single)\n    function poolKind(uint256 pid) external view override returns (PoolKind) {\n        return _poolInfo[pid].kind;\n    }\n\n    /// @notice Gets user staking info for a specific pool\n    /// @dev Returns user's staked amount and reward debt\n    /// @param pid Pool ID\n    /// @param user User address\n    /// @return amount User's staked amount, precision 1e18\n    /// @return rewardDebt Reward debt, used for calculating pending rewards\n    function userInfo(uint256 pid, address user)\n        external\n        view\n        override\n        returns (uint256 amount, uint256 rewardDebt)\n    {\n        IFarmingPool.UserInfo storage info = _userInfo[pid][user];\n        return (info.amount, info.rewardDebt);\n    }\n\n    /// @notice Adds new pool (optional immediate batch update)\n    /// @dev Only contract owner can call, adds a new staking pool\n    /// @param token Staking token address (LP or single token)\n    /// @param allocPoint Allocation points, determines the pool's weight in total rewards\n    /// @param kind Pool type (LP or Single)\n    /// @param withUpdate Whether to batch update all pools before adding\n    function addPool(\n        IERC20 token,\n        uint256 allocPoint,\n        PoolKind kind,\n        bool withUpdate\n    ) external override onlyOwner {\n        _addPoolInternal(allocPoint, token, kind, withUpdate);\n    }\n\n    /// @notice Adds new pool (default no batch update)\n    /// @dev Only contract owner can call, adds new pool without triggering batch update\n    /// @param token Staking token address\n    /// @param allocPoint Allocation points\n    /// @param kind Pool type\n    function addPool(IERC20 token, uint256 allocPoint, PoolKind kind) external override onlyOwner {\n        _addPoolInternal(allocPoint, token, kind, false);\n    }\n\n    /// @notice Batch adds pools\n    /// @dev Only contract owner can call, adds multiple pools at once\n    /// @param tokens Staking token address array\n    /// @param allocPoints Allocation points array\n    /// @param kinds Pool type array\n    function addPools(\n        IERC20[] calldata tokens,\n        uint256[] calldata allocPoints,\n        PoolKind[] calldata kinds\n    ) external override onlyOwner {\n        require(tokens.length == allocPoints.length, \"FarmingPool: length mismatch\");\n        require(tokens.length == kinds.length, \"FarmingPool: kind mismatch\");\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _addPoolInternal(allocPoints[i], tokens[i], kinds[i], false);\n        }\n    }\n\n    function _addPoolInternal(\n        uint256 allocPoint,\n        IERC20 token,\n        PoolKind kind,\n        bool withUpdate\n    ) internal {\n        if (withUpdate) {\n            massUpdatePools();\n        }\n        totalAllocPoint += allocPoint;\n        _poolInfo.push(\n            IFarmingPool.PoolInfo({\n                lpToken: token,\n                allocPoint: allocPoint,\n                lastRewardTime: block.timestamp,\n                accRewardPerShare: 0,\n                totalStaked: 0,\n                cachedLPValuePerToken: 0,\n                lastPriceUpdate: 0,\n                kind: kind\n            })\n        );\n    }\n\n    /// @notice Modifies pool allocation points\n    /// @dev Only contract owner can call, adjusts the pool's reward weight\n    /// @param pid Pool ID\n    /// @param allocPoint New allocation points\n    /// @param withUpdate Whether to batch update all pools before modifying\n    function setPool(uint256 pid, uint256 allocPoint, bool withUpdate) external override onlyOwner {\n        if (withUpdate) {\n            massUpdatePools();\n        }\n        IFarmingPool.PoolInfo storage pool = _poolInfo[pid];\n        totalAllocPoint = totalAllocPoint - pool.allocPoint + allocPoint;\n        pool.allocPoint = allocPoint;\n    }\n\n    // ============ Reward Calculation ============\n\n    /// @notice Gets current reward rate per second\n    /// @dev Calculates current epoch's reward rate based on start time, halving each epoch\n    /// @return Current BRS reward per second, precision 1e18\n    function currentRewardPerSecond() external view override returns (uint256) {\n        return _currentRewardPerSec();\n    }\n\n    function _currentRewardPerSec() internal view returns (uint256) {\n        if (totalAllocPoint == 0) return 0;\n        uint256 era = (block.timestamp - startTime) / Constants.ERA_PERIOD;\n        uint256 initialRate = (1_050_000_000e18) / Constants.ERA_PERIOD;\n        return initialRate >> era;\n    }\n\n    /// @notice Batch updates all pools\n    /// @dev Iterates through all pools and updates their accumulated rewards, recommended to call before modifying allocation points\n    function massUpdatePools() public {\n        uint256 length = _poolInfo.length;\n        for (uint256 pid = 0; pid < length; pid++) {\n            updatePool(pid);\n        }\n    }\n\n    /// @notice Updates accumulated rewards for a specific pool\n    /// @dev Calculates rewards since last update and updates accRewardPerShare\n    ///      Also distributes fund shares to specified fund addresses\n    /// @param pid Pool ID\n    function updatePool(uint256 pid) public {\n        IFarmingPool.PoolInfo storage pool = _poolInfo[pid];\n        if (block.timestamp <= pool.lastRewardTime) return;\n\n        uint256 totalStaked = pool.totalStaked;\n        if (totalStaked == 0 || totalAllocPoint == 0) {\n            pool.lastRewardTime = block.timestamp;\n            return;\n        }\n\n        uint256 timeElapsed = block.timestamp - pool.lastRewardTime;\n        uint256 reward = RewardMath.emissionFor(\n            timeElapsed,\n            _currentRewardPerSec(),\n            pool.allocPoint,\n            totalAllocPoint\n        );\n        reward = RewardMath.clampToMax(minted, reward, Constants.BRS_MAX_SUPPLY);\n        if (reward == 0) {\n            pool.lastRewardTime = block.timestamp;\n            return;\n        }\n        minted += reward;\n\n        uint256 fundDistributed;\n        uint256 shareSum;\n        uint256 lastFundIndex = type(uint256).max;\n        for (uint256 i = 0; i < fundAddrs.length; i++) {\n            if (fundAddrs[i] != address(0) && fundShares.length > i && fundShares[i] > 0) {\n                shareSum += fundShares[i];\n                lastFundIndex = i;\n            }\n        }\n\n        for (uint256 i = 0; i < fundAddrs.length; i++) {\n            address fund = fundAddrs[i];\n            uint256 share = fundShares.length > i ? fundShares[i] : 0;\n            if (fund != address(0) && share > 0) {\n                uint256 amt;\n                if (i == lastFundIndex) {\n                    uint256 totalFundAmount = Math.mulDiv(reward, shareSum, SHARE_BASE);\n                    amt = totalFundAmount - fundDistributed;\n                } else {\n                    amt = Math.mulDiv(reward, share, SHARE_BASE);\n                }\n                if (amt > 0) {\n                    rewardToken.safeTransfer(fund, amt);\n                    fundDistributed += amt;\n                }\n            }\n        }\n\n        uint256 poolReward = reward - fundDistributed;\n        pool.accRewardPerShare = RewardMath.accRewardPerShare(\n            pool.accRewardPerShare,\n            poolReward,\n            totalStaked\n        );\n        pool.lastRewardTime = block.timestamp;\n    }\n\n    /// @notice Queries user's pending BRS rewards\n    /// @dev Calculates user's current claimable rewards (including unupdated accumulated rewards)\n    /// @param pid Pool ID\n    /// @param account User address\n    /// @return Pending BRS amount, precision 1e18\n    function pendingReward(uint256 pid, address account) external view override returns (uint256) {\n        IFarmingPool.PoolInfo storage pool = _poolInfo[pid];\n        IFarmingPool.UserInfo storage user = _userInfo[pid][account];\n        uint256 accReward = pool.accRewardPerShare;\n        uint256 totalStaked = pool.totalStaked;\n\n        if (block.timestamp > pool.lastRewardTime && totalStaked > 0) {\n            uint256 timeElapsed = block.timestamp - pool.lastRewardTime;\n            uint256 reward = RewardMath.emissionFor(\n                timeElapsed,\n                _currentRewardPerSec(),\n                pool.allocPoint,\n                totalAllocPoint\n            );\n            reward = RewardMath.clampToMax(minted, reward, Constants.BRS_MAX_SUPPLY);\n            accReward = RewardMath.accRewardPerShare(accReward, reward, totalStaked);\n        }\n\n        return RewardMath.pending(user.amount, accReward, user.rewardDebt);\n    }\n\n    // ============ User Operations ============\n\n    /// @notice User stakes tokens\n    /// @dev Stakes tokens to a specific pool to earn BRS rewards, automatically claims accumulated rewards\n    ///      Stake amount must meet minimum USD value requirement\n    /// @param pid Pool ID\n    /// @param amount Stake amount, precision depends on token\n    function deposit(uint256 pid, uint256 amount) external override nonReentrant {\n        _deposit(pid, amount, msg.sender, msg.sender);\n    }\n\n    /// @notice Stakes tokens on behalf of another user\n    /// @dev Caller pays tokens, but staking record and rewards belong to onBehalfOf address\n    ///      Used by StakingRouter and similar contracts for proxy staking\n    /// @param pid Pool ID\n    /// @param amount Stake amount\n    /// @param onBehalfOf Beneficiary address, rewards will belong to this address\n    function depositFor(uint256 pid, uint256 amount, address onBehalfOf) external override nonReentrant {\n        require(onBehalfOf != address(0), \"FarmingPool: zero address\");\n        _deposit(pid, amount, msg.sender, onBehalfOf);\n    }\n\n    function _deposit(uint256 pid, uint256 amount, address payer, address beneficiary) internal {\n        IFarmingPool.PoolInfo storage pool = _poolInfo[pid];\n        IFarmingPool.UserInfo storage user = _userInfo[pid][beneficiary];\n        updatePool(pid);\n\n        if (user.amount > 0) {\n            uint256 pending = RewardMath.pending(user.amount, pool.accRewardPerShare, user.rewardDebt);\n            if (pending > 0) {\n                rewardToken.safeTransfer(beneficiary, pending);\n                emit Claim(beneficiary, pid, pending);\n            }\n        }\n\n        if (amount > 0) {\n            _updateLPValueIfNeeded(pid, pool.kind);\n            uint256 stakeValue = _calculateStakeValueUSD(pool, amount, pool.kind);\n            require(stakeValue >= Constants.MIN_USD_VALUE, \"FarmingPool: stake too small\");\n            require(stakeValue <= Constants.MAX_USD_VALUE, \"FarmingPool: stake too large\");\n            pool.lpToken.safeTransferFrom(payer, address(this), amount);\n            user.amount += amount;\n            pool.totalStaked += amount;\n        }\n\n        user.rewardDebt = RewardMath.rewardDebtValue(user.amount, pool.accRewardPerShare);\n        emit Deposit(beneficiary, pid, amount);\n    }\n\n    /// @notice User withdraws staked tokens\n    /// @dev Withdraws staked tokens from specified pool, automatically claims accumulated rewards\n    /// @param pid Pool ID\n    /// @param amount Withdraw amount, cannot exceed staked amount\n    function withdraw(uint256 pid, uint256 amount) external override nonReentrant {\n        _withdraw(pid, amount, msg.sender, msg.sender);\n    }\n\n    /// @notice Withdraws staked tokens on behalf of another user\n    /// @dev Withdraws from onBehalfOf's stake, tokens sent to 'to' address\n    ///      Used by StakingRouter and similar contracts for proxy withdrawal\n    /// @param pid Pool ID\n    /// @param amount Withdraw amount\n    /// @param onBehalfOf Stake owner address\n    /// @param to Address to receive tokens\n    function withdrawFor(uint256 pid, uint256 amount, address onBehalfOf, address to) external override nonReentrant {\n        require(onBehalfOf != address(0) && to != address(0), \"FarmingPool: zero address\");\n        _withdraw(pid, amount, onBehalfOf, to);\n    }\n\n    function _withdraw(uint256 pid, uint256 amount, address ownerAddr, address recipient) internal {\n        IFarmingPool.PoolInfo storage pool = _poolInfo[pid];\n        IFarmingPool.UserInfo storage user = _userInfo[pid][ownerAddr];\n        require(user.amount >= amount, \"FarmingPool: withdraw exceeds staked\");\n\n        // Validate withdraw amount USD value (prevent dust and overflow attacks)\n        if (amount > 0) {\n            _updateLPValueIfNeeded(pid, pool.kind);\n            uint256 withdrawValue = _calculateStakeValueUSD(pool, amount, pool.kind);\n            require(withdrawValue >= Constants.MIN_USD_VALUE, \"FarmingPool: withdraw too small\");\n            require(withdrawValue <= Constants.MAX_USD_VALUE, \"FarmingPool: withdraw too large\");\n        }\n\n        updatePool(pid);\n        uint256 pending = RewardMath.pending(user.amount, pool.accRewardPerShare, user.rewardDebt);\n        if (pending > 0) {\n            rewardToken.safeTransfer(ownerAddr, pending);\n            emit Claim(ownerAddr, pid, pending);\n        }\n\n        if (amount > 0) {\n            user.amount -= amount;\n            pool.totalStaked -= amount;\n            pool.lpToken.safeTransfer(recipient, amount);\n        }\n\n        user.rewardDebt = RewardMath.rewardDebtValue(user.amount, pool.accRewardPerShare);\n        emit Withdraw(ownerAddr, pid, amount);\n    }\n\n    /// @notice Claims BRS rewards\n    /// @dev Claims accumulated rewards from specified pool without affecting staked principal\n    /// @param pid Pool ID\n    function claim(uint256 pid) external override nonReentrant {\n        _claim(pid, msg.sender);\n    }\n\n    /// @notice Claims BRS rewards on behalf of another user\n    /// @dev Claims rewards for account from specified pool, rewards sent to account\n    ///      Used by StakingRouter and similar contracts for proxy claiming\n    /// @param pid Pool ID\n    /// @param account Reward owner address\n    function claimFor(uint256 pid, address account) external override nonReentrant {\n        require(account != address(0), \"FarmingPool: zero address\");\n        _claim(pid, account);\n    }\n\n    function _claim(uint256 pid, address account) internal {\n        IFarmingPool.PoolInfo storage pool = _poolInfo[pid];\n        IFarmingPool.UserInfo storage user = _userInfo[pid][account];\n        updatePool(pid);\n        uint256 pending = RewardMath.pending(user.amount, pool.accRewardPerShare, user.rewardDebt);\n        if (pending > 0) {\n            rewardToken.safeTransfer(account, pending);\n            emit Claim(account, pid, pending);\n        }\n        user.rewardDebt = RewardMath.rewardDebtValue(user.amount, pool.accRewardPerShare);\n    }\n\n    /// @notice Emergency withdrawal of all staked tokens\n    /// @dev Forfeits all pending rewards, only withdraws staked principal\n    ///      For emergency situations requiring quick exit\n    /// @param pid Pool ID\n    function emergencyWithdraw(uint256 pid) external override nonReentrant {\n        IFarmingPool.PoolInfo storage pool = _poolInfo[pid];\n        IFarmingPool.UserInfo storage user = _userInfo[pid][msg.sender];\n        uint256 amount = user.amount;\n        require(amount > 0, \"FarmingPool: nothing to withdraw\");\n\n        user.amount = 0;\n        user.rewardDebt = 0;\n        pool.totalStaked -= amount;\n        pool.lpToken.safeTransfer(msg.sender, amount);\n\n        emit EmergencyWithdraw(msg.sender, pid, amount);\n    }\n\n    // ============ LP Value Cache ============\n\n    uint256 public constant PRICE_UPDATE_INTERVAL = 1 hours;\n\n    /// @notice Checks if LP pool needs price cache update\n    /// @dev Only applicable to LP pools, updates LP token value hourly\n    /// @param pid Pool ID\n    /// @return needs Whether update is needed\n    /// @return timeSince Time since last update (seconds)\n    function needsUpdate(uint256 pid) external view override returns (bool needs, uint256 timeSince) {\n        IFarmingPool.PoolInfo storage pool = _poolInfo[pid];\n        if (pool.kind != PoolKind.LP) {\n            return (false, 0);\n        }\n        timeSince = block.timestamp - pool.lastPriceUpdate;\n        needs = timeSince >= PRICE_UPDATE_INTERVAL;\n    }\n\n    /// @notice Manually updates LP pool price cache\n    /// @dev Only applicable to LP pools, calculates and caches LP token USD value\n    ///      Used for minimum stake value validation\n    /// @param pid Pool ID (must be LP type)\n    function updateLPValue(uint256 pid) external override {\n        IFarmingPool.PoolInfo storage pool = _poolInfo[pid];\n        require(pool.kind == PoolKind.LP, \"FarmingPool: not LP\");\n        uint256 newValue = _calculateLPStakeValue(pool.lpToken, 1e18);\n        pool.cachedLPValuePerToken = newValue;\n        pool.lastPriceUpdate = block.timestamp;\n        emit LPValueUpdated(pid, newValue, block.timestamp);\n    }\n\n    function _updateLPValueIfNeeded(uint256 pid, PoolKind kind) internal {\n        if (kind != PoolKind.LP) {\n            return;\n        }\n        IFarmingPool.PoolInfo storage pool = _poolInfo[pid];\n        if (block.timestamp >= pool.lastPriceUpdate + PRICE_UPDATE_INTERVAL) {\n            uint256 newValue = _calculateLPStakeValue(pool.lpToken, 1e18);\n            pool.cachedLPValuePerToken = newValue;\n            pool.lastPriceUpdate = block.timestamp;\n            emit LPValueUpdated(pid, newValue, block.timestamp);\n        }\n    }\n\n    function _calculateStakeValueUSD(\n        IFarmingPool.PoolInfo storage pool,\n        uint256 amount,\n        PoolKind kind\n    ) internal view returns (uint256) {\n        if (kind == PoolKind.LP) {\n            uint256 valuePerToken = pool.cachedLPValuePerToken;\n            if (valuePerToken == 0) {\n                valuePerToken = _calculateLPStakeValue(pool.lpToken, 1e18);\n            }\n            return Math.mulDiv(amount, valuePerToken, 1e18);\n        }\n        return _calculateSingleStakeValue(pool.lpToken, amount);\n    }\n\n    function _calculateSingleStakeValue(IERC20 token, uint256 amount) internal view returns (uint256) {\n        uint8 decimals = IERC20Metadata(address(token)).decimals();\n        uint256 price = _fetchTokenPrice(address(token));\n        return Math.mulDiv(amount, price, 10 ** decimals);\n    }\n\n    function _calculateLPStakeValue(IERC20 lpToken, uint256 amount) internal view returns (uint256) {\n        IUniswapV2Pair pair = IUniswapV2Pair(address(lpToken));\n        uint256 totalSupply = pair.totalSupply();\n        if (totalSupply == 0) return 0;\n\n        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n        address token0 = pair.token0();\n        address token1 = pair.token1();\n\n        uint256 price0 = _fetchTokenPrice(token0);\n        uint256 price1 = _fetchTokenPrice(token1);\n        uint8 decimals0 = IERC20Metadata(token0).decimals();\n        uint8 decimals1 = IERC20Metadata(token1).decimals();\n\n        uint256 value0 = Math.mulDiv(reserve0, price0, 10 ** decimals0);\n        uint256 value1 = Math.mulDiv(reserve1, price1, 10 ** decimals1);\n        uint256 totalValue = value0 + value1;\n\n        return Math.mulDiv(amount, totalValue, totalSupply);\n    }\n\n    function _fetchTokenPrice(address token) internal view returns (uint256) {\n        IPriceOracle oracle = IPriceOracle(core.PRICE_ORACLE());\n        if (token == core.BTD()) {\n            return oracle.getBTDPrice();\n        }\n        if (token == core.BTB()) {\n            return oracle.getBTBPrice();\n        }\n        if (token == core.BRS()) {\n            return oracle.getBRSPrice();\n        }\n        if (token == core.WBTC()) {\n            return oracle.getWBTCPrice();\n        }\n        // stBTD price = BTD price * share value (ERC4626)\n        if (token == core.ST_BTD()) {\n            uint256 btdPrice = oracle.getBTDPrice();\n            uint256 assetsPerShare = IERC4626(token).convertToAssets(1e18);\n            return Math.mulDiv(btdPrice, assetsPerShare, 1e18);\n        }\n        // stBTB price = BTB price * share value (ERC4626)\n        if (token == core.ST_BTB()) {\n            uint256 btbPrice = oracle.getBTBPrice();\n            uint256 assetsPerShare = IERC4626(token).convertToAssets(1e18);\n            return Math.mulDiv(btbPrice, assetsPerShare, 1e18);\n        }\n        // Local/test: stablecoins fixed at $1, WETH set to $3,000\n        if (token == core.USDC() || token == core.USDT()) {\n            return 1e18;\n        }\n        if (token == core.WETH()) {\n            return 3_000e18;\n        }\n        revert(\"FarmingPool: unsupported token\");\n    }\n}\n"
      },
      "project/contracts/Governor.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.4.0\npragma solidity ^0.8.27;\n\nimport {GovernorUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport {GovernorCountingSimpleUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol\";\nimport {GovernorSettingsUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport {GovernorStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorStorageUpgradeable.sol\";\nimport {GovernorTimelockControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\nimport {GovernorVotesUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport {GovernorVotesQuorumFractionUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {TimelockControllerUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Governor - BRS Governance Contract\n * @notice On-chain governance system based on OpenZeppelin Governor, supports proposals, voting, timelock execution\n * @dev Upgradeable contract (UUPS pattern), integrates voting, proposal storage, timelock control, and other features\n *      - Voting delay: 1 day\n *      - Voting period: 1 week\n *      - Proposal threshold: 250,000 BRS\n *      - Quorum: 4% (based on total supply)\n */\ncontract Governor is Initializable, GovernorUpgradeable, GovernorSettingsUpgradeable, GovernorCountingSimpleUpgradeable, GovernorStorageUpgradeable, GovernorVotesUpgradeable, GovernorVotesQuorumFractionUpgradeable, GovernorTimelockControlUpgradeable, UUPSUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes governance contract\n     * @param _token Voting token (BRS)\n     * @param _timelock Timelock controller contract\n     * @dev Can only be called once, sets:\n     *      - Voting delay: 1 day\n     *      - Voting period: 1 week\n     *      - Proposal threshold: 250,000 BRS\n     *      - Quorum: 4%\n     */\n    function initialize(IVotes _token, TimelockControllerUpgradeable _timelock)\n        public\n        initializer\n    {\n        __Governor_init(\"Governor\");\n        __GovernorSettings_init(1 days, 1 weeks, 250000e18);\n        __GovernorCountingSimple_init();\n        __GovernorStorage_init();\n        __GovernorVotes_init(_token);\n        __GovernorVotesQuorumFraction_init(4);\n        __GovernorTimelockControl_init(_timelock);\n        __UUPSUpgradeable_init();\n    }\n\n    /**\n     * @notice Authorizes contract upgrade (only governance-approved proposals can call)\n     * @param newImplementation New implementation contract address\n     */\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyGovernance\n    {}\n\n    // The following functions are override functions required by Solidity\n\n    /**\n     * @notice Queries proposal state\n     * @param proposalId Proposal ID\n     * @return Proposal state (Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed)\n     */\n    function state(uint256 proposalId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    /**\n     * @notice Checks if proposal needs to be queued to timelock\n     * @param proposalId Proposal ID\n     * @return Whether queuing is needed\n     */\n    function proposalNeedsQueuing(uint256 proposalId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (bool)\n    {\n        return super.proposalNeedsQueuing(proposalId);\n    }\n\n    /**\n     * @notice Gets proposal threshold (minimum voting power required to create proposals)\n     * @return Proposal threshold (250,000 BRS)\n     */\n    function proposalThreshold()\n        public\n        view\n        override(GovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.proposalThreshold();\n    }\n\n    /**\n     * @notice Internal proposal creation function\n     * @param targets Target contract address array\n     * @param values ETH amounts to send with calls array\n     * @param calldatas Call data array\n     * @param description Proposal description\n     * @param proposer Proposer address\n     * @return Proposal ID\n     */\n    function _propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description, address proposer)\n        internal\n        override(GovernorUpgradeable, GovernorStorageUpgradeable)\n        returns (uint256)\n    {\n        return super._propose(targets, values, calldatas, description, proposer);\n    }\n\n    /**\n     * @notice Queues proposal operations to timelock\n     * @param proposalId Proposal ID\n     * @param targets Target contract address array\n     * @param values ETH amounts to send with calls array\n     * @param calldatas Call data array\n     * @param descriptionHash Proposal description hash\n     * @return Execution timestamp\n     */\n    function _queueOperations(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n        internal\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (uint48)\n    {\n        return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @notice Executes proposal operations\n     * @param proposalId Proposal ID\n     * @param targets Target contract address array\n     * @param values ETH amounts to send with calls array\n     * @param calldatas Call data array\n     * @param descriptionHash Proposal description hash\n     */\n    function _executeOperations(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n        internal\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n    {\n        super._executeOperations(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @notice Cancels proposal\n     * @param targets Target contract address array\n     * @param values ETH amounts to send with calls array\n     * @param calldatas Call data array\n     * @param descriptionHash Proposal description hash\n     * @return Proposal ID\n     */\n    function _cancel(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n        internal\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (uint256)\n    {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @notice Gets executor address (timelock contract)\n     * @return Executor address\n     */\n    function _executor()\n        internal\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (address)\n    {\n        return super._executor();\n    }\n}\n"
      },
      "project/contracts/IdealUSDManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ConfirmedOwner} from \"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\";\nimport {IIdealUSDManager} from \"./interfaces/IIdealUSDManager.sol\";\nimport {IAggregatorV3} from \"./interfaces/IAggregatorV3.sol\";\nimport {ConfigGov} from \"./ConfigGov.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/OracleMath.sol\";\nimport \"./libraries/IUSDMath.sol\";\nimport \"./libraries/FeedValidation.sol\";\n\n/**\n * @title IdealUSDManager - Ideal USD Manager\n * @notice Manages IUSD (Ideal USD), automatically adjusts based on fixed 2% annual inflation rate\n * @dev IUSD = IUSD x (current month PCE / previous month PCE) / monthlyGrowthFactor\n * @dev Non-upgradeable contract - core parameters are fixed after deployment, as per whitepaper requirements\n * @dev Inflation parameters use Constants library constants (ANNUAL_INFLATION_RATE, MONTHLY_GROWTH_FACTOR)\n * @dev PCE Feed address is dynamically retrieved from ConfigGov, supports governance replacement\n */\ncontract IdealUSDManager is ConfirmedOwner, IIdealUSDManager {\n\n    // ============ Immutable State ============\n\n    /// @notice ConfigGov contract address\n    /// @dev Cannot be changed after deployment, used to get governable PCE Feed address\n    ConfigGov public immutable configGov;\n\n    // ============ Mutable State ============\n\n    /// @notice Current IUSD value (18 decimals)\n    uint256 public iusdValue;\n\n    /// @notice Timestamp of most recent update\n    uint256 public lastUpdateTime;\n\n    /// @notice Timestamp of most recent PCE read\n    /// @dev Using uint64 to avoid year 2106 overflow issue (usable until year 584,942,417,355)\n    uint64 public lastPCEUpdateTime;\n\n    /// @notice Most recent PCE value (18 decimals)\n    uint256 public lastPCEValue;\n\n    /// @notice Previous PCE value (18 decimals)\n    uint256 public previousPCEValue;\n\n    // Authorized addresses (optional, disabled by default)\n    mapping(address => bool) public authorizedUpdaters;\n    bool public updaterWhitelistEnabled;\n\n    // Manual override safety controls\n    uint256 public lastManualOverrideTime;           // Last manual override timestamp\n    uint256 public constant MIN_OVERRIDE_INTERVAL = 7 days;  // Minimum override interval (7 days)\n    uint256 public constant MAX_MANUAL_DEVIATION = 5e16;     // Maximum manual deviation (5% = 0.05)\n    uint256 public manualOverrideCount;              // Manual override count for auditing\n\n    // History records\n    struct IUSDUpdate {\n        uint256 timestamp;\n        uint256 oldValue;\n        uint256 newValue;\n        uint256 currentPCE;\n        uint256 previousPCE;\n        uint256 actualMonthlyRate;\n        uint256 adjustmentFactor;\n    }\n\n\n    IUSDUpdate[] public updateHistory;\n\n    // Events\n    event IUSDUpdated(\n        uint256 indexed timestamp,\n        uint256 oldValue,\n        uint256 newValue,\n        uint256 currentPCE,\n        uint256 previousPCE,\n        uint256 actualRate,\n        uint256 targetRate,\n        uint256 adjustmentFactor\n    );\n\n    /// @notice Updater whitelist change\n    event UpdaterAuthorized(address indexed updater, bool authorized);\n    event IUSDManuallySet(\n        uint256 indexed timestamp,\n        uint256 oldValue,\n        uint256 newValue,\n        address indexed setter,\n        string reason\n    );\n\n    /**\n     * @notice Constructor - initializes IUSD manager\n     * @dev Uses fixed 2% annual inflation rate and monthly growth multiplier from Constants library\n     * @dev Monthly growth multiplier = (1.02)^(1/12) = 1.001651581301920174\n     * @dev PCE Feed address is dynamically retrieved from ConfigGov, ConfigGov must be configured at deployment\n     */\n    constructor(\n        address _owner,                  // Contract owner address\n        address _configGov,              // ConfigGov contract address\n        uint256 _initialIUSD             // Initial IUSD value (18 decimals, e.g., 1e18 = 1.0)\n    ) ConfirmedOwner(_owner) {\n        require(_configGov != address(0), \"Invalid ConfigGov\");\n        require(_initialIUSD > 0, \"Invalid initial value\");\n\n        // Set immutable parameters\n        configGov = ConfigGov(_configGov);\n\n        // Verify PCE Feed is configured\n        address pceFeedAddr = configGov.pceFeed();\n        require(pceFeedAddr != address(0), \"PCE Feed not set in ConfigGov\");\n\n        // Set mutable state\n        iusdValue = _initialIUSD;\n        lastUpdateTime = block.timestamp;\n        lastPCEUpdateTime = uint64(block.timestamp);\n\n        // Authorize deployer\n        authorizedUpdaters[_owner] = true;\n    }\n\n    /**\n     * @notice Updates IUSD value (automatically adjusts based on PCE data)\n     * @dev Retrieves latest data from Chainlink PCE Feed and adjusts IUSD based on inflation rate\n     * @dev Access control: default is owner only; when updaterWhitelist is enabled, requires whitelist authorization\n     * @dev Formula: IUSD = IUSD x (current month PCE / previous month PCE) / monthlyGrowthFactor\n     */\n    function updateIUSD() external {\n        require(isUpdaterAuthorized(msg.sender), \"Not authorized\");\n\n        // Get data from PCE data source\n        (uint256 currentPCE, uint256 previousPCE) = _pullPCEData();\n        uint256 oldIUSD = iusdValue;\n\n        (uint256 actualInflationMultiplier, uint256 adjustmentFactor) =\n            IUSDMath.adjustmentFactor(currentPCE, previousPCE, Constants.MONTHLY_GROWTH_FACTOR);\n\n        // Update IUSD: IUSD = IUSD x adjustment factor\n        iusdValue = (iusdValue * adjustmentFactor) / Constants.PRECISION_18;\n        lastUpdateTime = block.timestamp;\n\n        // Calculate actual monthly inflation rate (for event)\n        uint256 actualMonthlyRate = actualInflationMultiplier > Constants.PRECISION_18 ?\n            actualInflationMultiplier - Constants.PRECISION_18 : 0;\n\n        // Record history\n        updateHistory.push(IUSDUpdate({\n            timestamp: block.timestamp,\n            oldValue: oldIUSD,\n            newValue: iusdValue,\n            currentPCE: currentPCE,\n            previousPCE: previousPCE,\n            actualMonthlyRate: actualMonthlyRate,\n            adjustmentFactor: adjustmentFactor\n        }));\n\n        emit IUSDUpdated(\n            block.timestamp,\n            oldIUSD,\n            iusdValue,\n            currentPCE,\n            previousPCE,\n            actualMonthlyRate,\n            Constants.MONTHLY_GROWTH_FACTOR - Constants.PRECISION_18, // Convert to monthly growth rate format\n            adjustmentFactor\n        );\n    }\n\n    /**\n     * @notice Queries whether an address has IUSD update permission\n     * @dev If whitelist is not enabled, only owner has permission; when whitelist is enabled, checks authorization list\n     * @param updater Address to query\n     * @return Whether has update permission\n     */\n    function isUpdaterAuthorized(address updater) public view returns (bool) {\n        if (!updaterWhitelistEnabled) {\n            return updater == owner();\n        }\n        return authorizedUpdaters[updater] || updater == owner();\n    }\n\n    /**\n     * @notice Authorizes or revokes updater permission for specified address\n     * @dev Only owner can call, used for managing IUSD update permission whitelist\n     * @param updater Address to authorize\n     * @param authorized true=authorize, false=revoke\n     */\n    function setUpdaterAuthorization(address updater, bool authorized) external onlyOwner {\n        authorizedUpdaters[updater] = authorized;\n        emit UpdaterAuthorized(updater, authorized);\n    }\n\n    /**\n     * @notice Enables or disables updater whitelist mechanism\n     * @dev Only owner can call, disabled by default (only owner can update)\n     * @param enabled true=enable whitelist verification, false=only owner can update\n     */\n    function setUpdaterWhitelistEnabled(bool enabled) external onlyOwner {\n        updaterWhitelistEnabled = enabled;\n    }\n\n    /**\n     * @notice Manually sets IUSD value (for emergency use) - enhanced security version\n     * @param _newIUSDValue New IUSD value (18 decimals)\n     * @param _reason Reason for setting (minimum 20 characters)\n     * @dev Only owner can call, for the following scenarios:\n     *      1. PCE Feed retrieval failed, manual correction needed\n     *      2. updateIUSD() execution failed, emergency adjustment needed\n     *      3. Historical data error found, retroactive correction needed\n     *\n     *      Enhanced security restrictions:\n     *      - New value cannot be 0\n     *      - Deviation between new value and current value cannot exceed +/-5% (reduced from 10%)\n     *      - Must wait at least 7 days between manual overrides\n     *      - Detailed reason required (minimum 20 characters)\n     *      - Override count recorded for auditing\n     *\n     *      Example:\n     *      Monthly PCE not updated in time, theoretical IUSD should be 1.05, but system still shows 1.04\n     *      Call setIUSDValue(1.05e18, \"Manual correction for missed PCE update on 2025-01-15\")\n     */\n    function setIUSDValue(uint256 _newIUSDValue, string calldata _reason) external onlyOwner {\n        require(_newIUSDValue > 0, \"IUSD value must be positive\");\n        require(bytes(_reason).length >= 20, \"Reason must be at least 20 characters\");\n\n        uint256 oldValue = iusdValue;\n\n        // Timelock check: must wait at least 7 days between manual overrides\n        if (lastManualOverrideTime > 0) {\n            require(\n                block.timestamp >= lastManualOverrideTime + MIN_OVERRIDE_INTERVAL,\n                \"Must wait 7 days between manual overrides\"\n            );\n        }\n\n        // Safety check: prevent misoperation, deviation between new and old value cannot exceed +/-5% (reduced from 10%)\n        uint256 deviation;\n        if (_newIUSDValue > oldValue) {\n            deviation = ((_newIUSDValue - oldValue) * Constants.PRECISION_18) / oldValue;\n        } else {\n            deviation = ((oldValue - _newIUSDValue) * Constants.PRECISION_18) / oldValue;\n        }\n        require(\n            deviation <= MAX_MANUAL_DEVIATION,\n            \"Deviation exceeds 5% limit\"\n        );\n\n        // Update IUSD value\n        iusdValue = _newIUSDValue;\n        lastUpdateTime = block.timestamp;\n        lastManualOverrideTime = block.timestamp;\n        manualOverrideCount++;\n\n        // Record to history (with special marker)\n        updateHistory.push(IUSDUpdate({\n            timestamp: block.timestamp,\n            oldValue: oldValue,\n            newValue: _newIUSDValue,\n            currentPCE: 0,        // PCE is 0 for manual setting (marker)\n            previousPCE: 0,       // PCE is 0 for manual setting (marker)\n            actualMonthlyRate: 0,\n            adjustmentFactor: (_newIUSDValue * Constants.PRECISION_18) / oldValue  // Actual adjustment multiplier\n        }));\n\n        // Emit event\n        emit IUSDManuallySet(\n            block.timestamp,\n            oldValue,\n            _newIUSDValue,\n            msg.sender,\n            _reason\n        );\n    }\n\n    // Query functions\n\n    /**\n     * @notice Gets current IUSD value\n     * @dev Returns inflation-adjusted ideal USD price\n     * @return Current IUSD value (18 decimals)\n     */\n    function getCurrentIUSD() external view returns (uint256) {\n        return iusdValue;\n    }\n\n    /**\n     * @notice Gets inflation parameter configuration\n     * @dev Returns annual inflation rate and monthly growth multiplier (from Constants library constants)\n     * @dev Monthly growth rate = monthlyFactor - 1e18, example: 1.001653e18 -> 0.1653%\n     * @return annual Annual inflation rate (18 decimals, e.g., 2e16 = 2%)\n     * @return monthlyFactor Monthly growth multiplier (18 decimals, e.g., 1.001653e18)\n     */\n    function getInflationParameters() external pure returns (uint256 annual, uint256 monthlyFactor) {\n        return (Constants.ANNUAL_INFLATION_RATE, Constants.MONTHLY_GROWTH_FACTOR);\n    }\n\n    /**\n     * @notice Gets current PCE Feed address\n     * @dev Dynamically reads from ConfigGov, supports governance replacement\n     * @return PCE Feed oracle address\n     */\n    function pceFeed() external view returns (address) {\n        return configGov.pceFeed();\n    }\n\n    /**\n     * @notice Gets current PCE Feed decimals\n     * @dev Dynamically reads from PCE Feed contract, no storage needed\n     * @return PCE Feed decimal places\n     */\n    function pceFeedDecimals() external view returns (uint8) {\n        address pceFeedAddr = configGov.pceFeed();\n        require(pceFeedAddr != address(0), \"PCE Feed not configured\");\n        return IAggregatorV3(pceFeedAddr).decimals();\n    }\n\n    /**\n     * @notice Gets IUSD update history record count\n     * @dev Returns updateHistory array length\n     * @return History record count\n     */\n    function getUpdateHistoryLength() external view returns (uint256) {\n        return updateHistory.length;\n    }\n\n    /**\n     * @notice Gets most recent IUSD update record\n     * @dev Reverts if no update records exist\n     * @return Most recent update record (includes timestamp, IUSD value, PCE data, etc.)\n     */\n    function getLatestUpdate() external view returns (IUSDUpdate memory) {\n        require(updateHistory.length > 0, \"No updates yet\");\n        return updateHistory[updateHistory.length - 1];\n    }\n\n    /**\n     * @notice Formats IUSD information for display (human readable)\n     * @dev Returns formatted string with current IUSD value and target inflation rate\n     * @return Formatted string, e.g., \"IUSD: 1.050 Target: 2.00%\"\n     */\n    function getFormattedInfo() external view returns (string memory) {\n        uint256 iusdFormatted = iusdValue / 1e15; // Convert to 3 decimal display\n        uint256 targetPercent = Constants.ANNUAL_INFLATION_RATE / 1e14; // Convert to percentage display (2 decimals)\n\n        return string(abi.encodePacked(\n            \"IUSD: \", _toString(iusdFormatted / 1000), \".\", _toString(iusdFormatted % 1000),\n            \" Target: \", _toString(targetPercent / 100), \".\", _toString(targetPercent % 100), \"%\"\n        ));\n    }\n\n    /**\n     * @notice Internal function to get PCE data from Chainlink\n     * @dev Reads latest PCE value and updates history, uses current value as previous on first call to avoid division by zero\n     * @dev PCE Feed address is dynamically retrieved from ConfigGov, supports governance replacement\n     * @dev Validates PCE change rate does not exceed maximum deviation set in ConfigGov\n     * @return currentPCE Current PCE value (18 decimals)\n     * @return previousPCE Previous PCE value (18 decimals)\n     */\n    function _pullPCEData() private returns (uint256 currentPCE, uint256 previousPCE) {\n        // Get current PCE Feed address from ConfigGov\n        address pceFeedAddr = configGov.pceFeed();\n        require(pceFeedAddr != address(0), \"PCE Feed not configured\");\n\n        currentPCE = FeedValidation.readAggregator(pceFeedAddr);\n        previousPCE = lastPCEValue;\n\n        // For first update, use current value as previous to avoid division by zero and record baseline\n        if (previousPCE == 0) {\n            previousPCE = currentPCE;\n        } else {\n            // Validate PCE change rate does not exceed maximum deviation (prevent abnormal data)\n            uint256 maxDeviation = configGov.pceMaxDeviation();\n            if (maxDeviation > 0) {  // 0 means check disabled\n                uint256 deviation;\n                if (currentPCE > previousPCE) {\n                    deviation = ((currentPCE - previousPCE) * Constants.PRECISION_18) / previousPCE;\n                } else {\n                    deviation = ((previousPCE - currentPCE) * Constants.PRECISION_18) / previousPCE;\n                }\n                require(\n                    deviation <= maxDeviation,\n                    \"PCE deviation exceeds limit\"\n                );\n            }\n        }\n\n        previousPCEValue = previousPCE;\n        lastPCEValue = currentPCE;\n        lastPCEUpdateTime = uint64(block.timestamp);\n    }\n\n    /**\n     * @notice Internal helper function to convert uint256 to string\n     * @dev Used for formatted output\n     * @param value Value to convert\n     * @return String representation\n     */\n    function _toString(uint256 value) private pure returns (string memory) {\n        if (value == 0) return \"0\";\n\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n}\n"
      },
      "project/contracts/InterestPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.4.0\npragma solidity ^0.8.30;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport \"./ConfigCore.sol\";\nimport \"./ConfigGov.sol\";\nimport {IMintableERC20} from \"./interfaces/IMintableERC20.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {IInterestPool} from \"./interfaces/IInterestPool.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/InterestMath.sol\";\n\n/// @title InterestPool\n/// @notice Manages interest accrual for BTD and BTB deposited via stBTD/stBTB vaults.\n///         Users cannot interact with this contract directly - they must use stBTD/stBTB vault contracts.\n///\n///         BTD Deposit Rate (per whitepaper Section 4.1):\n///         - Price < 0.99 IUSD & Falling: Raise rate\n///         - Price < 0.99 IUSD & Rising: Unchanged\n///         - Price in [0.99, 1.01] IUSD: Unchanged\n///         - Price > 1.01 IUSD & Falling: Unchanged\n///         - Price > 1.01 IUSD & Rising: Lower rate\n///\n///         BTB Bond Rate (per whitepaper Section 4.2):\n///         - Price < 0.99 BTD & Falling: Raise rate\n///         - Price < 0.99 BTD & Rising: Unchanged\n///         - Price in [0.99, 1.01] BTD: Unchanged\n///         - Price > 1.01 BTD & Falling: Unchanged\n///         - Price > 1.01 BTD & Rising: Lower rate\n///\n/// @dev Only stBTD and stBTB vault contracts are authorized to call deposit/withdraw functions.\ncontract InterestPool is Ownable, ReentrancyGuard, IInterestPool {\n    using SafeERC20 for IMintableERC20;\n\n    // Price thresholds for rate adjustment (per whitepaper Table 3 & 4)\n    uint256 private constant LOWER_PRICE_THRESHOLD = (Constants.PRECISION_18 * 99) / 100; // 0.99\n    uint256 private constant UPPER_PRICE_THRESHOLD = (Constants.PRECISION_18 * 101) / 100; // 1.01\n\n    // Rate limits\n    uint256 private constant BTD_BASE_RATE = 400;   // 4% in bps (initial rate)\n\n    ConfigCore public immutable core;\n    ConfigGov public gov;\n    address public rateOracle; // Oracle address allowed to update rates\n\n    struct Pool {\n        IMintableERC20 token;\n        uint256 totalStaked;\n        uint256 accInterestPerShare; // Accumulated interest per token, scaled by 1e18\n        uint256 lastAccrual;\n        uint256 annualRateBps; // Current APR in basis points\n    }\n\n    struct UserInfo {\n        uint256 amount; // Staked principal\n        uint256 rewardDebt; // Tracks distributed interest\n    }\n\n    Pool public btdPool;\n    Pool public btbPool;\n\n    mapping(address => UserInfo) private btdUsers;\n    mapping(address => UserInfo) private btbUsers;\n\n    // BTD price tracking (for whitepaper-compliant rate adjustment)\n    uint256 public btdLastPrice; // Last recorded BTD/IUSD price ratio (18 decimals)\n    uint256 public btdLastRateUpdate; // Timestamp of the last BTD rate adjustment\n\n    // BTB price tracking\n    uint256 public btbLastPrice; // Last recorded BTB price in BTD (18 decimals)\n    uint256 public btbLastRateUpdate; // Timestamp of the last BTB rate adjustment\n\n    event RateOracleUpdated(address indexed newOracle);\n    event TreasuryFeeMinted(address indexed token, uint256 amount);\n\n    modifier onlyRateOracle() {\n        require(msg.sender == rateOracle, \"InterestPool: only rate oracle\");\n        _;\n    }\n\n    constructor(\n        address initialOwner,\n        address _core,\n        address _gov,\n        address _rateOracle\n    ) Ownable(initialOwner) {\n        require(initialOwner != address(0), \"InterestPool: invalid owner\");\n        require(_core != address(0), \"InterestPool: core zero\");\n        require(_gov != address(0), \"InterestPool: gov zero\");\n        core = ConfigCore(_core);\n        gov = ConfigGov(_gov);\n\n        address btdAddress = core.BTD();\n        address btbAddress = core.BTB();\n        require(btdAddress != address(0) && btbAddress != address(0), \"Token addresses not set\");\n\n        btdPool = Pool({\n            token: IMintableERC20(btdAddress),\n            totalStaked: 0,\n            accInterestPerShare: 0,\n            lastAccrual: block.timestamp,\n            annualRateBps: BTD_BASE_RATE  // BTD and BTB use same initial rate\n        });\n\n        btbPool = Pool({\n            token: IMintableERC20(btbAddress),\n            totalStaked: 0,\n            accInterestPerShare: 0,\n            lastAccrual: block.timestamp,\n            annualRateBps: BTD_BASE_RATE  // BTB rate is later dynamically adjusted by market mechanism\n        });\n\n    }\n\n    // --- User-facing staking functions removed ---\n    // Users should interact via stBTD/stBTB vault contracts instead of directly with InterestPool\n\n    /// @notice Gets current BTB price\n    /// @dev Reads TWAP-protected BTB price from PriceOracle\n    /// @return BTB price in BTD terms, precision 1e18\n    function getBTBPrice() external view returns (uint256) {\n        return _currentBTBPrice();\n    }\n\n    // --- Rate management ---\n\n    /// @notice Upgrades governance contract\n    /// @dev Only contract owner can call, core addresses in ConfigCore cannot be changed\n    /// @param newGov New ConfigGov contract address\n    function upgradeGov(address newGov) external onlyOwner {\n        require(newGov != address(0), \"Invalid gov\");\n        gov = ConfigGov(newGov);\n    }\n\n    /// @notice Sets rate oracle address\n    /// @dev Only contract owner can call\n    /// @param newOracle New rate oracle address\n    function setRateOracle(address newOracle) external onlyOwner {\n        require(newOracle != address(0), \"InterestPool: zero oracle\");\n        rateOracle = newOracle;\n        emit RateOracleUpdated(newOracle);\n    }\n\n    /// @notice Dynamically updates BTD annual rate (APR) based on BTD/IUSD price\n    /// @dev Per whitepaper Section 4.1 (Table 3 - Deposit Rate Policy):\n    ///      - Price < 0.99 IUSD & Falling: Raise rate (increase attractiveness)\n    ///      - Price < 0.99 IUSD & Rising: Unchanged\n    ///      - Price in [0.99, 1.01] IUSD: Unchanged (target range)\n    ///      - Price > 1.01 IUSD & Falling: Unchanged\n    ///      - Price > 1.01 IUSD & Rising: Lower rate\n    ///      Can only adjust once per day. Only rate oracle can call.\n    function updateBTDAnnualRate() external onlyRateOracle {\n        if (btdLastRateUpdate != 0) {\n            require(block.timestamp >= btdLastRateUpdate + Constants.SECONDS_PER_DAY, \"BTD rate already updated today\");\n        }\n\n        _accruePool(btdPool);\n\n        // Get BTD/IUSD price ratio\n        uint256 price = _currentBTDPriceInIUSD();\n        int256 changeBps = _calculateChangeBps(btdLastPrice, price);\n\n        uint256 oldRate = btdPool.annualRateBps;\n        uint256 newRate = oldRate;\n\n        if (btdLastPrice != 0) {\n            // Per whitepaper Table 3: Deposit Rate Policy\n            if (price < LOWER_PRICE_THRESHOLD && changeBps < 0) {\n                // Price < 0.99 IUSD and falling: raise rate\n                uint256 delta = uint256(-changeBps);\n                newRate += delta;\n            } else if (price > UPPER_PRICE_THRESHOLD && changeBps > 0) {\n                // Price > 1.01 IUSD and rising: lower rate\n                uint256 delta = uint256(changeBps);\n                if (delta >= newRate) {\n                    newRate = 0;\n                } else {\n                    newRate -= delta;\n                }\n            }\n            // Other cases: rate unchanged (per whitepaper)\n        }\n\n        // Apply maximum rate cap from governance\n        uint256 maxRate = gov.maxBTDRate();\n        if (newRate > maxRate) {\n            newRate = maxRate;\n        }\n\n        btdPool.annualRateBps = newRate;\n        btdLastPrice = price;\n        btdLastRateUpdate = block.timestamp;\n\n        emit BTDAnnualRateUpdated(oldRate, newRate);\n    }\n\n    /// @notice Gets current BTD/IUSD price ratio\n    /// @dev BTD/IUSD = BTD_USD_Price / IUSD_Price\n    ///      Returns 1e18 when BTD = 1 IUSD (perfect peg)\n    /// @return BTD/IUSD price ratio (18 decimals, 1e18 = 1.0)\n    function _currentBTDPriceInIUSD() internal view returns (uint256) {\n        IPriceOracle oracle = IPriceOracle(core.PRICE_ORACLE());\n        uint256 btdPriceUSD = oracle.getBTDPrice();  // BTD market price in USD\n        uint256 iusdPrice = oracle.getIUSDPrice();   // IUSD price in USD\n\n        if (iusdPrice == 0) {\n            return Constants.PRECISION_18; // Default to 1.0 if IUSD price unavailable\n        }\n\n        // BTD/IUSD = BTD_USD / IUSD_USD\n        return (btdPriceUSD * Constants.PRECISION_18) / iusdPrice;\n    }\n\n    /// @notice Updates BTB annual rate (APR)\n    /// @dev Can only adjust once per day, based on BTB/BTD price dynamics:\n    ///      - If price < 0.99 BTD and daily change < 0, increase APR (by |change rate|)\n    ///      - If price > 1.01 BTD and daily change > 0, decrease APR (by change rate)\n    ///      - Final APR is constrained to [0, Config.maxBTBRate()] range\n    ///      Only rate oracle or contract owner can call\n    function updateBTBAnnualRate() external onlyRateOracle {\n        if (btbLastRateUpdate != 0) {\n            require(block.timestamp >= btbLastRateUpdate + Constants.SECONDS_PER_DAY, \"BTB rate already updated today\");\n        }\n\n        _accruePool(btbPool);\n\n        uint256 price = _currentBTBPrice();\n        int256 changeBps = _calculateChangeBps(btbLastPrice, price);\n\n        uint256 oldRate = btbPool.annualRateBps;\n        uint256 newRate = oldRate;\n\n        if (btbLastPrice != 0) {\n            if (price < LOWER_PRICE_THRESHOLD && changeBps < 0) {\n                uint256 delta = uint256(-changeBps);\n                newRate += delta;\n            } else if (price > UPPER_PRICE_THRESHOLD && changeBps > 0) {\n                uint256 delta = uint256(changeBps);\n                if (delta >= newRate) {\n                    newRate = 0;\n                } else {\n                    newRate -= delta;\n                }\n            }\n        }\n\n        uint256 maxRate = gov.maxBTBRate();\n        if (newRate > maxRate) {\n            newRate = maxRate;\n        }\n\n        btbPool.annualRateBps = newRate;\n        btbLastPrice = price;\n        btbLastRateUpdate = block.timestamp;\n\n        emit BTBAnnualRateUpdated(oldRate, newRate, price, changeBps);\n    }\n\n    // --- Internal staking logic ---\n    // Direct user staking functions (_stake, _withdraw, _claim) removed\n    // Only stToken vault interface is supported\n\n    function _pendingCurrent(Pool storage pool, UserInfo storage user) internal view returns (uint256) {\n        return InterestMath.pendingReward(user.amount, pool.accInterestPerShare, user.rewardDebt);\n    }\n\n    function _accruePool(Pool storage pool) internal {\n        if (pool.lastAccrual == block.timestamp) {\n            return;\n        }\n\n        if (pool.totalStaked == 0 || pool.annualRateBps == 0) {\n            pool.lastAccrual = block.timestamp;\n            return;\n        }\n\n        uint256 timeElapsed = block.timestamp - pool.lastAccrual;\n        if (timeElapsed == 0) {\n            return;\n        }\n\n        uint256 interestPerShare = InterestMath.interestPerShareDelta(pool.annualRateBps, timeElapsed);\n        if (interestPerShare > 0) {\n            pool.accInterestPerShare += interestPerShare;\n        }\n\n        pool.lastAccrual = block.timestamp;\n    }\n\n    function _payout(Pool storage pool, address recipient, uint256 amount) internal {\n        // Mint interest to user\n        pool.token.mint(recipient, amount);\n\n        // For BTD pool, mint additional 10% fee to treasury\n        if (address(pool.token) == address(btdPool.token)) {\n            address treasury = core.TREASURY();\n            require(treasury != address(0), \"Treasury not set\");\n            uint256 fee = InterestMath.feeAmount(amount, 1000); // 10% = 1000 bps\n            if (fee > 0) {\n                pool.token.mint(treasury, fee);\n                emit TreasuryFeeMinted(address(pool.token), fee);\n            }\n        }\n    }\n\n    // --- Price helpers ---\n\n    /// @notice Gets BTB price from PriceOracle (TWAP protected)\n    /// @dev Uses PriceOracle.getBTBPrice() for TWAP to prevent flash loan attacks\n    ///      Previous version directly used Uniswap reserves (vulnerable to manipulation)\n    /// @return price BTB price in USD terms, precision 1e18\n    function _currentBTBPrice() internal view returns (uint256) {\n        address oracleAddr = core.PRICE_ORACLE();\n        require(oracleAddr != address(0), \"PriceOracle not set\");\n\n        // Get TWAP-protected price from PriceOracle\n        // PriceOracle.getBTBPrice() uses 30-minute TWAP when enabled (production)\n        // or spot price when TWAP is disabled (testing only)\n        uint256 btbPriceUSD = IPriceOracle(oracleAddr).getBTBPrice();\n\n        // Convert from USD to BTD terms (assuming BTD ≈ $1)\n        // Both are in 18 decimals, so direct return\n        return btbPriceUSD;\n    }\n\n    function _calculateChangeBps(uint256 previousPrice, uint256 currentPrice) internal pure returns (int256) {\n        return InterestMath.priceChangeBps(previousPrice, currentPrice);\n    }\n\n    // --- Virtual Staking Interface (for Coinbase integration) ---\n\n    /// @notice Gets total staked amount for a specific token (for virtual pool integration)\n    /// @dev Used for virtual pool integration with platforms like Coinbase\n    /// @param token Token address to query\n    /// @return Total staked amount, precision 1e18\n    function totalStaked(address token) external view returns (uint256) {\n        if (token == address(btdPool.token)) {\n            return btdPool.totalStaked;\n        } else if (token == address(btbPool.token)) {\n            return btbPool.totalStaked;\n        }\n        return 0;\n    }\n\n    /// @notice Gets user's staked amount in a specific token pool (for virtual pool integration)\n    /// @dev Used for virtual pool integration with platforms like Coinbase\n    /// @param token Token address to query\n    /// @param user User address to query\n    /// @return User's staked amount, precision 1e18\n    function userStaked(address token, address user) external view returns (uint256) {\n        if (token == address(btdPool.token)) {\n            return btdUsers[user].amount;\n        } else if (token == address(btbPool.token)) {\n            return btbUsers[user].amount;\n        }\n        return 0;\n    }\n\n    // --- stToken Vault Interface ---\n\n\n    /// @notice Stakes BTD to interest pool\n    /// @dev Anyone can call, automatically accrues interest and pays out pending interest\n    /// @param amount BTD amount to stake, precision 1e18, must be >= minimum stake amount\n    function stakeBTD(uint256 amount) external nonReentrant {\n        require(amount >= Constants.MIN_STABLECOIN_18_AMOUNT, \"Stake amount too small\");\n        require(amount <= Constants.MAX_STABLECOIN_18_AMOUNT, \"Stake amount too large\");\n\n        _accruePool(btdPool);\n\n        UserInfo storage user = btdUsers[msg.sender];\n        uint256 pendingAmount = _pendingCurrent(btdPool, user);\n\n        if (pendingAmount > 0) {\n            _payout(btdPool, msg.sender, pendingAmount);\n            emit InterestClaimed(msg.sender, address(btdPool.token), pendingAmount);\n        }\n\n        btdPool.token.safeTransferFrom(msg.sender, address(this), amount);\n        user.amount += amount;\n        btdPool.totalStaked += amount;\n\n        user.rewardDebt = InterestMath.rewardDebtValue(user.amount, btdPool.accInterestPerShare);\n        emit Staked(msg.sender, address(btdPool.token), amount);\n    }\n\n    /// @notice Stakes BTB to interest pool\n    /// @dev Anyone can call, automatically accrues interest and pays out pending interest\n    /// @param amount BTB amount to stake, precision 1e18, must be >= minimum stake amount\n    function stakeBTB(uint256 amount) external nonReentrant {\n        require(amount >= Constants.MIN_STABLECOIN_18_AMOUNT, \"Stake amount too small\");\n        require(amount <= Constants.MAX_STABLECOIN_18_AMOUNT, \"Stake amount too large\");\n\n        _accruePool(btbPool);\n\n        UserInfo storage user = btbUsers[msg.sender];\n        uint256 pendingAmount = _pendingCurrent(btbPool, user);\n\n        // CEI Pattern: Effects before Interactions\n        // Update state variables BEFORE external calls to prevent reentrancy\n        btbPool.token.safeTransferFrom(msg.sender, address(this), amount);\n        user.amount += amount;\n        btbPool.totalStaked += amount;\n        user.rewardDebt = InterestMath.rewardDebtValue(user.amount, btbPool.accInterestPerShare);\n\n        // Interactions: External calls after state updates\n        if (pendingAmount > 0) {\n            _payout(btbPool, msg.sender, pendingAmount);\n            emit InterestClaimed(msg.sender, address(btbPool.token), pendingAmount);\n        }\n\n        emit Staked(msg.sender, address(btbPool.token), amount);\n    }\n\n    /// @notice Unstakes BTD\n    /// @dev Anyone can call, withdrawal amount can include pending interest\n    ///      Proportionally allocates interest and principal, interest portion is minted, principal portion is transferred from contract balance\n    /// @param amount BTD amount to unstake (can include pending interest), precision 1e18\n    function unstakeBTD(uint256 amount) external nonReentrant {\n        require(amount >= Constants.MIN_STABLECOIN_18_AMOUNT, \"Unstake amount too small\");\n        require(amount <= Constants.MAX_STABLECOIN_18_AMOUNT, \"Unstake amount too large\");\n\n        _accruePool(btdPool);\n\n        UserInfo storage user = btdUsers[msg.sender];\n        uint256 pendingAmount = _pendingCurrent(btdPool, user);\n\n        // Total available = principal + pending interest\n        uint256 totalAvailable = user.amount + pendingAmount;\n        require(totalAvailable >= amount, \"Unstake exceeds balance\");\n\n        // Calculate interest and principal proportionally\n        (uint256 interestShare, uint256 principalShare) = InterestMath.splitWithdrawal(\n            amount,\n            pendingAmount,\n            totalAvailable\n        );\n\n        // Pay out interest portion\n        if (interestShare > 0) {\n            _payout(btdPool, msg.sender, interestShare);\n            emit InterestClaimed(msg.sender, address(btdPool.token), interestShare);\n        }\n\n        // Withdraw principal portion\n        if (principalShare > 0) {\n            user.amount -= principalShare;\n            btdPool.totalStaked -= principalShare;\n            btdPool.token.safeTransfer(msg.sender, principalShare);\n            emit Withdrawn(msg.sender, address(btdPool.token), principalShare);\n        }\n\n        user.rewardDebt = InterestMath.rewardDebtValue(user.amount, btdPool.accInterestPerShare);\n    }\n\n    /// @notice Unstakes BTB\n    /// @dev Anyone can call, withdrawal amount can include pending interest\n    ///      Proportionally allocates interest and principal, interest portion is minted, principal portion is transferred from contract balance\n    /// @param amount BTB amount to unstake (can include pending interest), precision 1e18\n    function unstakeBTB(uint256 amount) external nonReentrant {\n        require(amount >= Constants.MIN_STABLECOIN_18_AMOUNT, \"Unstake amount too small\");\n        require(amount <= Constants.MAX_STABLECOIN_18_AMOUNT, \"Unstake amount too large\");\n\n        _accruePool(btbPool);\n\n        UserInfo storage user = btbUsers[msg.sender];\n        uint256 pendingAmount = _pendingCurrent(btbPool, user);\n\n        // Total available = principal + pending interest\n        uint256 totalAvailable = user.amount + pendingAmount;\n        require(totalAvailable >= amount, \"Unstake exceeds balance\");\n\n        // Calculate interest and principal proportionally\n        (uint256 interestShare, uint256 principalShare) = InterestMath.splitWithdrawal(\n            amount,\n            pendingAmount,\n            totalAvailable\n        );\n\n        // Pay out interest portion\n        if (interestShare > 0) {\n            _payout(btbPool, msg.sender, interestShare);\n            emit InterestClaimed(msg.sender, address(btbPool.token), interestShare);\n        }\n\n        // Withdraw principal portion\n        if (principalShare > 0) {\n            user.amount -= principalShare;\n            btbPool.totalStaked -= principalShare;\n            btbPool.token.safeTransfer(msg.sender, principalShare);\n            emit Withdrawn(msg.sender, address(btbPool.token), principalShare);\n        }\n\n        user.rewardDebt = InterestMath.rewardDebtValue(user.amount, btbPool.accInterestPerShare);\n    }\n}\n"
      },
      "project/contracts/interfaces/IAggregatorV3.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title IAggregatorV3 - Chainlink price aggregator V3 interface\n * @notice Standard interface for Chainlink price oracle, used for querying on-chain price data\n */\ninterface IAggregatorV3 {\n    /**\n     * @notice Get decimals for price data\n     * @return Decimal places for price precision (e.g., 8 means price needs to be divided by 1e8)\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @notice Get latest round price data\n     * @return roundId Price round ID\n     * @return answer Price answer (needs precision adjustment based on decimals())\n     * @return startedAt This round start timestamp\n     * @return updatedAt This round update timestamp\n     * @return answeredInRound This round answer round ID\n     */\n    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
      },
      "project/contracts/interfaces/IFarmingPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IFarmingPool - Standard interface for yield farming contract\n * @notice Defines the core functionality interface for the yield farming contract\n */\ninterface IFarmingPool {\n    enum PoolKind {\n        Single,\n        LP\n    }\n\n    struct PoolInfo {\n        IERC20 lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardTime;\n        uint256 accRewardPerShare;\n        uint256 totalStaked;\n        uint256 cachedLPValuePerToken;  // Cached LP value per token (18 decimal precision USD)\n        uint256 lastPriceUpdate;        // Last price update timestamp\n        PoolKind kind;                  // Pool type\n    }\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n    }\n\n    // --- Mining Operations ---\n    /**\n     * @notice User deposits tokens to specified mining pool\n     * @param _pid Pool ID\n     * @param _amount Deposit amount\n     */\n    function deposit(uint256 _pid, uint256 _amount) external;\n\n    /**\n     * @notice User withdraws tokens from specified mining pool\n     * @param _pid Pool ID\n     * @param _amount Withdrawal amount\n     */\n    function withdraw(uint256 _pid, uint256 _amount) external;\n\n    /**\n     * @notice User claims rewards from specified mining pool\n     * @param _pid Pool ID\n     */\n    function claim(uint256 _pid) external;\n\n    /**\n     * @notice Emergency withdrawal, forfeit rewards and retrieve principal\n     * @param _pid Pool ID\n     */\n    function emergencyWithdraw(uint256 _pid) external;\n\n    // --- Proxy Operations (for Router contract) ---\n    /**\n     * @notice Deposit tokens on behalf of another user (called by Router contract)\n     * @param _pid Pool ID\n     * @param _amount Deposit amount\n     * @param _onBehalfOf Actual beneficiary address\n     */\n    function depositFor(uint256 _pid, uint256 _amount, address _onBehalfOf) external;\n\n    /**\n     * @notice Withdraw tokens on behalf of another user (called by Router contract)\n     * @param _pid Pool ID\n     * @param _amount Withdrawal amount\n     * @param _onBehalfOf Token owner address\n     * @param _to Recipient address\n     */\n    function withdrawFor(uint256 _pid, uint256 _amount, address _onBehalfOf, address _to) external;\n\n    /**\n     * @notice Claim rewards on behalf of another user (called by Router contract)\n     * @param _pid Pool ID\n     * @param _onBehalfOf Actual beneficiary address\n     */\n    function claimFor(uint256 _pid, address _onBehalfOf) external;\n\n    /**\n     * @notice Inject BRS reward tokens into reward pool\n     * @param amount BRS amount\n     */\n    function fundRewards(uint256 amount) external;\n\n    // --- Pool Management ---\n    /**\n     * @notice Add new mining pool\n     * @param _token Staking token (single token or LP token)\n     * @param _allocPoint Allocation points, determines reward distribution weight for this pool\n     * @param _kind Pool type (Single=single token pool, LP=liquidity pool)\n     * @param _withUpdate Whether to update rewards for all pools first\n     */\n    function addPool(IERC20 _token, uint256 _allocPoint, PoolKind _kind, bool _withUpdate) external;\n\n    /**\n     * @notice Add new mining pool (default: don't update other pools)\n     * @param _token Staking token (single token or LP token)\n     * @param _allocPoint Allocation points\n     * @param _kind Pool type\n     */\n    function addPool(IERC20 _token, uint256 _allocPoint, PoolKind _kind) external;\n\n    /**\n     * @notice Batch add multiple mining pools\n     * @param _tokens Array of staking tokens\n     * @param _allocPoints Array of allocation points\n     * @param _kinds Array of pool types\n     */\n    function addPools(\n        IERC20[] calldata _tokens,\n        uint256[] calldata _allocPoints,\n        PoolKind[] calldata _kinds\n    ) external;\n\n    /**\n     * @notice Modify allocation points for specified mining pool\n     * @param _pid Pool ID\n     * @param _allocPoint New allocation points\n     * @param _withUpdate Whether to update rewards for all pools first\n     */\n    function setPool(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;\n\n    // --- Query Functions ---\n    /**\n     * @notice Get total number of mining pools\n     * @return Number of mining pools\n     */\n    function poolLength() external view returns (uint256);\n\n    /**\n     * @notice Query user's pending rewards\n     * @param _pid Pool ID\n     * @param _user User address\n     * @return Pending BRS reward amount\n     */\n    function pendingReward(uint256 _pid, address _user) external view returns (uint256);\n\n    // Auto-generated getter functions (from public storage variables)\n    /**\n     * @notice Get user info for specified pool\n     * @param _pid Pool ID\n     * @param _user User address\n     * @return amount User's staked token amount\n     * @return rewardDebt Debt value used for reward calculation\n     */\n    function userInfo(uint256 _pid, address _user) external view returns (uint256 amount, uint256 rewardDebt);\n\n    /**\n     * @notice Get detailed info for specified pool\n     * @param _pid Pool ID\n     * @return lpToken Staking token contract\n     * @return allocPoint Allocation points\n     * @return lastRewardTime Last reward calculation timestamp\n     * @return accRewardPerShare Accumulated reward per share\n     * @return totalStaked Total staked amount\n     * @return cachedLPValuePerToken Cached LP value per token (18 decimal precision USD)\n     * @return lastPriceUpdate Last price update timestamp\n     * @return kind Pool type\n     */\n    function poolInfo(uint256 _pid) external view returns (\n        IERC20 lpToken,\n        uint256 allocPoint,\n        uint256 lastRewardTime,\n        uint256 accRewardPerShare,\n        uint256 totalStaked,\n        uint256 cachedLPValuePerToken,\n        uint256 lastPriceUpdate,\n        PoolKind kind\n    );\n\n    /**\n     * @notice Get pool type for specified pool\n     * @param _pid Pool ID\n     * @return Pool type (Single or LP)\n     */\n    function poolKind(uint256 _pid) external view returns (PoolKind);\n\n\n    // --- Reward Parameters ---\n    /**\n     * @notice Get current reward rate per second\n     * @return Current BRS reward produced per second\n     */\n    function currentRewardPerSecond() external view returns (uint256);\n\n    /**\n     * @notice Get BRS token contract address\n     * @return BRS token address\n     */\n    function brs() external view returns (address);\n\n    /**\n     * @notice Get mining start time\n     * @return Block timestamp when mining started\n     */\n    function startTime() external view returns (uint256);\n\n    /**\n     * @notice Get total minted BRS\n     * @return Cumulative minted BRS amount\n     */\n    function minted() external view returns (uint256);\n\n    // --- LP Value Management ---\n    /**\n     * @notice Update LP token value cache for specified pool\n     * @param _pid Pool ID\n     */\n    function updateLPValue(uint256 _pid) external;\n\n    /**\n     * @notice Check if specified pool needs LP value update\n     * @param _pid Pool ID\n     * @return needs Whether update is needed\n     * @return timeSinceUpdate Time since last update (seconds)\n     */\n    function needsUpdate(uint256 _pid) external view returns (bool needs, uint256 timeSinceUpdate);\n\n    // --- Events ---\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Claim(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event LPValueUpdated(uint256 indexed pid, uint256 newValuePerToken, uint256 timestamp);\n}\n"
      },
      "project/contracts/interfaces/IFunctionsRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title IFunctionsRouter - Chainlink Functions router interface\n * @notice Standard interface for managing Chainlink Functions subscriptions and consumers\n */\ninterface IFunctionsRouter {\n    /**\n     * @notice Add consumer to specified subscription\n     * @param subscriptionId Chainlink Functions subscription ID\n     * @param consumer Consumer contract address\n     */\n    function addConsumer(uint64 subscriptionId, address consumer) external;\n\n    /**\n     * @notice Remove consumer from specified subscription\n     * @param subscriptionId Chainlink Functions subscription ID\n     * @param consumer Consumer contract address\n     */\n    function removeConsumer(uint64 subscriptionId, address consumer) external;\n\n    /**\n     * @notice Check if address is a consumer of specified subscription\n     * @param subscriptionId Chainlink Functions subscription ID\n     * @param consumer Address to check\n     * @return true if consumer, false otherwise\n     */\n    function getConsumer(uint64 subscriptionId, address consumer) external view returns (bool);\n}\n"
      },
      "project/contracts/interfaces/IIdealUSDManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title IIdealUSDManager - Standard interface for IdealUSDManager contract\n * @notice Defines the core functionality interface for the IdealUSDManager contract\n */\ninterface IIdealUSDManager {\n    /**\n     * @notice Get the current Ideal USD value (IUSD)\n     * @return The current IUSD value (18 decimal precision)\n     */\n    function getCurrentIUSD() external view returns (uint256);\n\n    /**\n     * @notice Get the timestamp of the last update\n     * @return The update timestamp\n     */\n    function lastUpdateTime() external view returns (uint256);\n}\n"
      },
      "project/contracts/interfaces/IInterestPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title IInterestPool - Standard interface for interest pool\n * @notice Defines the core functionality interface for the InterestPool contract\n * @dev Users can directly stake BTD/BTB to the interest pool without going through vault\n */\ninterface IInterestPool {\n    // ============ BTD Operations ============\n\n    /**\n     * @notice Stake BTD to the interest pool\n     * @param amount BTD amount\n     */\n    function stakeBTD(uint256 amount) external;\n\n    /**\n     * @notice Unstake BTD\n     * @param amount BTD amount\n     */\n    function unstakeBTD(uint256 amount) external;\n\n    // ============ BTB Operations ============\n\n    /**\n     * @notice Stake BTB to the interest pool\n     * @param amount BTB amount\n     */\n    function stakeBTB(uint256 amount) external;\n\n    /**\n     * @notice Unstake BTB\n     * @param amount BTB amount\n     */\n    function unstakeBTB(uint256 amount) external;\n\n    // ============ Interest Rate Management ============\n\n    /**\n     * @notice Update BTD annual rate (read on-chain from FFR Oracle)\n     * @dev No parameters needed, reads latest rate directly from FFR Oracle\n     */\n    function updateBTDAnnualRate() external;\n\n    /**\n     * @notice Update BTB annual rate (automatically adjusts based on BTB price)\n     */\n    function updateBTBAnnualRate() external;\n\n    // ============ Events ============\n\n    event Staked(address indexed user, address indexed token, uint256 amount);\n    event Withdrawn(address indexed user, address indexed token, uint256 amount);\n    event InterestClaimed(address indexed user, address indexed token, uint256 amount);\n    event BTDAnnualRateUpdated(uint256 oldRateBps, uint256 newRateBps);\n    event BTBAnnualRateUpdated(uint256 oldRateBps, uint256 newRateBps, uint256 price, int256 dailyChangeBps);\n}\n"
      },
      "project/contracts/interfaces/IMintableERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IMintableERC20 - Mintable ERC20 interface\n * @notice Defines the standard interface for ERC20 tokens with mint and burn functionality\n * @dev Applicable to system tokens such as BTD, BTB, BRS\n */\ninterface IMintableERC20 is IERC20 {\n    /**\n     * @notice Mint tokens\n     * @param to Recipient address\n     * @param amount Amount to mint\n     */\n    function mint(address to, uint256 amount) external;\n\n    /**\n     * @notice Burn tokens from a specified account\n     * @param account Account to burn from\n     * @param amount Amount to burn\n     */\n    function burnFrom(address account, uint256 amount) external;\n}\n"
      },
      "project/contracts/interfaces/IMinter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title IMinter - Standard interface for Minter contract\n * @notice Defines the core functionality interface for the Minter contract\n */\ninterface IMinter {\n    // --- Minting Operations ---\n    /**\n     * @notice Mint BTD stablecoin using WBTC\n     * @param wbtcAmount Amount of WBTC\n     */\n    function mintBTD(uint256 wbtcAmount) external;\n\n    // --- Redemption Operations ---\n    /**\n     * @notice Redeem BTD to receive WBTC, BTB, and BRS based on collateral ratio\n     * @param btdAmount Amount of BTD to redeem\n     */\n    function redeemBTD(uint256 btdAmount) external;\n\n    /**\n     * @notice Exchange BTB for BTD at 1:1 ratio (requires CR>100%)\n     * @param btbAmount Amount of BTB to exchange\n     */\n    function redeemBTB(uint256 btbAmount) external;\n\n    // --- Query Functions ---\n    // Note: getBTDPrice() and getBTBPrice() have been removed, please call PriceOracle.getBTDPrice() and getBTBPrice() directly\n\n    /**\n     * @notice Get system collateral ratio\n     * @return Collateral ratio, 18 decimal precision (e.g., 1.5e18 represents 150%)\n     */\n    function getCollateralRatio() external view returns (uint256);\n\n    /**\n     * @notice Get ConfigCore contract address\n     * @dev ConfigCore is immutable, cannot be changed after deployment\n     * @return ConfigCore contract address\n     */\n    function configCore() external view returns (address);\n\n    /**\n     * @notice Get ConfigGov contract address\n     * @dev ConfigGov can be updated via upgradeGov()\n     * @return ConfigGov contract address\n     */\n    function configGov() external view returns (address);\n\n    // --- Calculation Functions ---\n    /**\n     * @notice Calculate BTD mint amount and fee (without executing actual mint)\n     * @param wbtcAmount Input WBTC amount, 8 decimal precision\n     * @return btdAmount Mintable BTD amount, 18 decimal precision\n     * @return fee Minting fee (denominated in BTD), 18 decimal precision\n     */\n    function calculateMintAmount(uint256 wbtcAmount) external view returns (uint256 btdAmount, uint256 fee);\n\n    /**\n     * @notice Calculate WBTC amount and fee when redeeming BTD (without executing actual redemption)\n     * @param btdAmount Input BTD amount, 18 decimal precision\n     * @return wbtcAmount Redeemable WBTC amount, 8 decimal precision\n     * @return fee Redemption fee (denominated in WBTC), 8 decimal precision\n     */\n    function calculateBurnAmount(uint256 btdAmount) external view returns (uint256 wbtcAmount, uint256 fee);\n\n    // --- Events ---\n    event BTDMinted(address indexed user, uint256 wbtcAmount, uint256 btdAmount, uint256 fee);\n    event BTDRedeemed(\n        address indexed user,\n        uint256 btdAmount,\n        uint256 wbtcAmount,\n        uint256 btbAmount,\n        uint256 brsAmount\n    );\n    event BTBRedeemed(address indexed user, uint256 btbAmount, uint256 btdAmount);\n}\n"
      },
      "project/contracts/interfaces/IPriceOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title IPriceOracle - Standard interface for price oracle\n * @notice Provides a unified price query interface for the entire BRS system\n * @dev All prices are returned with 18 decimal precision (1e18 = $1)\n */\ninterface IPriceOracle {\n    // ============ Events ============\n\n    event TWAPOracleUpdated(address indexed oldOracle, address indexed newOracle);\n    event TWAPModeChanged(bool enabled);\n    event PriceQueried(address indexed token, uint256 price, uint256 timestamp);\n\n    // ============ Core Price Query Interface ============\n\n    /**\n     * @notice Get WBTC/USD price (multi-oracle verification)\n     * @dev Aggregates Chainlink (WBTC/BTC & BTC/USD), Pyth, Redstone as reference,\n     *      Uniswap TWAP/spot as final price, requires deviation <1% from reference median\n     * @return price WBTC price, 18 decimal precision (e.g., $50,000 = 50000e18)\n     */\n    function getWBTCPrice() external view returns (uint256 price);\n\n    /**\n     * @notice Get BTD/USD actual market price\n     * @dev Queries BTD's actual market price from Uniswap BTD/USDC pool\n     *      Note: This is BTD's actual trading price, which may deviate from IUSD target price\n     * @return price BTD price, 18 decimal precision\n     */\n    function getBTDPrice() external view returns (uint256 price);\n\n    /**\n     * @notice Get BTB/USD price\n     * @dev Calculated via chain: BTB/BTD x BTD/USDC = BTB/USD\n     * @return price BTB price, 18 decimal precision\n     */\n    function getBTBPrice() external view returns (uint256 price);\n\n    /**\n     * @notice Get BRS/USD price\n     * @dev Calculated via chain: BRS/BTD x BTD/USDC = BRS/USD\n     * @return price BRS price, 18 decimal precision\n     */\n    function getBRSPrice() external view returns (uint256 price);\n\n    /**\n     * @notice Get IUSD price (Ideal USD)\n     * @dev Queries current IUSD value from IdealUSDManager contract\n     * @return price IUSD price, 18 decimal precision\n     */\n    function getIUSDPrice() external view returns (uint256 price);\n\n    /**\n     * @notice Get USD price by token address (generic price query)\n     * @dev Supports WBTC, BTD, BTB, BRS, USDC, USDT\n     * @param token Token address\n     * @return price Token's USD price, 18 decimal precision\n     */\n    function getPrice(address token) external view returns (uint256 price);\n\n    /**\n     * @notice Get generic token pair price\n     * @dev Automatically uses TWAP (if enabled) or spot price\n     * @param pool Uniswap V2 pair address\n     * @param base Base token address\n     * @param quote Quote token address\n     * @return price Price (quote/base), 18 decimal precision\n     */\n    function getPrice(address pool, address base, address quote)\n        external view returns (uint256 price);\n\n    // ============ TWAP Management Interface ============\n\n    /**\n     * @notice Set TWAP Oracle address\n     * @param _twapOracle UniswapV2TWAPOracle contract address\n     */\n    function setTWAPOracle(address _twapOracle) external;\n\n    /**\n     * @notice Enable or disable TWAP mode\n     * @dev TWAP mode should be enabled in production, can be disabled in test environment\n     * @param _useTWAP true=use TWAP (secure), false=use spot price (testing only)\n     */\n    function setUseTWAP(bool _useTWAP) external;\n\n    /**\n     * @notice Check if TWAP is enabled\n     * @return enabled true=TWAP is enabled\n     */\n    function isTWAPEnabled() external view returns (bool enabled);\n\n    /**\n     * @notice Get TWAP Oracle address\n     * @return oracle TWAP Oracle contract address\n     */\n    function getTWAPOracle() external view returns (address oracle);\n\n    // ============ Chainlink Related ============\n\n    /**\n     * @notice Get Chainlink BTC/USD price\n     * @dev Used only as validator, not as primary price source\n     * @return price BTC/USD price, 18 decimal precision\n     */\n    function getChainlinkBTCUSD() external view returns (uint256 price);\n}\n"
      },
      "project/contracts/interfaces/ITreasury.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title ITreasury - Standard interface for Treasury contract\n * @notice Defines the core functionality interface for the Treasury contract\n */\ninterface ITreasury {\n    // --- Asset Management ---\n    /**\n     * @notice Deposit WBTC from caller (Minter) to treasury\n     * @dev Minter must first receive WBTC from user and approve to Treasury before calling\n     * @param amt WBTC amount\n     */\n    function depositWBTC(uint256 amt) external;\n\n    /**\n     * @notice Withdraw WBTC from treasury to caller (Minter)\n     * @dev Minter is responsible for transferring WBTC to end user\n     * @param amt WBTC amount\n     */\n    function withdrawWBTC(uint256 amt) external;\n\n    /**\n     * @notice Compensate user with BRS tokens from treasury\n     * @param to Recipient address\n     * @param amt BRS amount\n     */\n    function compensate(address to, uint256 amt) external;\n\n    /**\n     * @notice Buyback BRS using BTD from Uniswap\n     * @param btdAmount BTD amount\n     * @param minBRSOut Minimum BRS output amount (slippage protection)\n     */\n    function buybackBRS(uint256 btdAmount, uint256 minBRSOut) external;\n\n    // --- Configuration Management ---\n    /**\n     * @notice Update Uniswap Router address\n     * @param newRouter New Router address\n     */\n    function setRouter(address newRouter) external;\n\n    // --- Query Functions ---\n    function getBalances()\n        external\n        view\n        returns (uint256 wbtcBalance, uint256 brsBalance, uint256 btdBalance);\n\n    function configCore() external view returns (address);\n    function router() external view returns (address);\n\n    // --- Events ---\n    event WBTCDeposited(address indexed from, uint256 amount);\n    event WBTCWithdrawn(address indexed to, uint256 amount);\n    event BRSCompensated(address indexed to, uint256 amount);\n    event BRSBuyback(uint256 btdAmount, uint256 brsReceived);\n}\n"
      },
      "project/contracts/interfaces/IUniswapV2Callee.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n/**\n * @title IUniswapV2Callee - Uniswap V2 callback interface\n * @notice Standard interface for receiving Uniswap V2 flash loan callbacks\n */\ninterface IUniswapV2Callee {\n    /**\n     * @notice Uniswap V2 flash loan callback function\n     * @param sender Address that initiated the swap\n     * @param amount0 Amount of token0 borrowed\n     * @param amount1 Amount of token1 borrowed\n     * @param data Custom data passed to swap\n     */\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
      },
      "project/contracts/interfaces/IUniswapV2Factory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n/**\n * @title IUniswapV2Factory - Uniswap V2 factory contract interface\n * @notice Standard interface for creating and managing Uniswap V2 trading pairs\n */\ninterface IUniswapV2Factory {\n    /**\n     * @notice Emitted when a new pair is created\n     * @param token0 First token address\n     * @param token1 Second token address\n     * @param pair Newly created pair address\n     */\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    /**\n     * @notice Get fee recipient address\n     * @return Fee recipient address\n     */\n    function feeTo() external view returns (address);\n\n    /**\n     * @notice Get fee setter address\n     * @return Fee setter address\n     */\n    function feeToSetter() external view returns (address);\n\n    /**\n     * @notice Get pair address for two tokens\n     * @param tokenA Token A address\n     * @param tokenB Token B address\n     * @return pair Pair address, returns zero address if not exists\n     */\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    /**\n     * @notice Get pair address by index\n     * @param index Pair index\n     * @return pair Pair address\n     */\n    function allPairs(uint index) external view returns (address pair);\n\n    /**\n     * @notice Get total number of pairs\n     * @return Total number of pairs\n     */\n    function allPairsLength() external view returns (uint);\n\n    /**\n     * @notice Create a new trading pair\n     * @param tokenA Token A address\n     * @param tokenB Token B address\n     * @return pair Newly created pair address\n     */\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    /**\n     * @notice Set fee recipient address\n     * @param _feeTo New fee recipient address\n     */\n    function setFeeTo(address _feeTo) external;\n\n    /**\n     * @notice Set fee setter address\n     * @param _feeToSetter New fee setter address\n     */\n    function setFeeToSetter(address _feeToSetter) external;\n}\n"
      },
      "project/contracts/interfaces/IUniswapV2Pair.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n/**\n * @title IUniswapV2Pair - Uniswap V2 trading pair interface\n * @notice Defines the standard interface for Uniswap V2 liquidity pools, including ERC20 functionality and AMM trading functionality\n */\ninterface IUniswapV2Pair {\n    /**\n     * @notice Emitted when allowance changes\n     * @param owner Token owner\n     * @param spender Approved spender\n     * @param value Approved amount\n     */\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    /**\n     * @notice Emitted when tokens are transferred\n     * @param from Sender\n     * @param to Recipient\n     * @param value Transfer amount\n     */\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    /**\n     * @notice Get LP token name\n     * @return LP token name\n     */\n    function name() external pure returns (string memory);\n\n    /**\n     * @notice Get LP token symbol\n     * @return LP token symbol\n     */\n    function symbol() external pure returns (string memory);\n\n    /**\n     * @notice Get LP token decimals\n     * @return LP token decimals (usually 18)\n     */\n    function decimals() external pure returns (uint8);\n\n    /**\n     * @notice Get LP token total supply\n     * @return LP token total amount\n     */\n    function totalSupply() external view returns (uint);\n\n    /**\n     * @notice Get account's LP token balance\n     * @param owner Account address\n     * @return LP token balance\n     */\n    function balanceOf(address owner) external view returns (uint);\n\n    /**\n     * @notice Get allowance\n     * @param owner Token owner\n     * @param spender Approved spender\n     * @return Allowance amount\n     */\n    function allowance(address owner, address spender) external view returns (uint);\n\n    /**\n     * @notice Approve another address to use your LP tokens\n     * @param spender Approved spender\n     * @param value Approved amount\n     * @return Success status\n     */\n    function approve(address spender, uint value) external returns (bool);\n\n    /**\n     * @notice Transfer LP tokens\n     * @param to Recipient\n     * @param value Transfer amount\n     * @return Success status\n     */\n    function transfer(address to, uint value) external returns (bool);\n\n    /**\n     * @notice Transfer LP tokens from another account (requires approval)\n     * @param from Sender\n     * @param to Recipient\n     * @param value Transfer amount\n     * @return Success status\n     */\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    /**\n     * @notice Get EIP-712 domain separator\n     * @return EIP-712 domain separator hash\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /**\n     * @notice Get permit type hash\n     * @return Permit type hash value\n     */\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    /**\n     * @notice Get account's signature nonce\n     * @param owner Account address\n     * @return Nonce value\n     */\n    function nonces(address owner) external view returns (uint);\n\n    /**\n     * @notice Approve token usage via signature (EIP-2612)\n     * @param owner Token owner\n     * @param spender Approved spender\n     * @param value Approved amount\n     * @param deadline Approval deadline\n     * @param v Signature parameter v\n     * @param r Signature parameter r\n     * @param s Signature parameter s\n     */\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @notice Emitted when liquidity is added\n     * @param sender Operation initiator\n     * @param amount0 Amount of token0 added\n     * @param amount1 Amount of token1 added\n     */\n    event Mint(address indexed sender, uint amount0, uint amount1);\n\n    /**\n     * @notice Emitted when liquidity is removed\n     * @param sender Operation initiator\n     * @param amount0 Amount of token0 removed\n     * @param amount1 Amount of token1 removed\n     * @param to Recipient address\n     */\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n\n    /**\n     * @notice Emitted when a swap is executed\n     * @param sender Operation initiator\n     * @param amount0In Input amount of token0\n     * @param amount1In Input amount of token1\n     * @param amount0Out Output amount of token0\n     * @param amount1Out Output amount of token1\n     * @param to Recipient address\n     */\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n\n    /**\n     * @notice Emitted when reserves are synced\n     * @param reserve0 token0 reserve\n     * @param reserve1 token1 reserve\n     */\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    /**\n     * @notice Get minimum liquidity (minimum LP locked at zero address)\n     * @return Minimum liquidity value (usually 1000)\n     */\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n\n    /**\n     * @notice Get factory contract address\n     * @return Factory contract address\n     */\n    function factory() external view returns (address);\n\n    /**\n     * @notice Get token0 address\n     * @return token0 contract address\n     */\n    function token0() external view returns (address);\n\n    /**\n     * @notice Get token1 address\n     * @return token1 contract address\n     */\n    function token1() external view returns (address);\n\n    /**\n     * @notice Get reserves info\n     * @return reserve0 token0 reserve\n     * @return reserve1 token1 reserve\n     * @return blockTimestampLast Last update timestamp\n     */\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    /**\n     * @notice Get token0 cumulative price\n     * @return token0 cumulative price (used for TWAP calculation)\n     */\n    function price0CumulativeLast() external view returns (uint);\n\n    /**\n     * @notice Get token1 cumulative price\n     * @return token1 cumulative price (used for TWAP calculation)\n     */\n    function price1CumulativeLast() external view returns (uint);\n\n    /**\n     * @notice Get last k value (reserve0 * reserve1)\n     * @return k value\n     */\n    function kLast() external view returns (uint);\n\n    /**\n     * @notice Mint LP tokens (add liquidity)\n     * @param to LP token recipient address\n     * @return liquidity Amount of LP tokens minted\n     */\n    function mint(address to) external returns (uint liquidity);\n\n    /**\n     * @notice Burn LP tokens (remove liquidity)\n     * @param to Underlying token recipient address\n     * @return amount0 Amount of token0 returned\n     * @return amount1 Amount of token1 returned\n     */\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    /**\n     * @notice Execute token swap\n     * @param amount0Out Output amount of token0\n     * @param amount1Out Output amount of token1\n     * @param to Recipient address\n     * @param data Callback data (for flash loans)\n     */\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n\n    /**\n     * @notice Force balance to match reserves (remove excess tokens)\n     * @param to Excess token recipient address\n     */\n    function skim(address to) external;\n\n    /**\n     * @notice Force update reserves to match balance\n     */\n    function sync() external;\n\n    /**\n     * @notice Initialize trading pair (set token0 and token1)\n     * @param _token0 token0 address\n     * @param _token1 token1 address\n     */\n    function initialize(address _token0, address _token1) external;\n}\n"
      },
      "project/contracts/interfaces/IUniswapV2TWAPOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title IUniswapV2TWAPOracle\n * @notice Uniswap V2 Time-Weighted Average Price (TWAP) oracle interface\n * @dev Defines the standard interface for TWAP Oracle, used to prevent flash loan price manipulation\n */\ninterface IUniswapV2TWAPOracle {\n\n    /**\n     * @notice Get the TWAP price for a trading pair\n     * @param pair Uniswap V2 pair address\n     * @param token0Decimals Decimals of token0\n     * @param token1Decimals Decimals of token1\n     * @return TWAP price (18 decimal precision)\n     * @dev Returns the TWAP price of token1 denominated in token0\n     */\n    function getTWAPPrice(address pair, uint8 token0Decimals, uint8 token1Decimals)\n        external view returns (uint256);\n\n    /**\n     * @notice Check if TWAP is ready\n     * @param pair Uniswap V2 pair address\n     * @return true if TWAP has been initialized and is ready to use\n     * @dev Should check this function before calling getTWAPPrice\n     */\n    function isTWAPReady(address pair) external view returns (bool);\n\n    /**\n     * @notice Update the cumulative price for a trading pair\n     * @param pair Uniswap V2 pair address\n     * @dev Should be called periodically to maintain accurate TWAP data\n     */\n    function update(address pair) external;\n}\n"
      },
      "project/contracts/libraries/CollateralMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./Constants.sol\";\n\n/**\n * @title CollateralMath - Collateral Value and Liability Calculation Library\n * @notice Pure function library for centralized management of collateral value, liability, and quota calculations\n * @dev Provides calculation functions for core financial metrics such as collateral ratio and redeemable quota\n */\nlibrary CollateralMath {\n\n    /**\n     * @notice Calculate the USD value of collateral\n     * @dev Formula: Value = (WBTC Balance × WBTC Price) / 1e8\n     * @param wbtcBalance WBTC balance (8 decimals)\n     * @param wbtcPrice WBTC price (18 decimals, unit: USD)\n     * @return Collateral USD value (18 decimals)\n     */\n    function collateralValue(uint256 wbtcBalance, uint256 wbtcPrice) internal pure returns (uint256) {\n        if (wbtcBalance == 0 || wbtcPrice == 0) {\n            return 0;\n        }\n        return Math.mulDiv(wbtcBalance, wbtcPrice, Constants.PRECISION_8);\n    }\n\n    /**\n     * @notice Calculate the USD value of liability\n     * @dev Formula: Value = (Total BTD Equivalent × IUSD Price) / 1e18\n     *      Total BTD Equivalent = BTD Supply + stBTD converted to BTD amount\n     * @param btdSupply BTD total supply (18 decimals)\n     * @param stBTDEquivalent stBTD converted to BTD amount (18 decimals)\n     * @param iusdPrice IUSD price (18 decimals, unit: USD)\n     * @return Liability USD value (18 decimals)\n     */\n    function liabilityValue(uint256 btdSupply, uint256 stBTDEquivalent, uint256 iusdPrice) internal pure returns (uint256) {\n        uint256 totalBTD = btdSupply + stBTDEquivalent;\n        if (totalBTD == 0 || iusdPrice == 0) {\n            return 0;\n        }\n        return Math.mulDiv(totalBTD, iusdPrice, Constants.PRECISION_18);\n    }\n\n    /**\n     * @notice Calculate Collateral Ratio (CR)\n     * @dev Formula: CR = (Collateral Value / Liability Value) × 1e18\n     *      Total BTD Equivalent = BTD Supply + stBTD converted to BTD amount\n     *      - CR = 1e18 (100%) indicates fully collateralized\n     *      - CR > 1e18 indicates over-collateralized\n     *      - CR < 1e18 indicates under-collateralized\n     *      - Returns 1e18 when position is empty\n     * @param wbtcBalance WBTC balance (8 decimals)\n     * @param wbtcPrice WBTC price (18 decimals)\n     * @param btdSupply BTD total supply (18 decimals)\n     * @param stBTDEquivalent stBTD converted to BTD amount (18 decimals)\n     * @param iusdPrice IUSD price (18 decimals)\n     * @return Collateral ratio (18 decimals, 1e18 = 100%)\n     */\n    function collateralRatio(\n        uint256 wbtcBalance,\n        uint256 wbtcPrice,\n        uint256 btdSupply,\n        uint256 stBTDEquivalent,\n        uint256 iusdPrice\n    ) internal pure returns (uint256) {\n        uint256 totalBTD = btdSupply + stBTDEquivalent;\n        if (wbtcBalance == 0 || totalBTD == 0) {\n            return Constants.PRECISION_18;\n        }\n\n        uint256 colValue = collateralValue(wbtcBalance, wbtcPrice);\n        uint256 liabValue = liabilityValue(btdSupply, stBTDEquivalent, iusdPrice);\n        require(colValue >= Constants.MIN_USD_VALUE, \"Collateral value too small\");\n        require(liabValue >= Constants.MIN_USD_VALUE, \"Liability value too small\");\n        return Math.mulDiv(colValue, Constants.PRECISION_18, liabValue);\n    }\n\n    /**\n     * @notice Calculate maximum redeemable USD value\n     * @dev Formula: Max Redeemable = max(Collateral Value - Liability Value, 0)\n     *      - Only has redemption capacity when over-collateralized\n     *      - Returns 0 when under-collateralized\n     * @param collateralValue_ Collateral USD value (18 decimals)\n     * @param liabilityValue_ Liability USD value (18 decimals)\n     * @return Maximum redeemable USD value (18 decimals)\n     */\n    function maxRedeemableUSD(uint256 collateralValue_, uint256 liabilityValue_) internal pure returns (uint256) {\n        return collateralValue_ > liabilityValue_ ? collateralValue_ - liabilityValue_ : 0;\n    }\n\n    /**\n     * @notice Calculate maximum redeemable BTD amount\n     * @dev Formula: Max Redeemable BTD = (Max Redeemable USD × 1e18) / IUSD Price\n     *      - First calculate USD value redemption capacity\n     *      - Then convert to BTD amount\n     * @param collateralValue_ Collateral USD value (18 decimals)\n     * @param liabilityValue_ Liability USD value (18 decimals)\n     * @param iusdPrice IUSD price (18 decimals)\n     * @return Maximum redeemable BTD amount (18 decimals)\n     */\n    function maxRedeemableBTD(\n        uint256 collateralValue_,\n        uint256 liabilityValue_,\n        uint256 iusdPrice\n    ) internal pure returns (uint256) {\n        uint256 usd = maxRedeemableUSD(collateralValue_, liabilityValue_);\n        if (usd == 0 || iusdPrice == 0) {\n            return 0;\n        }\n        return Math.mulDiv(usd, Constants.PRECISION_18, iusdPrice);\n    }\n}\n"
      },
      "project/contracts/libraries/Constants.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title Constants - BRS System Global Constants Library\n * @notice Centralized management of system-level immutable constants\n * @dev Uses library + internal constant to ensure compile-time inlining (zero gas overhead)\n *\n * Key features:\n * - internal constant is inlined by the compiler into contracts that use it\n * - Gas cost = 16 gas (same as local constant)\n * - Unified management, single source of truth\n * - Type-safe, compile-time checking\n */\nlibrary Constants {\n    // ============ Precision Constants ============\n\n    /// @notice 18 decimals precision (standard ERC20, USD prices)\n    uint256 internal constant PRECISION_18 = 1e18;\n\n    /// @notice 8 decimals precision (BTC)\n    uint256 internal constant PRECISION_8 = 1e8;\n\n    /// @notice 6 decimals precision (USDC/USDT)\n    uint256 internal constant PRECISION_6 = 1e6;\n\n    // ============ Precision Conversion Scale Constants ============\n\n    /// @notice WBTC (8 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-8) = 1e10, used for explicit precision conversion, avoiding runtime EXP calculation\n    uint256 internal constant SCALE_WBTC_TO_NORM = 1e10;\n\n    /// @notice USDC (6 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-6) = 1e12, used for explicit precision conversion\n    uint256 internal constant SCALE_USDC_TO_NORM = 1e12;\n\n    /// @notice USDT (6 decimals) to normalized (18 decimals) scale factor\n    /// @dev 10^(18-6) = 1e12, used for explicit precision conversion (same as USDC)\n    uint256 internal constant SCALE_USDT_TO_NORM = 1e12;\n\n    /// @notice Normalized (18 decimals) to WBTC (8 decimals) scale factor\n    /// @dev 1e8, used for output precision conversion\n    uint256 internal constant SCALE_NORM_TO_WBTC = 1e8;\n\n    /// @notice Normalized (18 decimals) to USDC (6 decimals) scale factor\n    /// @dev 1e6, used for output precision conversion\n    uint256 internal constant SCALE_NORM_TO_USDC = 1e6;\n\n    /// @notice Normalized (18 decimals) to USDT (6 decimals) scale factor\n    /// @dev 1e6, used for output precision conversion (same as USDC)\n    uint256 internal constant SCALE_NORM_TO_USDT = 1e6;\n\n    // ============ Input Parameter Safety Limits ============\n\n    /// @notice Maximum input parameter value (overflow prevention)\n    /// @dev 1e33, two such values multiplied equals 1e66 < type(uint256).max (1.15e77)\n    /// With this design, most multiplication operations don't need safeMulDiv\n    uint256 internal constant MAX_INPUT_AMOUNT = 1e33;\n\n    // ============ Minimum Operation Amount Constants ============\n\n    /// @notice Minimum BTC operation amount per transaction (8 decimals)\n    /// @dev 1 satoshi, prevents dust attacks\n    uint256 internal constant MIN_BTC_AMOUNT = 1;\n\n    /// @notice Minimum ETH operation amount per transaction (18 decimals)\n    /// @dev 1e-8 ETH = 1e10 wei (0.00000001 ETH)\n    uint256 internal constant MIN_ETH_AMOUNT = 1e10;\n\n        /// @notice Minimum USD value for operations (18 decimals)\n    /// @dev Used in Minter, Treasury, and other scenarios involving USD value conversion\n    /// $0.001 USD, prevents dust attacks and precision loss\n    ///\n    /// Use cases:\n    /// - Minter.mintBTD(): Check mint USD value >= $0.001\n    /// - Minter.redeemBTD(): Check redeem USD value >= $0.001\n    /// - Treasury.buyback(): Check buyback USD value >= $0.001\n    uint256 internal constant MIN_USD_VALUE = 1e15;\n\n    /// @notice Minimum operation amount for 6-decimal stablecoins\n    /// @dev 0.001 USDC/USDT = 1000 units (6 decimals), prevents dust attacks\n    /// Applicable to: USDC, USDT\n    uint256 internal constant MIN_STABLECOIN_6_AMOUNT = 1000;\n\n    /// @notice Minimum operation amount for 18-decimal stablecoins\n    /// @dev 0.001 tokens = 1e15 (18 decimals), prevents dust attacks\n    /// Applicable to: BTD, BTB, stBTD, stBTB\n    ///\n    /// Use cases:\n    /// - InterestPool.stake(): Minimum stake amount for BTD/BTB\n    /// - StakingRouter: Minimum stake amount for stBTD/stBTB\n    uint256 internal constant MIN_STABLECOIN_18_AMOUNT = 1e15;\n\n    // ============ Maximum Single Operation Limits (Prevents Hacker Attacks and Overflow) ============\n\n    /// @notice Maximum WBTC amount per single operation\n    /// @dev 10,000 BTC (8 decimals = 10000 * 1e8)\n    /// Prevents hacker attacks and integer overflow, applies to all WBTC transfer/mint/redeem operations\n    uint256 internal constant MAX_WBTC_AMOUNT = 10_000 * 1e8;\n\n    /// @notice Maximum ETH amount per single operation\n    /// @dev 100,000 ETH (18 decimals = 100000 * 1e18)\n    /// Prevents hacker attacks and integer overflow\n    uint256 internal constant MAX_ETH_AMOUNT = 100_000 * 1e18;\n\n    /// @notice Maximum 6-decimal stablecoin amount per single operation\n    /// @dev 1 billion USDC/USDT (6 decimals = 1000000000 * 1e6)\n    /// Prevents hacker attacks and integer overflow\n    /// Applicable to: USDC, USDT\n    uint256 internal constant MAX_STABLECOIN_6_AMOUNT = 1_000_000_000 * 1e6;\n\n    /// @notice Maximum 18-decimal stablecoin amount per single operation\n    /// @dev 1 billion BTD/BTB/stBTD/stBTB (18 decimals = 1000000000 * 1e18)\n    /// Prevents hacker attacks and integer overflow\n    /// Applicable to: BTD, BTB, stBTD, stBTB and other 18-decimal stablecoins\n    uint256 internal constant MAX_STABLECOIN_18_AMOUNT = 1_000_000_000 * 1e18;\n\n    /// @notice Maximum USD value per single operation\n    /// @dev Equivalent to 1 billion USD (18 decimals = 1000000000 * 1e18)\n    /// Prevents hacker attacks and integer overflow, applies to all USD value calculations\n    uint256 internal constant MAX_USD_VALUE = 1_000_000_000 * 1e18;\n\n    /// @notice Percentage base (100%)\n    uint256 internal constant PERCENT_BASE = 100;\n\n    /// @notice Basis points base (10000 = 100.00%)\n    uint256 internal constant BPS_BASE = 10000;\n\n    // ============ Time Constants ============\n\n    /// @notice Seconds per year\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n    /// @notice Seconds per day\n    uint256 internal constant SECONDS_PER_DAY = 1 days;\n\n    /// @notice Seconds per week\n    uint256 internal constant SECONDS_PER_WEEK = 7 days;\n\n    /// @notice BTC halving cycle (4 years)\n    uint256 internal constant ERA_PERIOD = 4 * 365 days;\n\n    // ============ Inflation Parameter Constants ============\n\n    /// @notice Fixed annual inflation rate - 2%\n    /// @dev Fixed inflation target specified in whitepaper, used for IUSD (Ideal USD) calculation\n    /// 2% = 0.02 = 2e16 (18 decimals)\n    uint256 internal constant ANNUAL_INFLATION_RATE = 2e16;\n\n    /// @notice Monthly growth factor - (1.02)^(1/12)\n    /// @dev Calculated from 2% annual inflation\n    /// Formula: (1 + 0.02)^(1/12) = 1.001651581301920174\n    /// Calculated off-chain with high precision and stored with 18 decimals\n    uint256 internal constant MONTHLY_GROWTH_FACTOR = 1001651581301920174;\n\n    // ============ Supply Constants ============\n\n    /// @notice BRS maximum supply (2.1 billion, tribute to BTC's 21 million)\n    /// @dev Maximum supply of BRS tokens, the only definition in the system\n    uint256 internal constant BRS_MAX_SUPPLY = 2_100_000_000e18;\n}\n"
      },
      "project/contracts/libraries/FeedValidation.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../interfaces/IAggregatorV3.sol\";\nimport \"./OracleMath.sol\";\n\n/**\n * @title FeedValidation - Oracle Data Validation Library\n * @notice Encapsulates Chainlink oracle data reading and validation logic\n * @dev Provides standardized price data reading interface with automatic precision conversion\n */\nlibrary FeedValidation {\n    /**\n     * @notice Read and validate Chainlink oracle price data\n     * @dev Execution flow:\n     *      1. Verify oracle address is non-zero\n     *      2. Read oracle precision (decimals)\n     *      3. Call latestRoundData to get latest price\n     *      4. Verify price is positive\n     *      5. Normalize price to 18 decimals\n     *\n     *      Security checks:\n     *      - Oracle address must be non-zero\n     *      - Returned price must be greater than 0 (prevents negative or zero prices)\n     *\n     *      Precision conversion:\n     *      - BTC/USD: 8 decimals -> 18 decimals\n     *      - ETH/USD: 18 decimals -> 18 decimals (unchanged)\n     *      - Others: Automatically converted based on decimals\n     *\n     * @param feedAddress Chainlink oracle contract address\n     * @return Normalized price (18 decimals)\n     */\n    function readAggregator(address feedAddress) internal view returns (uint256) {\n        require(feedAddress != address(0), \"Feed not set\");\n        IAggregatorV3 feed = IAggregatorV3(feedAddress);\n        uint8 decimals = feed.decimals();\n        (, int256 answer, , , ) = feed.latestRoundData();\n        require(answer > 0, \"Invalid feed price\");\n        return OracleMath.normalizeAmount(uint256(answer), decimals);\n    }\n}\n"
      },
      "project/contracts/libraries/InterestMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Constants.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title InterestMath - Interest Accumulation and Reward Distribution Calculation Library\n * @notice Pure function library encapsulating all interest accumulation and reward distribution calculations\n * @dev Provides mathematical calculation support for interest pools, staking rewards, and similar scenarios\n */\nlibrary InterestMath {\n\n\n    /**\n     * @notice Calculate pending rewards to be claimed\n     * @dev Formula: Pending Rewards = (Staked Amount × Accumulated Interest Per Share) / 1e18 - Reward Debt\n     *      Uses debt mechanism to prevent duplicate claims\n     * @param amount Staked amount (18 decimals)\n     * @param accInterestPerShare Accumulated interest per share (18 decimals)\n     * @param rewardDebt Reward debt (18 decimals)\n     * @return Pending reward amount (18 decimals)\n     */\n    function pendingReward(uint256 amount, uint256 accInterestPerShare, uint256 rewardDebt) internal pure returns (uint256) {\n        if (amount == 0 || accInterestPerShare == 0) {\n            return 0;\n        }\n        uint256 accumulated = Math.mulDiv(amount, accInterestPerShare, Constants.PRECISION_18);\n        return accumulated > rewardDebt ? accumulated - rewardDebt : 0;\n    }\n\n    /**\n     * @notice Calculate interest per share delta over a time period\n     * @dev Formula: delta = (Annual Rate × Time) / (10000 × 365 days)\n     *      - Annual rate is expressed in basis points (1% = 100 bps)\n     *      - Time is in seconds\n     *      - Returns delta value with 18 decimals\n     * @param annualRateBps Annual rate (basis points, 100 = 1%)\n     * @param timeElapsed Elapsed time (seconds)\n     * @return Interest per share delta (18 decimals)\n     */\n    function interestPerShareDelta(uint256 annualRateBps, uint256 timeElapsed) internal pure returns (uint256) {\n        if (annualRateBps == 0 || timeElapsed == 0) {\n            return 0;\n        }\n        uint256 scaled = Math.mulDiv(annualRateBps, Constants.PRECISION_18, 1);\n        scaled = Math.mulDiv(scaled, timeElapsed, 1);\n        uint256 denominator = Constants.BPS_BASE * Constants.SECONDS_PER_YEAR;\n        return Math.mulDiv(scaled, 1, denominator);\n    }\n\n    /**\n     * @notice Calculate reward debt value\n     * @dev Formula: Debt = (Staked Amount × Accumulated Interest Per Share) / 1e18\n     *      Used to record initial debt when staking, preventing claims of historical rewards\n     * @param amount Staked amount (18 decimals)\n     * @param accInterestPerShare Accumulated interest per share (18 decimals)\n     * @return Reward debt value (18 decimals)\n     */\n    function rewardDebtValue(uint256 amount, uint256 accInterestPerShare) internal pure returns (uint256) {\n        if (amount == 0 || accInterestPerShare == 0) {\n            return 0;\n        }\n        return Math.mulDiv(amount, accInterestPerShare, Constants.PRECISION_18);\n    }\n\n    /**\n     * @notice Calculate fee amount\n     * @dev Formula: Fee = (Amount × Fee Basis Points) / 10000\n     *      - Fee rate is expressed in basis points (100 bps = 1%)\n     * @param amount Original amount (any precision)\n     * @param feeBps Fee basis points (100 = 1%)\n     * @return Fee amount (same precision as input)\n     */\n    function feeAmount(uint256 amount, uint256 feeBps) internal pure returns (uint256) {\n        if (amount == 0 || feeBps == 0) {\n            return 0;\n        }\n        return Math.mulDiv(amount, feeBps, Constants.BPS_BASE);\n    }\n\n    /**\n     * @notice Split withdrawal amount into interest and principal proportionally\n     * @dev Formula:\n     *      Interest Portion = (Withdrawal Amount × Pending Interest) / Total Available\n     *      Principal Portion = Withdrawal Amount - Interest Portion\n     *      Interest is used first, shortfall is covered by principal\n     * @param amount Withdrawal amount (18 decimals)\n     * @param pendingInterest Pending interest (18 decimals)\n     * @param totalAvailable Total available amount (18 decimals)\n     * @return interestShare Interest portion (18 decimals)\n     * @return principalShare Principal portion (18 decimals)\n     */\n    function splitWithdrawal(uint256 amount, uint256 pendingInterest, uint256 totalAvailable) internal pure returns (uint256 interestShare, uint256 principalShare) {\n        if (amount == 0) {\n            return (0, 0);\n        }\n        if (totalAvailable == 0 || pendingInterest == 0) {\n            return (0, amount);\n        }\n        interestShare = Math.mulDiv(amount, pendingInterest, totalAvailable);\n        if (interestShare > amount) {\n            interestShare = amount;\n        }\n        principalShare = amount - interestShare;\n    }\n\n    /**\n     * @notice Calculate total assets including accrued interest\n     * @dev Formula: Total Assets = Principal + (Principal × Interest Delta)\n     *      Interest Delta = (Annual Rate × Elapsed Time) / (10000 × 365 days)\n     *      Used for real-time queries of total assets including unsettled interest\n     * @param principal Principal amount (18 decimals)\n     * @param annualRateBps Annual rate (basis points)\n     * @param lastAccrual Last settlement time (Unix timestamp)\n     * @param currentTimestamp Current time (Unix timestamp)\n     * @return Total assets (18 decimals)\n     */\n    function totalAssetsWithAccrued(\n        uint256 principal,\n        uint256 annualRateBps,\n        uint256 lastAccrual,\n        uint256 currentTimestamp\n    ) internal pure returns (uint256) {\n        if (principal == 0) {\n            return 0;\n        }\n        if (currentTimestamp <= lastAccrual || annualRateBps == 0) {\n            return principal;\n        }\n        uint256 elapsed = currentTimestamp - lastAccrual;\n        uint256 delta = interestPerShareDelta(annualRateBps, elapsed);\n        if (delta == 0) {\n            return principal;\n        }\n        uint256 interest = Math.mulDiv(principal, delta, Constants.PRECISION_18);\n        return principal + interest;\n    }\n\n    /**\n     * @notice Calculate price change percentage (basis points)\n     * @dev Formula: Change Rate = ((Current Price - Previous Price) / Previous Price) × 10000\n     *      - Returns positive value for price increase\n     *      - Returns negative value for price decrease\n     *      - Returns 0 for unchanged price\n     * @param previousPrice Previous price (18 decimals)\n     * @param currentPrice Current price (18 decimals)\n     * @return Price change rate (basis points, 100 = 1%)\n     */\n    function priceChangeBps(uint256 previousPrice, uint256 currentPrice) internal pure returns (int256) {\n        if (previousPrice == 0 || currentPrice == previousPrice) {\n            return 0;\n        }\n        if (currentPrice > previousPrice) {\n            uint256 delta = Math.mulDiv(currentPrice - previousPrice, Constants.BPS_BASE, previousPrice);\n            return int256(delta);\n        }\n        uint256 negDelta = Math.mulDiv(previousPrice - currentPrice, Constants.BPS_BASE, previousPrice);\n        return -int256(negDelta);\n    }\n}\n"
      },
      "project/contracts/libraries/IUSDMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Constants.sol\";\n\n/**\n * @title IUSDMath - IUSD Adjustment Factor Calculation Library\n * @notice Calculate IUSD price adjustment factor based on PCE index\n * @dev Used to adjust IUSD price based on actual inflation rate, making it track real purchasing power\n */\nlibrary IUSDMath {\n    /**\n     * @notice Calculate IUSD adjustment factor\n     * @dev Core logic:\n     *      1. Calculate actual inflation multiplier = Current PCE / Previous PCE\n     *      2. Calculate adjustment factor = Actual Inflation Multiplier / Target Growth Multiplier\n     *\n     *      Formula:\n     *      - Actual Inflation Multiplier = (Current PCE × 1e18) / Previous PCE\n     *      - Adjustment Factor = (Actual Inflation Multiplier × 1e18) / Monthly Growth Factor\n     *\n     *      Adjustment factor meaning:\n     *      - factor = 1e18: Actual inflation = Target inflation, no adjustment\n     *      - factor > 1e18: Actual inflation > Target inflation, IUSD price adjusted upward\n     *      - factor < 1e18: Actual inflation < Target inflation, IUSD price adjusted downward\n     *\n     *      Example:\n     *      Assume target monthly growth rate = 0.2% (monthlyGrowthFactor = 1.002e18)\n     *      - Current PCE = 102, Previous PCE = 100\n     *      - Actual Inflation Multiplier = 102 × 1e18 / 100 = 1.02e18 (2% growth)\n     *      - Adjustment Factor = 1.02e18 × 1e18 / 1.002e18 ≈ 1.018e18\n     *      - Indicates actual inflation is higher than target, IUSD price needs 1.8% upward adjustment\n     *\n     * @param current Current PCE index (any precision, integer recommended)\n     * @param previous Previous PCE index (any precision, integer recommended)\n     * @param monthlyGrowthFactor Monthly target growth factor (18 decimals, e.g., 1.002e18 for 0.2% monthly growth)\n     * @return actualInflationMultiplier Actual inflation multiplier (18 decimals)\n     * @return factor Adjustment factor (18 decimals)\n     */\n    function adjustmentFactor(\n        uint256 current,\n        uint256 previous,\n        uint256 monthlyGrowthFactor\n    ) internal pure returns (uint256 actualInflationMultiplier, uint256 factor) {\n        require(current > 0 && previous > 0, \"Invalid PCE values\");\n        // Actual inflation multiplier = Current PCE / Previous PCE (18 decimals)\n        actualInflationMultiplier = (current * Constants.PRECISION_18) / previous;\n        // Optimization: factor = (current * 1e18 / previous) * 1e18 / monthlyGrowthFactor\n        //             = (current * 1e36) / (previous * monthlyGrowthFactor)\n        // Multiply first, divide later to avoid precision loss\n        factor = (current * Constants.PRECISION_18 * Constants.PRECISION_18) / (previous * monthlyGrowthFactor);\n    }\n}\n"
      },
      "project/contracts/libraries/MintLogic.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Constants.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title MintLogic - BTD Minting Logic Calculation Library\n * @notice Pure function library: Calculate mint-related results based on input state\n * @dev Encapsulates core calculation logic for BTD minting, including USD value conversion, fee calculation, etc.\n */\nlibrary MintLogic {\n\n\n    /**\n     * @notice Mint input parameters structure\n     * @param wbtcAmount WBTC amount (8 decimals)\n     * @param wbtcPrice WBTC price (18 decimals, unit: USD)\n     * @param iusdPrice IUSD price (18 decimals, unit: USD)\n     * @param currentBTDSupply Current BTD total supply (18 decimals)\n     * @param feeBP Fee rate (basis points, 100 = 1%)\n     */\n    struct MintInputs {\n        uint256 wbtcAmount;        // 8 decimals\n        uint256 wbtcPrice;         // 18 decimals USD\n        uint256 iusdPrice;         // 18 decimals USD\n        uint256 currentBTDSupply;  // 18 decimals\n        uint256 feeBP;             // basis points\n    }\n\n    /**\n     * @notice Mint output results structure\n     * @param usdValue Collateral USD value (18 decimals)\n     * @param btdToMint BTD amount to mint for user (after fee deduction, 18 decimals)\n     * @param fee Fee (18 decimals)\n     * @param btdGross Gross mint amount (before fee, 18 decimals)\n     * @param newLiabilityValue New liability USD value (18 decimals)\n     * @param normalizedWBTC Normalized WBTC amount (18 decimals)\n     */\n    struct MintOutputs {\n        uint256 usdValue;\n        uint256 btdToMint;         // User actually receives (after fee)\n        uint256 fee;               // Fee\n        uint256 btdGross;          // Gross mint amount (before fee)\n        uint256 newLiabilityValue;\n        uint256 normalizedWBTC;    // 18 decimals\n    }\n\n    /**\n     * @notice Evaluate mint operation, calculate all related values\n     * @dev Main flow:\n     *      1. Validate input parameter validity\n     *      2. Convert WBTC to normalized 18 decimals\n     *      3. Calculate collateral USD value\n     *      4. Calculate gross BTD amount to mint based on IUSD price (before fee)\n     *      5. Calculate fee (deducted from gross amount)\n     *      6. Calculate actual BTD user receives (after fee)\n     *      7. Calculate new liability value\n     *\n     *      Formulas:\n     *      - Normalized WBTC = WBTC Amount × 1e10\n     *      - USD Value = (Normalized WBTC × WBTC Price) / 1e18\n     *      - Gross BTD = (USD Value × 1e18) / IUSD Price\n     *      - Fee = (Gross BTD × Fee Rate) / 10000\n     *      - User Receives = Gross BTD - Fee\n     *      - New Liability Value = ((Current Supply + Gross BTD) × IUSD Price) / 1e18\n     *\n     * @param inputs Mint input parameters\n     * @return result Mint output results\n     */\n    function evaluate(MintInputs memory inputs) internal pure returns (MintOutputs memory result) {\n        require(inputs.wbtcAmount > 0, \"Invalid amount\");\n        require(inputs.wbtcPrice > 0, \"Invalid WBTC price\");\n        require(inputs.iusdPrice > 0, \"Invalid IUSD price\");\n\n        result.normalizedWBTC = inputs.wbtcAmount * Constants.SCALE_WBTC_TO_NORM;\n        result.usdValue = Math.mulDiv(result.normalizedWBTC, inputs.wbtcPrice, Constants.PRECISION_18);\n        require(result.usdValue >= Constants.MIN_USD_VALUE, \"Mint value too small\");\n\n        // Calculate gross mint amount (before fee)\n        result.btdGross = Math.mulDiv(result.usdValue, Constants.PRECISION_18, inputs.iusdPrice);\n        require(result.btdGross > 1e14, \"Mint amount too small\");\n\n        // Calculate fee\n        result.fee = Math.mulDiv(result.btdGross, inputs.feeBP, Constants.BPS_BASE);\n\n        // User actually receives = Gross - Fee\n        result.btdToMint = result.btdGross - result.fee;\n\n        // New liability based on gross mint amount (including fee)\n        uint256 newBTDSupply = inputs.currentBTDSupply + result.btdGross;\n        result.newLiabilityValue = Math.mulDiv(newBTDSupply, inputs.iusdPrice, Constants.PRECISION_18);\n        require(result.newLiabilityValue >= Constants.MIN_USD_VALUE, \"Resulting liability too small\");\n    }\n}\n"
      },
      "project/contracts/libraries/OracleMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./Constants.sol\";\n\n/**\n * @title OracleMath - Oracle Price Calculation Helper Library\n * @notice Provides price deviation checks, precision conversion, spot price calculation, and other functions\n * @dev Encapsulates commonly used oracle data processing logic to ensure price data consistency and security\n */\nlibrary OracleMath {\n\n\n    /**\n     * @notice Check if deviation between two prices is within allowed range\n     * @dev Formula: |priceA - priceB| / priceA × 10000 <= maxBps\n     *      - Uses absolute difference to avoid sign issues\n     *      - Uses priceA as the base for percentage calculation\n     *      - Optimization: Uses multiplication to avoid division, reducing precision loss\n     *\n     *      Example:\n     *      - priceA = 100, priceB = 103, maxBps = 500 (5%)\n     *      - diff = 3, diff × 10000 = 30000\n     *      - priceA × maxBps = 100 × 500 = 50000\n     *      - 30000 <= 50000, returns true (3% deviation is within 5% range)\n     *\n     * @param priceA Price A (18 decimals)\n     * @param priceB Price B (18 decimals)\n     * @param maxBps Maximum allowed deviation (basis points, 500 = 5%)\n     * @return Whether deviation is within range\n     */\n    function deviationWithin(uint256 priceA, uint256 priceB, uint256 maxBps) internal pure returns (bool) {\n        if (priceA == 0 || priceB == 0) {\n            return false;\n        }\n        uint256 diff = priceA > priceB ? priceA - priceB : priceB - priceA;\n        return diff * Constants.BPS_BASE <= priceA * maxBps;\n    }\n\n    /**\n     * @notice Calculate the inverse of a price\n     * @dev Formula: Inverse Price = 1e36 / Original Price\n     *      - Uses 1e36 to maintain 18 decimals: (1e18 × 1e18) / price = 1e18\n     *      - Use case: Token A/B price -> Token B/A price\n     *\n     *      Example:\n     *      - ETH/USD = 2000e18 -> USD/ETH = 1e36 / 2000e18 = 0.0005e18\n     *\n     * @param price Original price (18 decimals)\n     * @return Inverse price (18 decimals)\n     */\n    function inversePrice(uint256 price) internal pure returns (uint256) {\n        require(price > 0, \"Oracle: zero price\");\n        return Math.mulDiv(1e36, 1, price);\n    }\n\n    /**\n     * @notice Normalize any precision amount to 18 decimals\n     * @dev Conversion rules:\n     *      - decimals = 18: Unchanged\n     *      - decimals < 18: Multiply by 10^(18-decimals)\n     *      - decimals > 18: Divide by 10^(decimals-18)\n     *\n     *      Common conversions:\n     *      - USDC (6 decimals) -> Normalized: × 1e12\n     *      - WBTC (8 decimals) -> Normalized: × 1e10\n     *      - DAI (18 decimals) -> Normalized: Unchanged\n     *\n     * @param amount Original amount\n     * @param decimals Original decimals\n     * @return Normalized amount (18 decimals)\n     */\n    function normalizeAmount(uint256 amount, uint8 decimals) internal pure returns (uint256) {\n        if (decimals == 18) return amount;\n        if (decimals > 18) {\n            return amount / (10 ** (decimals - 18));\n        }\n        return amount * (10 ** (18 - decimals));\n    }\n\n    /**\n     * @notice Calculate spot price from liquidity pool reserves\n     * @dev Formula: Price = (Quote Token Reserve × 1e18) / Base Token Reserve\n     *      - Automatically handles precision conversion, normalizing both tokens to 18 decimals\n     *      - Returns \"how much quote token per unit of base token\"\n     *\n     *      Example (USDC/WBTC pool):\n     *      - reserveBase (WBTC) = 10 × 1e8 = 1000000000 (8 decimals)\n     *      - reserveQuote (USDC) = 650000 × 1e6 = 650000000000 (6 decimals)\n     *      - baseNorm = 10 × 1e18 (normalized)\n     *      - quoteNorm = 650000 × 1e18 (normalized)\n     *      - Price = 650000 × 1e18 / 10 = 65000e18 (each BTC is worth 65000 USDC)\n     *\n     * @param reserveBase Base token reserve\n     * @param reserveQuote Quote token reserve\n     * @param baseDecimals Base token decimals\n     * @param quoteDecimals Quote token decimals\n     * @return Spot price (18 decimals, quote/base)\n     */\n    function spotPrice(\n        uint256 reserveBase,\n        uint256 reserveQuote,\n        uint8 baseDecimals,\n        uint8 quoteDecimals\n    ) internal pure returns (uint256) {\n        require(reserveBase > 0, \"Oracle: zero reserve\");\n        uint256 baseNorm = normalizeAmount(reserveBase, baseDecimals);\n        uint256 quoteNorm = normalizeAmount(reserveQuote, quoteDecimals);\n        return Math.mulDiv(quoteNorm, 1e18, baseNorm);\n    }\n}\n"
      },
      "project/contracts/libraries/PriceBlend.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./OracleMath.sol\";\n\n/**\n * @title PriceBlend - Price Blending and Deviation Validation Library\n * @notice Provides median calculation and deviation verification for multiple price sources\n * @dev Used for oracle price aggregation and anomaly detection\n */\nlibrary PriceBlend {\n    /**\n     * @notice Calculate median of three prices\n     * @dev Uses sorting network algorithm:\n     *      1. Compare a and b, swap to make a <= b\n     *      2. Compare b and c, swap to make b <= c\n     *      3. Compare a and b again, swap to make a <= b\n     *      Final order: a <= b <= c, median is b\n     *\n     *      Advantages:\n     *      - Fixed 3 comparisons, no loops, low gas cost\n     *      - Resistant to extreme values (more robust than average)\n     *\n     *      Use cases:\n     *      - Multi-oracle price aggregation (Chainlink + Uniswap + Curve)\n     *      - Anomalous price filtering\n     *\n     *      Examples:\n     *      median3(100, 200, 150) = 150\n     *      median3(100, 200, 1000) = 200 (filters out anomaly 1000)\n     *\n     * @param a Price 1 (18 decimals)\n     * @param b Price 2 (18 decimals)\n     * @param c Price 3 (18 decimals)\n     * @return Median price (18 decimals)\n     */\n    function median3(uint256 a, uint256 b, uint256 c) internal pure returns (uint256) {\n        if (a > b) (a, b) = (b, a);\n        if (b > c) (b, c) = (c, b);\n        if (a > b) (a, b) = (b, a);\n        return b;\n    }\n\n    /**\n     * @notice Validate that spot price deviation from reference price is within allowed range\n     * @dev Use cases:\n     *      - Validate consistency between AMM spot price and Chainlink oracle price\n     *      - Prevent price manipulation attacks\n     *      - Ensure reliability of multi-source prices\n     *\n     *      Security mechanism:\n     *      Transaction will revert with error if deviation is too large\n     *\n     *      Example:\n     *      - spot = 65000e18, ref = 64000e18, maxBps = 200 (2%)\n     *      - Deviation = 1000 / 64000 ≈ 1.56%\n     *      - 1.56% < 2%, validation passes\n     *\n     * @param spot Spot price (18 decimals)\n     * @param ref Reference price (18 decimals)\n     * @param maxBps Maximum allowed deviation (basis points, 200 = 2%)\n     */\n    function validateSpotAgainstRef(uint256 spot, uint256 ref, uint256 maxBps) internal pure {\n        require(OracleMath.deviationWithin(spot, ref, maxBps), \"Price deviation too large\");\n    }\n\n    /**\n     * @notice Multi-source price blending: Calculate median and validate all prices are within allowed deviation\n     * @dev Complete multi-source price aggregation flow:\n     *      1. Sort all prices\n     *      2. Calculate median\n     *      3. Validate all prices deviate from median by <= maxBps\n     *      4. If any price deviates too much, the entire call fails\n     *\n     *      Use cases:\n     *      - Aggregation of 5 or more oracle sources\n     *      - Scenarios requiring strict validation of all source data consistency\n     *      - Preventing single source anomaly from affecting final price\n     *\n     *      Algorithm:\n     *      - Uses insertion sort (gas optimized for small arrays)\n     *      - Median takes middle value (odd) or average of two middle values (even)\n     *      - Comprehensive deviation check\n     *\n     *      Example:\n     *      prices = [100e18, 102e18, 101e18, 99e18, 103e18]\n     *      maxBps = 300 (3%)\n     *      After sorting: [99, 100, 101, 102, 103]\n     *      Median: 101\n     *      Validation: All prices deviate from 101 by <= 3% ✓\n     *      Returns: 101e18\n     *\n     * @param prices Price array (18 decimals), at least 2 elements\n     * @param maxBps Maximum allowed deviation (basis points, e.g., 300=3%)\n     * @return Median price (18 decimals)\n     */\n    function blendMultiSource(\n        uint256[] memory prices,\n        uint256 maxBps\n    ) internal pure returns (uint256) {\n        uint256 len = prices.length;\n        require(len >= 2, \"Need at least 2 prices\");\n\n        // Insertion sort (gas optimized for small arrays of 5-10 elements)\n        for (uint256 i = 1; i < len; i++) {\n            uint256 key = prices[i];\n            uint256 j = i;\n            while (j > 0 && prices[j - 1] > key) {\n                prices[j] = prices[j - 1];\n                j--;\n            }\n            prices[j] = key;\n        }\n\n        // Calculate median\n        uint256 median;\n        if (len % 2 == 1) {\n            // Odd: Take middle value\n            median = prices[len / 2];\n        } else {\n            // Even: Take average of two middle values\n            uint256 mid1 = prices[len / 2 - 1];\n            uint256 mid2 = prices[len / 2];\n            median = (mid1 + mid2) / 2;\n        }\n\n        // Validate all prices deviate from median within allowed range\n        for (uint256 i = 0; i < len; i++) {\n            require(\n                OracleMath.deviationWithin(prices[i], median, maxBps),\n                \"Price source deviation too large\"\n            );\n        }\n\n        return median;\n    }\n\n    /**\n     * @notice Validate that all prices are within allowed deviation from each other\n     * @dev More strict validation: Checks deviation between any two prices, not just from median\n     *\n     *      Use cases:\n     *      - Extremely high security requirement scenarios\n     *      - Need to ensure high consistency across all source data\n     *      - Used for early warning and anomaly detection\n     *\n     *      Algorithm:\n     *      - O(n^2) complexity, only suitable for small number of price sources (<=5)\n     *      - Checks all price pairs\n     *\n     *      Example:\n     *      prices = [100e18, 101e18, 102e18]\n     *      maxBps = 200 (2%)\n     *      Checks: |100-101|/100≈1%, |100-102|/100=2%, |101-102|/101≈1%\n     *      Result: All deviations <= 2% ✓\n     *\n     * @param prices Price array (18 decimals), at least 2 elements\n     * @param maxBps Maximum allowed deviation (basis points, e.g., 200=2%)\n     * @return Whether all prices are within allowed deviation\n     */\n    function validateAllWithinBounds(\n        uint256[] memory prices,\n        uint256 maxBps\n    ) internal pure returns (bool) {\n        uint256 len = prices.length;\n        require(len >= 2, \"Need at least 2 prices\");\n\n        // Check all price pairs\n        for (uint256 i = 0; i < len; i++) {\n            for (uint256 j = i + 1; j < len; j++) {\n                if (!OracleMath.deviationWithin(prices[i], prices[j], maxBps)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n"
      },
      "project/contracts/libraries/RedeemLogic.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./Constants.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title RedeemLogic - BTD Redemption Logic Calculation Library\n * @notice Pure function library: Responsible for amount calculations in BTD redemption flow\n * @dev Implements dual-token redemption mechanism: Returns WBTC when over-collateralized, returns WBTC+BTB+BRS combination when under-collateralized\n */\nlibrary RedeemLogic {\n\n\n    /**\n     * @notice Redemption input parameters structure\n     * @param btdAmount BTD amount to redeem (18 decimals)\n     * @param wbtcPrice WBTC price (18 decimals, unit: USD)\n     * @param iusdPrice IUSD price (18 decimals, unit: USD)\n     * @param cr Collateral ratio (18 decimals, 1e18 = 100%)\n     * @param btdPrice BTD price (18 decimals, unit: USD)\n     * @param btbPrice BTB price (18 decimals, unit: USD)\n     * @param brsPrice BRS price (18 decimals, unit: USD)\n     * @param minBTBPriceInBTD BTB minimum price relative to BTD (18 decimals)\n     * @param redeemFeeBP Redemption fee rate (basis points, e.g., 50=0.5%)\n     */\n    struct RedeemInputs {\n        uint256 btdAmount;\n        uint256 wbtcPrice;\n        uint256 iusdPrice;\n        uint256 cr;                  // collateral ratio 1e18\n        uint256 btdPrice;\n        uint256 btbPrice;\n        uint256 brsPrice;\n        uint256 minBTBPriceInBTD;    // 18 decimals\n        uint256 redeemFeeBP;         // basis points\n    }\n\n    /**\n     * @notice Redemption output results structure\n     * @param wbtcOutNormalized WBTC amount to return (18 decimals normalized)\n     * @param btbOut BTB amount to return (18 decimals)\n     * @param brsOut BRS amount to return (18 decimals)\n     * @param fee Redemption fee (BTD, 18 decimals)\n     */\n    struct RedeemOutputs {\n        uint256 wbtcOutNormalized;   // 18 decimals\n        uint256 btbOut;\n        uint256 brsOut;\n        uint256 fee;                 // redeem fee in BTD\n    }\n\n    /**\n     * @notice Evaluate redemption operation, calculate amounts of assets to return\n     * @dev Redemption logic is divided into two cases:\n     *\n     *      Fee handling:\n     *      - Fee = BTD Amount × Redemption Fee Rate\n     *      - Effective Redemption Amount = BTD Amount - Fee\n     *      - All asset returns are calculated based on effective redemption amount\n     *\n     *      Case 1: CR >= 100% (Over-collateralized)\n     *      - Return equivalent WBTC\n     *      - Formula: WBTC = (Effective Redemption Amount × IUSD Price / WBTC Price)\n     *\n     *      Case 2: CR < 100% (Under-collateralized)\n     *      - WBTC Portion = Effective Redemption Value × CR\n     *      - Loss Portion = Effective Redemption Value × (1 - CR)\n     *\n     *      Loss Compensation Mechanism:\n     *      a) If BTB Price >= Minimum Price: Compensate entirely with BTB\n     *         BTB Amount = Loss Value / BTB Price\n     *\n     *      b) If BTB Price < Minimum Price: Compensate with BTB + BRS combination\n     *         BTB Amount = Loss Value / Minimum Price (calculated at minimum price)\n     *         Extra Loss = Loss Value × (Minimum Price - BTB Price) / Minimum Price\n     *         BRS Amount = Extra Loss / BRS Price\n     *\n     * @param inputs Redemption input parameters\n     * @return result Redemption output results\n     */\n    function evaluate(RedeemInputs memory inputs) internal pure returns (RedeemOutputs memory result) {\n        require(inputs.btdAmount > 0, \"Invalid amount\");\n        require(inputs.wbtcPrice > 0 && inputs.iusdPrice > 0, \"Invalid price\");\n\n        // Calculate fee (deducted from user)\n        result.fee = Math.mulDiv(inputs.btdAmount, inputs.redeemFeeBP, Constants.BPS_BASE);\n\n        // Effective redemption amount = User redemption amount - Fee\n        uint256 effectiveBTDAmount = inputs.btdAmount - result.fee;\n\n        // Calculate USD value based on effective redemption amount\n        uint256 usdValue = Math.mulDiv(effectiveBTDAmount, inputs.iusdPrice, Constants.PRECISION_18);\n        require(usdValue >= Constants.MIN_USD_VALUE, \"Redeem value too small\");\n\n        if (inputs.cr >= Constants.PRECISION_18) {\n            result.wbtcOutNormalized = Math.mulDiv(\n                usdValue,\n                Constants.PRECISION_18,\n                inputs.wbtcPrice\n            );\n            return result;\n        }\n\n        require(\n            inputs.minBTBPriceInBTD > 0 &&\n            inputs.btdPrice > 0 &&\n            inputs.btbPrice > 0,\n            \"Invalid secondary price\"\n        );\n\n        uint256 wbtcValue = Math.mulDiv(usdValue, inputs.cr, Constants.PRECISION_18);\n        result.wbtcOutNormalized = Math.mulDiv(\n            wbtcValue,\n            Constants.PRECISION_18,\n            inputs.wbtcPrice\n        );\n\n        uint256 lossValue = usdValue > wbtcValue ? usdValue - wbtcValue : 0;\n        if (lossValue == 0) {\n            return result;\n        }\n\n        uint256 minPriceInUSD = Math.mulDiv(\n            inputs.minBTBPriceInBTD,\n            inputs.btdPrice,\n            Constants.PRECISION_18\n        );\n\n        if (inputs.btbPrice >= minPriceInUSD) {\n            result.btbOut = Math.mulDiv(lossValue, Constants.PRECISION_18, inputs.btbPrice);\n        } else {\n            result.btbOut = Math.mulDiv(lossValue, Constants.PRECISION_18, minPriceInUSD);\n            require(inputs.brsPrice > 0, \"Invalid BRS price\");\n            uint256 extraLoss = Math.mulDiv(\n                lossValue,\n                minPriceInUSD - inputs.btbPrice,\n                minPriceInUSD\n            );\n            result.brsOut = Math.mulDiv(extraLoss, Constants.PRECISION_18, inputs.brsPrice);\n        }\n    }\n}\n"
      },
      "project/contracts/libraries/RewardMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n/**\n * @title RewardMath - Farm Reward Distribution Calculation Library\n * @notice Pure function library for FarmingPool and similar reward distribution modules\n * @dev Provides time-based and weight-based reward calculations using 1e12 precision for accumulated rewards per share\n */\nlibrary RewardMath {\n\n\n    /// @notice Precision for accumulated rewards per share (1e12)\n    /// @dev Uses 12 decimals to avoid confusion with token's 18 decimals, reducing precision loss in division\n    uint256 internal constant ACC_PRECISION = 1e12;\n\n    /**\n     * @notice Calculate rewards a specific pool should receive over a time period\n     * @dev Formula: Pool Reward = (Reward Per Second × Pool Weight / Total Weight) × Time\n     *      - Uses weight allocation mechanism, similar to Sushi/Curve's MasterChef\n     *      - Time is in seconds\n     * @param timeElapsed Elapsed time (seconds)\n     * @param rewardPerSec Total reward per second (18 decimals)\n     * @param allocPoint Pool's weight allocation points\n     * @param totalAllocPoint Total weight points of all pools\n     * @return Reward the pool should receive (18 decimals)\n     */\n    function emissionFor(\n        uint256 timeElapsed,\n        uint256 rewardPerSec,\n        uint256 allocPoint,\n        uint256 totalAllocPoint\n    ) internal pure returns (uint256) {\n        if (timeElapsed == 0 || rewardPerSec == 0 || totalAllocPoint == 0) {\n            return 0;\n        }\n        uint256 poolRate = Math.mulDiv(rewardPerSec, allocPoint, totalAllocPoint);\n        return poolRate * timeElapsed;\n    }\n\n    /**\n     * @notice Limit reward to not exceed maximum supply\n     * @dev Formula: Actual Reward = min(Planned Reward, Max Supply - Already Minted)\n     *      Prevents over-issuance, ensuring total token supply doesn't exceed cap\n     * @param minted Already minted amount (18 decimals)\n     * @param reward Planned reward amount (18 decimals)\n     * @param maxSupply Maximum supply (18 decimals)\n     * @return Actual distributable reward (18 decimals)\n     */\n    function clampToMax(uint256 minted, uint256 reward, uint256 maxSupply) internal pure returns (uint256) {\n        if (reward == 0 || minted >= maxSupply) {\n            return 0;\n        }\n        uint256 remaining = maxSupply - minted;\n        return reward > remaining ? remaining : reward;\n    }\n\n    /**\n     * @notice Update accumulated rewards per share\n     * @dev Formula: New Accumulated = Current Accumulated + (Pool Reward × 1e12) / Total Staked\n     *      - Uses 1e12 precision to improve calculation accuracy for small rewards\n     *      - Does not update when total staked is 0\n     * @param current Current accumulated rewards per share (1e12 precision)\n     * @param poolReward Pool reward for this period (18 decimals)\n     * @param totalStaked Total staked amount (18 decimals)\n     * @return Updated accumulated rewards per share (1e12 precision)\n     */\n    function accRewardPerShare(\n        uint256 current,\n        uint256 poolReward,\n        uint256 totalStaked\n    ) internal pure returns (uint256) {\n        if (poolReward == 0 || totalStaked == 0) {\n            return current;\n        }\n        return current + Math.mulDiv(poolReward, ACC_PRECISION, totalStaked);\n    }\n\n    /**\n     * @notice Calculate user's pending rewards to be claimed\n     * @dev Formula: Pending = (Staked Amount × Accumulated Per Share / 1e12) - Reward Debt\n     *      - Uses debt mechanism to prevent duplicate claims\n     *      - Returns safely claimable reward amount\n     * @param amount Staked amount (18 decimals)\n     * @param accPerShare Accumulated rewards per share (1e12 precision)\n     * @param rewardDebt Reward debt (18 decimals)\n     * @return Pending rewards (18 decimals)\n     */\n    function pending(uint256 amount, uint256 accPerShare, uint256 rewardDebt) internal pure returns (uint256) {\n        uint256 accumulated = Math.mulDiv(amount, accPerShare, ACC_PRECISION);\n        return accumulated > rewardDebt ? accumulated - rewardDebt : 0;\n    }\n\n    /**\n     * @notice Calculate reward debt value\n     * @dev Formula: Debt = (Staked Amount × Accumulated Per Share) / 1e12\n     *      - Used to record initial debt when staking\n     *      - Prevents claiming rewards from before staking\n     * @param amount Staked amount (18 decimals)\n     * @param accPerShare Accumulated rewards per share (1e12 precision)\n     * @return Reward debt value (18 decimals)\n     */\n    function rewardDebtValue(uint256 amount, uint256 accPerShare) internal pure returns (uint256) {\n        if (amount == 0 || accPerShare == 0) {\n            return 0;\n        }\n        return Math.mulDiv(amount, accPerShare, ACC_PRECISION);\n    }\n}\n"
      },
      "project/contracts/local/MockAggregatorV3.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @notice Mock Chainlink AggregatorV3Interface\ncontract MockAggregatorV3 {\n    int256 private _answer;\n    uint8 private _decimals = 8; // Default Chainlink commonly uses 8 decimals\n\n    constructor(int256 initialAnswer) {\n        _answer = initialAnswer;\n    }\n\n    function setDecimals(uint8 newDecimals) external {\n        _decimals = newDecimals;\n    }\n\n    function setAnswer(int256 newAnswer) external {\n        _answer = newAnswer;\n    }\n\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (0, _answer, 0, block.timestamp, 0);\n    }\n}\n"
      },
      "project/contracts/local/MockFunctionsRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IFunctionsRouter} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsRouter.sol\";\nimport {IFunctionsClient} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsClient.sol\";\nimport {FunctionsResponse} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsResponse.sol\";\n\n/// @notice Minimal mock router for unit testing Functions clients.\ncontract MockFunctionsRouter is IFunctionsRouter {\n    uint256 private _requestCounter;\n\n    uint64 public lastSubscriptionId;\n    bytes public lastData;\n    uint16 public lastDataVersion;\n    uint32 public lastCallbackGasLimit;\n    bytes32 public lastDonId;\n\n    mapping(bytes32 => address) public requestSenders;\n\n    function getAllowListId() external pure override returns (bytes32) {\n        return bytes32(0);\n    }\n\n    function setAllowListId(bytes32) external override {}\n\n    function getAdminFee() external pure override returns (uint72) {\n        return 0;\n    }\n\n    function sendRequest(\n        uint64 subscriptionId,\n        bytes calldata data,\n        uint16 dataVersion,\n        uint32 callbackGasLimit,\n        bytes32 donId\n    ) external override returns (bytes32 requestId) {\n        _requestCounter++;\n        requestId = bytes32(_requestCounter);\n        lastSubscriptionId = subscriptionId;\n        lastData = data;\n        lastDataVersion = dataVersion;\n        lastCallbackGasLimit = callbackGasLimit;\n        lastDonId = donId;\n        requestSenders[requestId] = msg.sender;\n    }\n\n    function sendRequestToProposed(\n        uint64,\n        bytes calldata,\n        uint16,\n        uint32,\n        bytes32\n    ) external pure override returns (bytes32) {\n        return bytes32(0);\n    }\n\n    function fulfill(\n        bytes memory,\n        bytes memory,\n        uint96,\n        uint96,\n        address,\n        FunctionsResponse.Commitment memory\n    ) external pure override returns (FunctionsResponse.FulfillResult, uint96) {\n        return (FunctionsResponse.FulfillResult.FULFILLED, 0);\n    }\n\n    function isValidCallbackGasLimit(uint64, uint32) external pure override {}\n\n    function getContractById(bytes32) external pure override returns (address) {\n        return address(0);\n    }\n\n    function getProposedContractById(bytes32) external pure override returns (address) {\n        return address(0);\n    }\n\n    function getProposedContractSet()\n        external\n        pure\n        override\n        returns (bytes32[] memory ids, address[] memory addresses)\n    {\n        ids = new bytes32[](0);\n        addresses = new address[](0);\n    }\n\n    function proposeContractsUpdate(bytes32[] memory, address[] memory) external pure override {}\n\n    function updateContracts() external pure override {}\n\n    function pause() external pure override {}\n\n    function unpause() external pure override {}\n\n    /// @notice Helper to simulate router fulfillment in tests.\n    function fulfillRequest(\n        address client,\n        bytes32 requestId,\n        bytes memory response,\n        bytes memory err\n    ) external {\n        IFunctionsClient(client).handleOracleFulfillment(requestId, response, err);\n    }\n}\n"
      },
      "project/contracts/local/MockIUSDManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../interfaces/IIdealUSDManager.sol\";\n\ncontract MockIUSDManager is IIdealUSDManager {\n    uint256 private price;\n    uint256 private _lastUpdate;\n\n    constructor(uint256 initialPrice) {\n        price = initialPrice;\n        _lastUpdate = block.timestamp;\n    }\n\n    function getCurrentIUSD() external view override returns (uint256) {\n        return price;\n    }\n\n    function setPrice(uint256 newPrice) external {\n        price = newPrice;\n        _lastUpdate = block.timestamp;\n    }\n\n    function lastUpdateTime() external view override returns (uint256) {\n        return _lastUpdate;\n    }\n}\n"
      },
      "project/contracts/local/MockPriceOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"../interfaces/IPriceOracle.sol\";\n\n/**\n * @title MockPriceOracle - Price oracle for testing\n * @notice Allows manual price setting for test environment\n */\ncontract MockPriceOracle is IPriceOracle {\n    // Price storage (18 decimal precision)\n    uint256 public wbtcPrice;\n    uint256 public btdPrice;\n    uint256 public btbPrice;\n    uint256 public brsPrice;\n    uint256 public iusdPrice;\n\n    address public twapOracle;\n    bool public useTWAP;\n\n    // Default prices\n    constructor() {\n        wbtcPrice = 50000e18;  // $50,000\n        btdPrice = 1e18;       // $1.00\n        btbPrice = 1e18;       // $1.00\n        brsPrice = 1e18;       // $1.00\n        iusdPrice = 1e18;      // $1.00\n        useTWAP = false;       // TWAP disabled by default in test environment\n    }\n\n    // ============ Admin Functions ============\n\n    function setWBTCPrice(uint256 _price) external {\n        wbtcPrice = _price;\n    }\n\n    function setBTDPrice(uint256 _price) external {\n        btdPrice = _price;\n    }\n\n    function setBTBPrice(uint256 _price) external {\n        btbPrice = _price;\n    }\n\n    function setBRSPrice(uint256 _price) external {\n        brsPrice = _price;\n    }\n\n    function setIUSDPrice(uint256 _price) external {\n        iusdPrice = _price;\n    }\n\n    function setAllPrices(\n        uint256 _wbtc,\n        uint256 _btd,\n        uint256 _btb,\n        uint256 _brs,\n        uint256 _iusd\n    ) external {\n        wbtcPrice = _wbtc;\n        btdPrice = _btd;\n        btbPrice = _btb;\n        brsPrice = _brs;\n        iusdPrice = _iusd;\n    }\n\n    // ============ IPriceOracle Implementation ============\n\n    function getWBTCPrice() external view override returns (uint256) {\n        return wbtcPrice;\n    }\n\n    function getBTDPrice() external view override returns (uint256) {\n        return btdPrice;\n    }\n\n    function getBTBPrice() external view override returns (uint256) {\n        return btbPrice;\n    }\n\n    function getBRSPrice() external view override returns (uint256) {\n        return brsPrice;\n    }\n\n    function getIUSDPrice() external view override returns (uint256) {\n        return iusdPrice;\n    }\n\n    function getPrice(address token) external view override returns (uint256) {\n        // Simple mock implementation: all tokens return $1 (except WBTC)\n        // In actual tests, specific prices can be set via setXXXPrice()\n        return 1e18; // Default $1\n    }\n\n    function getPrice(address, address, address) external pure override returns (uint256) {\n        return 1e18; // Default $1\n    }\n\n    function setTWAPOracle(address _twapOracle) external override {\n        twapOracle = _twapOracle;\n        emit TWAPOracleUpdated(address(0), _twapOracle);\n    }\n\n    function setUseTWAP(bool _useTWAP) external override {\n        useTWAP = _useTWAP;\n        emit TWAPModeChanged(_useTWAP);\n    }\n\n    function isTWAPEnabled() external view override returns (bool) {\n        return useTWAP;\n    }\n\n    function getTWAPOracle() external view override returns (address) {\n        return twapOracle;\n    }\n\n    function getChainlinkBTCUSD() external view override returns (uint256) {\n        return wbtcPrice; // Mock returns the same price\n    }\n}\n"
      },
      "project/contracts/local/MockPyth.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @notice Simplified Pyth mock for local testing getPriceUnsafe\ncontract MockPyth {\n    struct Price {\n        int64 price;\n        uint64 conf;\n        int32 expo;\n        uint256 publishTime;\n    }\n\n    mapping(bytes32 => Price) private prices;\n\n    function setPrice(bytes32 id, int64 price, int32 expo) external {\n        prices[id] = Price({\n            price: price,\n            conf: 0,\n            expo: expo,\n            publishTime: block.timestamp\n        });\n    }\n\n    function getPriceUnsafe(bytes32 id) external view returns (Price memory) {\n        Price memory p = prices[id];\n        require(p.price != 0, \"Price not set\");\n        // Always return current block.timestamp to prevent staleness in local testing\n        p.publishTime = block.timestamp;\n        return p;\n    }\n}\n"
      },
      "project/contracts/local/MockRedstone.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @notice Simplified Redstone DataService mock\ncontract MockRedstone {\n    mapping(bytes32 => uint256) public values;\n\n    function setValue(bytes32 dataFeedId, uint256 price) external {\n        values[dataFeedId] = price;\n    }\n\n    function getValueForDataFeedId(bytes32 dataFeedId) external view returns (uint256) {\n        uint256 val = values[dataFeedId];\n        require(val != 0, \"Value not set\");\n        return val;\n    }\n}\n"
      },
      "project/contracts/local/MockUSDC.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.4.0 and Community Contracts commit 2d607bd\npragma solidity ^0.8.30;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract MockUSDC is ERC20, ERC20Permit {\n    constructor(address recipient) ERC20(\"Mock USDC\", \"USDC\") ERC20Permit(\"Mock USDC\") {\n        _mint(recipient, 1000000000 * 10 ** decimals());\n    }\n\n    // Override the default 18 decimals and set it to 6\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n}\n"
      },
      "project/contracts/local/MockUSDT.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\n/**\n * @title MockUSDT - USDT token for testing\n * @notice Mock USDT with mint functionality for test environment\n */\ncontract MockUSDT is ERC20, ERC20Permit {\n    constructor(address recipient) ERC20(\"Mock USDT\", \"USDT\") ERC20Permit(\"Mock USDT\") {\n        _mint(recipient, 1000000000 * 10 ** decimals());\n    }\n\n    // Override the default 18 decimals and set it to 6\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n}\n"
      },
      "project/contracts/local/MockWBTC.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.4.0\npragma solidity ^0.8.30;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract MockWBTC is ERC20, ERC20Permit {\n    constructor(address recipient) ERC20(\"Mock Wrapped BTC\", \"WBTC\") ERC20Permit(\"Mock Wrapped BTC\") {\n        // Total supply: 21 million WBTC with 8 decimals\n        _mint(recipient, 21000000 * 10 ** decimals());\n    }\n\n    // Override the default 18 decimals and set it to 8\n    function decimals() public pure override returns (uint8) {\n        return 8;\n    }\n}\n"
      },
      "project/contracts/local/MockWETH.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.4.0\npragma solidity ^0.8.30;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title MockWETH\n * @notice Mock Wrapped Ether for local testing with deposit/withdraw functionality\n * @dev Implements the core WETH interface: deposit ETH to get WETH, withdraw WETH to get ETH\n */\ncontract MockWETH is ERC20 {\n    // Events\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    constructor(address recipient) ERC20(\"Mock Wrapped Ether\", \"WETH\") {\n        // Initial supply: 120 million WETH for testing\n        _mint(recipient, 120000000 * 10 ** decimals());\n    }\n\n    // WETH uses standard 18 decimals\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @notice Deposit ETH and receive WETH\n     * @dev Payable function that mints WETH equal to msg.value\n     */\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Withdraw WETH and receive ETH\n     * @dev Burns WETH and sends ETH to caller\n     * @param wad Amount of WETH to withdraw\n     */\n    function withdraw(uint256 wad) public {\n        require(balanceOf(msg.sender) >= wad, \"Insufficient WETH balance\");\n        _burn(msg.sender, wad);\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    /**\n     * @notice Receive ETH and automatically deposit\n     * @dev Allows sending ETH directly to contract\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @notice Fallback function\n     * @dev Calls deposit when ETH is sent\n     */\n    fallback() external payable {\n        deposit();\n    }\n}\n"
      },
      "project/contracts/local/UniswapV2Pair.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title UniswapV2Pair\n * @notice Uniswap V2 core liquidity pool contract\n * @dev Implements core AMM (Automated Market Maker) functionality\n */\ncontract UniswapV2Pair is ERC20 {\n    uint112 private reserve0;           // token0 reserve\n    uint112 private reserve1;           // token1 reserve\n    uint32  private blockTimestampLast; // Last update timestamp\n\n    address public token0;\n    address public token1;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'UniswapV2: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() ERC20(\"Uniswap V2 LP\", \"UNI-V2\") {}\n\n    /**\n     * @notice Initialize token pair\n     */\n    function initialize(address _token0, address _token1) external {\n        require(token0 == address(0), 'UniswapV2: ALREADY_INITIALIZED');\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    /// @notice For local/testing only, directly write reserves (disabled in production)\n    function __setReservesForTest(uint112 _reserve0, uint112 _reserve1) external {\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n    }\n\n    /**\n     * @notice Get reserves\n     */\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    /**\n     * @notice Safe transfer\n     */\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n    }\n\n    /**\n     * @notice Update reserves\n     */\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    /**\n     * @notice Calculate square root (Newton's method)\n     */\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    /**\n     * @notice Add liquidity, mint LP tokens\n     * @dev User first transfers tokens to contract, then calls this function to mint LP\n     */\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0 - _reserve0;\n        uint amount1 = balance1 - _reserve1;\n\n        uint _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            // First liquidity addition\n            liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(1), MINIMUM_LIQUIDITY); // Permanently lock minimum liquidity to burn address\n        } else {\n            // Subsequent liquidity additions\n            liquidity = min(amount0 * _totalSupply / _reserve0, amount1 * _totalSupply / _reserve1);\n        }\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    /**\n     * @notice Remove liquidity, burn LP tokens and return underlying tokens\n     * @dev User first transfers LP tokens to contract, then calls this function to burn LP and retrieve underlying tokens\n     */\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\n        address _token0 = token0;\n        address _token1 = token1;\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf(address(this));\n\n        uint _totalSupply = totalSupply();\n        amount0 = liquidity * balance0 / _totalSupply;\n        amount1 = liquidity * balance1 / _totalSupply;\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    /**\n     * @notice Swap tokens\n     */\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata /* data */) external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        {\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n\n        {\n            // Verify K invariant (including 0.3% fee)\n            uint balance0Adjusted = balance0 * 1000 - amount0In * 3;\n            uint balance1Adjusted = balance1 * 1000 - amount1In * 3;\n            require(balance0Adjusted * balance1Adjusted >= uint(_reserve0) * uint(_reserve1) * 1000**2, 'UniswapV2: K');\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    /**\n     * @notice Force balance to match reserves\n     */\n    function skim(address to) external lock {\n        address _token0 = token0;\n        address _token1 = token1;\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)) - reserve0);\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)) - reserve1);\n    }\n\n    /**\n     * @notice Force reserves to match balance\n     */\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n\n    /**\n     * @notice Return the smaller of two numbers\n     */\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    /**\n     * @notice Set token addresses (for testing)\n     */\n    function setTokens(address _token0, address _token1) external {\n        require(token0 == address(0), 'UniswapV2: ALREADY_SET');\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    /**\n     * @notice Set reserves (for testing)\n     */\n    function setReserves(uint112 _reserve0, uint112 _reserve1) external {\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n        blockTimestampLast = uint32(block.timestamp % 2**32);\n    }\n}\n"
      },
      "project/contracts/Minter.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.4.0\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport \"./ConfigCore.sol\";\nimport \"./ConfigGov.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IMintableERC20.sol\";\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IMinter.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/MintLogic.sol\";\nimport \"./libraries/RedeemLogic.sol\";\nimport \"./libraries/CollateralMath.sol\";\n\n/**\n * @title Minter - BTD Stablecoin Minting and Redemption Contract\n * @notice Handles BTD minting and redemption business logic\n * @dev Price queries delegated to PriceOracle contract, this contract focuses on business logic\n */\ncontract Minter is ReentrancyGuard, Ownable, Pausable, IMinter {\n    using SafeERC20 for IERC20;\n\n    // ============ State Variables ============\n\n    ConfigCore public immutable core;\n    ConfigGov public gov; // Global config contract - internal to maintain storage layout\n\n    /**\n     * @notice Get ConfigCore contract address\n     * @dev ConfigCore is immutable, cannot be changed after deployment\n     * @return ConfigCore contract address\n     */\n    function configCore() external view returns (address) {\n        return address(core);\n    }\n\n    /**\n     * @notice Get ConfigGov contract address\n     * @dev ConfigGov can be updated via setConfigGov()\n     * @return ConfigGov contract address\n     */\n    function configGov() external view returns (address) {\n        return address(gov);\n    }\n\n    // ============ Rate Limiting ============\n\n    // ============ Constants ============\n\n    /// @notice ConfigGov address update event\n    /// @param oldConfigGov Old ConfigGov address\n    /// @param newConfigGov New ConfigGov address\n    event ConfigGovUpdated(address indexed oldConfigGov, address indexed newConfigGov);\n\n    // ============ Initialization ============\n\n    /**\n     * @notice Constructor\n     * @dev Initializes contract owner and Config addresses, both cannot be zero address\n     */\n    constructor(\n        address initialOwner,  // Contract owner address\n        address _core, address _gov     // Config contract addresses\n    ) Ownable(initialOwner) {\n        require(initialOwner != address(0), \"Invalid owner\");\n        require(_core != address(0), \"Invalid core\");\n        require(_gov != address(0), \"Invalid gov\");\n        core = ConfigCore(_core);\n        gov = ConfigGov(_gov);\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @notice Pause all write operations\n     * @dev Only owner can call, after pause all nonReentrant whenNotPaused functions will be blocked\n     */\n    function pause() external onlyOwner { _pause(); }\n\n    function unpause() external onlyOwner { _unpause(); }\n\n    /**\n     * @notice Upgrade governance contract\n     * @dev Only owner can call, core address ConfigCore cannot be changed\n     * @dev ConfigCore is immutable, never changeable after deployment\n     * @dev ConfigGov is upgradeable for adjusting governable parameters (fees, limits, etc.)\n     * @param newGov New ConfigGov contract address\n     */\n    function upgradeGov(address newGov) external onlyOwner {\n        require(newGov != address(0), \"Invalid gov\");\n        address oldGov = address(gov);\n        gov = ConfigGov(newGov);\n        emit ConfigGovUpdated(oldGov, newGov);\n    }\n\n    // ============ Price Queries (delegated to PriceOracle) ============\n\n    // ============ Precision Conversion Helpers ============\n\n    /**\n     * @notice Convert WBTC amount (8 decimals) to normalized amount (18 decimals)\n     * @dev Uses precomputed constant, ~8 gas (vs Math.mulDiv's 250 gas)\n     * @param wbtcAmount WBTC amount (8 decimals)\n     * @return Normalized amount (18 decimals)\n     */\n    function _wbtcToNormalized(uint256 wbtcAmount) internal pure returns (uint256) {\n        return wbtcAmount * Constants.SCALE_WBTC_TO_NORM;\n    }\n\n    /**\n     * @notice Convert normalized amount (18 decimals) back to WBTC amount (8 decimals)\n     * @dev Uses precomputed constant, ~8 gas\n     * @param normalizedAmount Normalized amount (18 decimals)\n     * @return WBTC amount (8 decimals)\n     */\n    function _wbtcFromNormalized(uint256 normalizedAmount) internal pure returns (uint256) {\n        return normalizedAmount / Constants.SCALE_WBTC_TO_NORM;\n    }\n\n\n    // ============ Max Value Limit Checks ============\n\n    /**\n     * @notice Check WBTC operation amount limits (anti-hack protection)\n     * @dev Validates WBTC amount within safe range: min 154 satoshi, max 10,000 BTC\n     * @param wbtcAmount WBTC amount (8 decimals)\n     */\n    function _checkWBTCAmount(uint256 wbtcAmount) internal pure {\n        require(wbtcAmount >= Constants.MIN_BTC_AMOUNT, \"Amount below minimum BTC\");\n        require(wbtcAmount <= Constants.MAX_WBTC_AMOUNT, \"Amount exceeds max WBTC\");\n    }\n\n    /**\n     * @notice Check BTD/BTB 18-decimal stablecoin operation amount limits (anti-hack protection)\n     * @dev Validates amount within safe range: min 0.001 token, max 1 billion tokens\n     * @param amount Stablecoin amount (18 decimals)\n     */\n    function _checkStablecoinAmount(uint256 amount) internal pure {\n        require(amount >= Constants.MIN_STABLECOIN_18_AMOUNT, \"Amount below minimum\");\n        require(amount <= Constants.MAX_STABLECOIN_18_AMOUNT, \"Amount exceeds max\");\n    }\n\n    // ============ Price Query Functions ============\n\n    /**\n     * @notice Get price oracle contract\n     * @return PriceOracle contract instance\n     */\n    function _getPriceOracle() internal view returns (IPriceOracle) {\n        address oracle = core.PRICE_ORACLE();\n        require(oracle != address(0), \"PriceOracle not set\");\n        return IPriceOracle(oracle);\n    }\n\n    /**\n     * @notice Get WBTC/USD price (internal use)\n     * @dev Queries from PriceOracle contract, price in 18-decimal USD\n     * @dev For external calls use priceOracle.getWBTCPrice() directly\n     * @return WBTC price (18-decimal USD)\n     */\n    function getWBTCPrice() internal view returns (uint256) {\n        return _getPriceOracle().getWBTCPrice();\n    }\n\n    /**\n     * @notice Get BTD/USD actual market price (internal use)\n     * @dev Queries Uniswap market price from PriceOracle contract, price in 18-decimal USD\n     * @dev For external calls use priceOracle.getBTDPrice() directly\n     * @return BTD price (18-decimal USD)\n     */\n    function getBTDPrice() internal view returns (uint256) {\n        return _getPriceOracle().getBTDPrice();\n    }\n\n    /**\n     * @notice Get BTB/USD price (internal use)\n     * @dev Queries from PriceOracle, calculated via BTB/BTD and BTD/USDC pools, price in 18-decimal USD\n     * @dev For external calls use priceOracle.getBTBPrice() directly\n     * @return BTB price (18-decimal USD)\n     */\n    function getBTBPrice() internal view returns (uint256) {\n        return _getPriceOracle().getBTBPrice();\n    }\n\n    /**\n     * @notice Get BRS/USD price (internal use)\n     * @dev Queries from PriceOracle, calculated via BRS/BTD and BTD/USDC pools, price in 18-decimal USD\n     * @dev For external calls use priceOracle.getBRSPrice() directly\n     * @return BRS price (18-decimal USD)\n     */\n    function getBRSPrice() internal view returns (uint256) {\n        return _getPriceOracle().getBRSPrice();\n    }\n\n    /**\n     * @notice Get IUSD (Ideal USD) price (internal use)\n     * @dev Queries from IdealUSDManager contract, IUSD adjusts with inflation, price in 18 decimals\n     * @dev For external calls use priceOracle.getIUSDPrice() directly\n     * @return IUSD price (18 decimals)\n     */\n    function getIUSDPrice() internal view returns (uint256) {\n        return _getPriceOracle().getIUSDPrice();\n    }\n\n    // ============ Collateral and Liabilities ============\n\n    /**\n     * @notice Get WBTC balance in Treasury contract\n     * @dev Queries actual WBTC holdings in Treasury, 8 decimals\n     * @return WBTC balance (8 decimals)\n     */\n    function totalWBTC() public view returns (uint256) {\n        (uint256 wbtcBalance, , ) = ITreasury(core.TREASURY())\n            .getBalances();\n        return wbtcBalance;\n    }\n\n    /**\n     * @notice Get BTD token total supply\n     * @dev Queries BTD contract totalSupply, 18 decimals\n     * @return BTD total supply (18 decimals)\n     */\n    function totalBTD() public view returns (uint256) {\n        return IMintableERC20(core.BTD()).totalSupply();\n    }\n\n    /**\n     * @notice Get BTD equivalent amount from stBTD\n     * @dev Uses ERC4626 totalAssets() to get total BTD locked in stBTD pool\n     * @return stBTD equivalent BTD amount (18 decimals)\n     */\n    function totalStBTDEquivalent() public view returns (uint256) {\n        address stBTD = core.ST_BTD();\n        if (stBTD == address(0)) {\n            return 0;\n        }\n        // ERC4626 totalAssets() returns underlying assets locked in pool\n        return IERC4626(stBTD).totalAssets();\n    }\n\n    /**\n     * @notice Get system Collateral Ratio\n     * @dev CR = (WBTC amount * WBTC price) / (BTD equivalent total * IUSD price), 18 decimals\n     *      BTD equivalent total = BTD supply + stBTD equivalent BTD amount\n     *      CR=100% equals 1e18, CR>100% means overcollateralized, CR<100% means undercollateralized\n     * @return Collateral ratio (18 decimals, 1e18=100%)\n     */\n    function getCollateralRatio() public view override returns (uint256) {\n        return CollateralMath.collateralRatio(\n            totalWBTC(),\n            getWBTCPrice(),\n            totalBTD(),\n            totalStBTDEquivalent(),\n            getIUSDPrice()\n        );\n    }\n\n    /**\n     * @notice Calculate BTD output amount and fee when minting (read-only preview)\n     * @dev Uses MintLogic library, does not modify state, can be used for frontend preview\n     * @param wbtcAmount WBTC amount to deposit (8 decimals)\n     * @return btdAmount BTD amount user will receive (after fee, 18 decimals)\n     * @return fee Minting fee (BTD, 18 decimals), deducted from user\n     */\n    function calculateMintAmount(uint256 wbtcAmount) external view override returns (uint256 btdAmount, uint256 fee) {\n        MintLogic.MintInputs memory inputs = MintLogic.MintInputs({\n            wbtcAmount: wbtcAmount,\n            wbtcPrice: getWBTCPrice(),\n            iusdPrice: getIUSDPrice(),\n            currentBTDSupply: totalBTD(),\n            feeBP: gov.mintFeeBP()\n        });\n        MintLogic.MintOutputs memory outputs = MintLogic.evaluate(inputs);\n        return (outputs.btdToMint, outputs.fee);\n    }\n\n    /**\n     * @notice Calculate output amount and fee when redeeming BTD (read-only preview)\n     * @dev Calculates WBTC output and redemption fee based on BTD amount and current prices\n     * @param btdAmount BTD amount to burn (18 decimals)\n     * @return wbtcAmount WBTC amount user will receive (8 decimals)\n     * @return fee Redemption fee (BTD, 18 decimals), deducted from user\n     */\n    function calculateBurnAmount(uint256 btdAmount) external view override returns (uint256 wbtcAmount, uint256 fee) {\n        uint256 wbtcPrice = getWBTCPrice();\n        uint256 iusdPrice = getIUSDPrice();\n        uint256 cr = _getCRWithPrice(wbtcPrice, iusdPrice);\n\n        RedeemLogic.RedeemInputs memory redeemInputs = RedeemLogic.RedeemInputs({\n            btdAmount: btdAmount,\n            wbtcPrice: wbtcPrice,\n            iusdPrice: iusdPrice,\n            cr: cr,\n            btdPrice: 0,\n            btbPrice: 0,\n            brsPrice: 0,\n            minBTBPriceInBTD: 0,\n            redeemFeeBP: gov.redeemFeeBP()\n        });\n\n        if (cr < Constants.PRECISION_18) {\n            redeemInputs.btdPrice = getBTDPrice();\n            redeemInputs.btbPrice = getBTBPrice();\n            redeemInputs.brsPrice = getBRSPrice();\n            redeemInputs.minBTBPriceInBTD = gov.minBTBPrice();\n        }\n\n        RedeemLogic.RedeemOutputs memory redeemOutputs = RedeemLogic.evaluate(redeemInputs);\n        wbtcAmount = _wbtcFromNormalized(redeemOutputs.wbtcOutNormalized);\n        fee = redeemOutputs.fee;\n        return (wbtcAmount, fee);\n    }\n\n    /**\n     * @notice Calculate CR with pre-fetched prices (gas optimization)\n     * @dev Avoids repeated oracle calls\n     */\n    function _getCRWithPrice(uint256 wbtcPrice, uint256 iusdPrice) private view returns (uint256) {\n        return CollateralMath.collateralRatio(\n            totalWBTC(),\n            wbtcPrice,\n            totalBTD(),\n            totalStBTDEquivalent(),\n            iusdPrice\n        );\n    }\n\n    // ============ Mint BTD ============\n\n    /**\n     * @notice Deposit WBTC to mint BTD\n     * @dev User must approve Minter first, flow: User->Minter->Treasury, mints BTD and fee\n     * @dev Security: reentrancy guard, pause protection, amount limit checks\n     * @param wbtcAmount WBTC amount to deposit (8 decimals)\n     */\n    function mintBTD(uint256 wbtcAmount) external nonReentrant whenNotPaused {\n        // Deposit limit check: BTC min/max amount\n        _checkWBTCAmount(wbtcAmount);\n\n        MintLogic.MintInputs memory inputs = MintLogic.MintInputs({\n            wbtcAmount: wbtcAmount,\n            wbtcPrice: getWBTCPrice(),\n            iusdPrice: getIUSDPrice(),\n            currentBTDSupply: totalBTD(),\n            feeBP: gov.mintFeeBP()\n        });\n        MintLogic.MintOutputs memory outputs = MintLogic.evaluate(inputs);\n\n        // Security: Minter receives WBTC first, then transfers to Treasury\n        // Step 1: User transfers WBTC to Minter (user needs to approve Minter)\n        IERC20(core.WBTC()).safeTransferFrom(msg.sender, address(this), wbtcAmount);\n\n        // Step 2: Minter approves Treasury (if not enough allowance)\n        IERC20 wbtc = IERC20(core.WBTC());\n        address treasuryAddr = core.TREASURY();\n        if (wbtc.allowance(address(this), treasuryAddr) < wbtcAmount) {\n            wbtc.forceApprove(treasuryAddr, type(uint256).max);\n        }\n\n        // Step 3: Treasury transfers from Minter\n        ITreasury(treasuryAddr).depositWBTC(wbtcAmount);\n\n        // Mint BTD: user gets net amount, fee goes to Treasury\n        IMintableERC20 btdToken = IMintableERC20(core.BTD());\n        btdToken.mint(msg.sender, outputs.btdToMint);  // User gets amount after fee\n        if (outputs.fee > 0) {\n            btdToken.mint(treasuryAddr, outputs.fee);  // Treasury gets fee\n        }\n\n        emit BTDMinted(msg.sender, wbtcAmount, outputs.btdToMint, outputs.fee);\n    }\n\n    // ============ Redeem BTD ============\n\n    /**\n     * @notice Redeem BTD for WBTC\n     * @dev CR>=100%: all WBTC; CR<100%: partial WBTC + BTB + BRS compensation\n     * @dev Security: reentrancy guard, pause protection, amount limit checks\n     * @param btdAmount BTD amount to burn (18 decimals)\n     */\n    function redeemBTD(uint256 btdAmount) external nonReentrant whenNotPaused {\n        _redeemBTD(msg.sender, btdAmount);\n    }\n\n    /**\n     * @notice Redeem BTD using EIP-2612 permit signature (no pre-approval needed)\n     * @dev User signs authorization for one-tx redemption, CR<100% gets BTB/BRS compensation\n     * @dev Security: reentrancy guard, pause protection, amount limit checks, signature validation\n     * @param btdAmount BTD amount to burn (18 decimals)\n     * @param deadline Permit signature deadline timestamp (seconds)\n     * @param v ECDSA signature parameter v (27 or 28)\n     * @param r ECDSA signature parameter r (32 bytes)\n     * @param s ECDSA signature parameter s (32 bytes)\n     */\n    function redeemBTDWithPermit(\n        uint256 btdAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        IERC20Permit(core.BTD()).permit(\n            msg.sender,\n            address(this),\n            btdAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _redeemBTD(msg.sender, btdAmount);\n    }\n\n    /**\n     * @notice Internal BTD redemption implementation\n     * @dev Decides redemption method based on CR: CR>=100% all WBTC, CR<100% mixed compensation\n     * @param account Redeemer address\n     * @param btdAmount BTD amount to burn (18 decimals)\n     */\n    function _redeemBTD(address account, uint256 btdAmount) internal {\n        require(btdAmount > 0, \"Invalid amount\");\n        require(\n            IMintableERC20(core.BTD()).balanceOf(account) >= btdAmount,\n            \"Not enough BTD\"\n        );\n\n        // Withdrawal limit check: BTD is stablecoin\n        _checkStablecoinAmount(btdAmount);\n\n        uint256 wbtcPrice = getWBTCPrice();\n        uint256 iusdPrice = getIUSDPrice();\n        uint256 cr = _getCRWithPrice(wbtcPrice, iusdPrice);\n\n        RedeemLogic.RedeemInputs memory redeemInputs = RedeemLogic.RedeemInputs({\n            btdAmount: btdAmount,\n            wbtcPrice: wbtcPrice,\n            iusdPrice: iusdPrice,\n            cr: cr,\n            btdPrice: 0,\n            btbPrice: 0,\n            brsPrice: 0,\n            minBTBPriceInBTD: 0,\n            redeemFeeBP: gov.redeemFeeBP()\n        });\n\n        if (cr < Constants.PRECISION_18) {\n            redeemInputs.btdPrice = getBTDPrice();\n            redeemInputs.btbPrice = getBTBPrice();\n            redeemInputs.brsPrice = getBRSPrice();\n            redeemInputs.minBTBPriceInBTD = gov.minBTBPrice();\n        }\n\n        RedeemLogic.RedeemOutputs memory redeemOutputs = RedeemLogic.evaluate(redeemInputs);\n\n        // Burn all user's BTD (including fee)\n        IMintableERC20(core.BTD()).burnFrom(account, btdAmount);\n\n        // If there's redemption fee, mint to Treasury\n        if (redeemOutputs.fee > 0) {\n            IMintableERC20(core.BTD()).mint(core.TREASURY(), redeemOutputs.fee);\n        }\n\n        uint256 wbtcOut = _wbtcFromNormalized(redeemOutputs.wbtcOutNormalized);\n        if (wbtcOut > 0) {\n            _checkWBTCAmount(wbtcOut);\n            ITreasury(core.TREASURY()).withdrawWBTC(wbtcOut);\n            IERC20(core.WBTC()).safeTransfer(account, wbtcOut);\n        }\n\n        if (redeemOutputs.brsOut > 0) {\n            ITreasury(core.TREASURY()).compensate(account, redeemOutputs.brsOut);\n        }\n\n        if (redeemOutputs.btbOut > 0) {\n            IMintableERC20(core.BTB()).mint(account, redeemOutputs.btbOut);\n        }\n\n        emit BTDRedeemed(account, btdAmount, wbtcOut, redeemOutputs.btbOut, redeemOutputs.brsOut);\n\n        // Note: fee is collected by burning user's BTD and minting back to Treasury\n        // The effective BTD removed from circulation is (btdAmount - fee)\n    }\n\n    // ============ Redeem BTB ============\n\n    /**\n     * @notice Redeem BTB for BTD\n     * @dev Only allowed when CR>=100%, burns BTB and mints equal BTD\n     * @dev Security: reentrancy guard, pause protection, CR check, max redeemable check\n     * @param btbAmount BTB amount to burn (18 decimals)\n     */\n    function redeemBTB(uint256 btbAmount) external nonReentrant whenNotPaused {\n        _validateRedeemBTBRequest(msg.sender, btbAmount);\n        _redeemBTB(msg.sender, btbAmount);\n    }\n\n    /**\n     * @notice Redeem BTB using EIP-2612 permit signature (no pre-approval needed)\n     * @dev User signs for one-tx BTB redemption, only available when CR>=100%\n     * @dev Security: reentrancy guard, pause protection, CR check, signature validation\n     * @param btbAmount BTB amount to burn (18 decimals)\n     * @param deadline Permit signature deadline timestamp (seconds)\n     * @param v ECDSA signature parameter v (27 or 28)\n     * @param r ECDSA signature parameter r (32 bytes)\n     * @param s ECDSA signature parameter s (32 bytes)\n     */\n    function redeemBTBWithPermit(\n        uint256 btbAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant whenNotPaused {\n        _validateRedeemBTBRequest(msg.sender, btbAmount);\n\n        IERC20Permit(core.BTB()).permit(\n            msg.sender,\n            address(this),\n            btbAmount,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        _redeemBTB(msg.sender, btbAmount);\n    }\n\n    /**\n     * @notice Validate BTB redemption request\n     * @dev Checks amount range and user balance\n     * @param account Redeemer address\n     * @param btbAmount BTB amount (18 decimals)\n     */\n    function _validateRedeemBTBRequest(address account, uint256 btbAmount) internal view {\n        _checkStablecoinAmount(btbAmount);\n        require(\n            IMintableERC20(core.BTB()).balanceOf(account) >= btbAmount,\n            \"Not enough BTB\"\n        );\n    }\n\n    /**\n     * @notice Internal BTB redemption implementation\n     * @dev Checks CR>=100%, redemption value meets minimum, doesn't exceed max redeemable, then burns BTB and mints BTD\n     * @param account Redeemer address\n     * @param btbAmount BTB amount (18 decimals)\n     */\n    function _redeemBTB(address account, uint256 btbAmount) internal {\n        // Get all prices at once (gas saving)\n        uint256 wbtcPrice = getWBTCPrice();\n        uint256 iusdPrice = getIUSDPrice();\n        uint256 cr = _getCRWithPrice(wbtcPrice, iusdPrice);\n        require(cr >= 1e18, \"CR<100%, BTB not redeemable\");\n\n        // Check redemption value meets min/max\n        uint256 redeemUsdValue = Math.mulDiv(btbAmount, iusdPrice, Constants.PRECISION_18);\n        require(redeemUsdValue >= Constants.MIN_USD_VALUE, \"Redeem value too small\");\n        require(redeemUsdValue <= Constants.MAX_USD_VALUE, \"Redeem value too large\");\n\n        uint256 collateralValue = CollateralMath.collateralValue(totalWBTC(), wbtcPrice);\n        uint256 liabilityValue = CollateralMath.liabilityValue(totalBTD(), totalStBTDEquivalent(), iusdPrice);\n        uint256 maxRedeemableBTD = CollateralMath.maxRedeemableBTD(collateralValue, liabilityValue, iusdPrice);\n        require(btbAmount <= maxRedeemableBTD, \"Exceeds max redeemable\");\n\n        // Burn BTB, mint equal BTD\n        IMintableERC20(core.BTB()).burnFrom(account, btbAmount);\n        IMintableERC20(core.BTD()).mint(account, btbAmount);\n\n        emit BTBRedeemed(account, btbAmount, btbAmount);\n    }\n\n    // ============ System State Queries ============\n\n    /**\n     * @notice Get overall system status information\n     * @dev Returns all key metrics at once for frontend display\n     * @return _totalBTD BTD total supply (18 decimals)\n     * @return _totalWBTC WBTC balance in Treasury (8 decimals)\n     * @return _collateralRatio Collateral ratio (18 decimals, 1e18=100%)\n     * @return _wbtcPrice WBTC price (18-decimal USD)\n     * @return _btbPrice BTB price (18-decimal USD)\n     * @return _brsPrice BRS price (18-decimal USD)\n     */\n    function getSystemInfo()\n        external\n        view\n        returns (\n            uint256 _totalBTD,\n            uint256 _totalWBTC,\n            uint256 _collateralRatio,\n            uint256 _wbtcPrice,\n            uint256 _btbPrice,\n            uint256 _brsPrice\n        )\n    {\n        _totalBTD = totalBTD();\n        _totalWBTC = totalWBTC();\n        _collateralRatio = getCollateralRatio();\n        _wbtcPrice = getWBTCPrice();\n        _btbPrice = getBTBPrice();\n        _brsPrice = getBRSPrice();\n    }\n}\n"
      },
      "project/contracts/PriceOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport \"./ConfigCore.sol\";\nimport \"./interfaces/IIdealUSDManager.sol\";\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IUniswapV2TWAPOracle.sol\";\nimport \"./interfaces/IAggregatorV3.sol\";\nimport \"./libraries/OracleMath.sol\";\nimport \"./libraries/FeedValidation.sol\";\nimport \"./libraries/PriceBlend.sol\";\n\n/// @notice Pyth Price Feed Interface\ninterface IPyth {\n    struct Price {\n        int64 price;\n        uint64 conf;\n        int32 expo;\n        uint256 publishTime;\n    }\n\n    function getPriceUnsafe(bytes32 id) external view returns (Price memory price);\n}\n\n/// @notice Redstone Data Service Interface\ninterface IRedstoneData {\n    function getValueForDataFeedId(bytes32 dataFeedId) external view returns (uint256);\n}\n\n/// @notice Uniswap V2 Pair Interface\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112, uint112, uint32);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}\n\n/**\n * @title PriceOracle - Bitres System Price Oracle\n * @notice Provides TWAP-protected unified price query service for the entire Bitres system\n * @dev Implements separation of concerns, isolating price query logic from business contracts\n */\ncontract PriceOracle is Ownable, IPriceOracle {\n    // ============ State Variables ============\n\n    // Immutable core configuration (fixed at deployment)\n    ConfigCore public immutable core;\n    bytes32 public immutable pythWbtcPriceId;\n    bytes32 public immutable redstoneWbtcDataFeedId;\n    uint8 public immutable redstoneWbtcDecimals;\n    bool public immutable useTWAPDefault;\n\n    // Mutable configuration (whitelist restricted)\n    IUniswapV2TWAPOracle public twapOracle;\n    bool public useTWAP;\n\n    // Governable parameters (strictly restricted)\n    uint256 public maxDeviationBps = 100; // Default 1%\n    uint256 public lastDeviationUpdate;\n\n    // Safety limit constants\n    uint256 public constant MAX_DEVIATION_CEILING = 500;  // Cannot exceed 5%\n    uint256 public constant MIN_DEVIATION_FLOOR = 50;     // Cannot be below 0.5%\n    uint256 public constant DEVIATION_UPDATE_COOLDOWN = 1 days;\n    uint256 public constant GOV_COOLDOWN = 1 days;\n\n    // Pyth price safety parameters\n    uint256 public constant PYTH_MAX_STALENESS = 60;      // Maximum staleness: 60 seconds\n    uint64 public constant PYTH_MAX_CONF_RATIO = 100;     // Maximum confidence ratio: 1% (conf/price < 1%)\n\n    /// @notice Pyth price ID update event\n    /// @param oldId Old price ID\n    /// @param newId New price ID\n    event PythPriceIdUpdated(bytes32 oldId, bytes32 newId);\n\n    /// @notice Redstone configuration update event\n    /// @param oldId Old data feed ID\n    /// @param oldDecimals Old decimals\n    /// @param newId New data feed ID\n    /// @param newDecimals New decimals\n    event RedstoneConfigUpdated(bytes32 oldId, uint8 oldDecimals, bytes32 newId, uint8 newDecimals);\n\n    /// @notice Maximum deviation update event\n    /// @param oldBps Old deviation value (basis points)\n    /// @param newBps New deviation value (basis points)\n    event MaxDeviationUpdated(uint256 oldBps, uint256 newBps);\n\n    // ============ Initialization ============\n\n    /**\n     * @notice Constructor\n     * @dev Initializes price oracle, fixes core configuration parameters\n     */\n    constructor(\n        address initialOwner,                  // Contract owner address, cannot be zero address\n        address _core,                         // ConfigCore contract address, cannot be zero address\n        address _twapOracle,                   // TWAP Oracle address, can be zero address (set later)\n        bytes32 _pythWbtcPriceId,              // Pyth WBTC price ID, cannot be zero\n        bytes32 _redstoneWbtcDataFeedId,       // Redstone WBTC data feed ID, cannot be zero\n        uint8 _redstoneWbtcDecimals            // Redstone decimals, must be greater than 0\n    ) Ownable(initialOwner) {\n        require(initialOwner != address(0), \"Invalid owner\");\n        require(_core != address(0), \"Invalid core address\");\n        require(_pythWbtcPriceId != bytes32(0), \"Invalid Pyth price id\");\n        require(_redstoneWbtcDataFeedId != bytes32(0), \"Invalid Redstone feed id\");\n        require(_redstoneWbtcDecimals > 0, \"Invalid Redstone decimals\");\n\n        core = ConfigCore(_core);\n        pythWbtcPriceId = _pythWbtcPriceId;\n        redstoneWbtcDataFeedId = _redstoneWbtcDataFeedId;\n        redstoneWbtcDecimals = _redstoneWbtcDecimals;\n        useTWAPDefault = true;\n        useTWAP = true;\n\n        if (_twapOracle != address(0)) {\n            twapOracle = IUniswapV2TWAPOracle(_twapOracle);\n        }\n    }\n\n    // ============ TWAP Management ============\n\n    /**\n     * @notice Sets TWAP Oracle address\n     * @dev Only owner can call, used to update TWAP Oracle contract address\n     * @param _twapOracle New TWAP Oracle address\n     */\n    function setTWAPOracle(address _twapOracle) external onlyOwner {\n        address oldOracle = address(twapOracle);\n        twapOracle = IUniswapV2TWAPOracle(_twapOracle);\n        emit TWAPOracleUpdated(oldOracle, _twapOracle);\n    }\n\n    /**\n     * @notice Toggles TWAP mode switch\n     * @dev Only owner can call, used to enable or disable TWAP price protection\n     * @param _useTWAP true to enable TWAP, false to use spot price\n     */\n    function setUseTWAP(bool _useTWAP) external onlyOwner {\n        useTWAP = _useTWAP;\n        emit TWAPModeChanged(_useTWAP);\n    }\n\n    // Removed: setPythWbtcPriceId() - pythWbtcPriceId is now immutable\n    // Removed: setRedstoneWbtcConfig() - redstoneWbtcDataFeedId and redstoneWbtcDecimals are now immutable\n    //\n    // Refactoring notes:\n    // - Pyth and Redstone configuration parameters are now fixed as immutable in constructor\n    // - These parameters cannot be modified after deployment, following weak governance principle\n    // - To switch price sources, use Config contract's whitelist mechanism to manage backup oracle addresses\n    // - Reference PARAMETER_CLASSIFICATION.md Section 1: PriceOracle parameter classification\n\n    /**\n     * @notice Sets maximum price deviation value (basis points)\n     * @dev Only owner can call, with strict safety restrictions:\n     *      1. Boundary check: 0.5% <= newBps <= 5%\n     *      2. One-way adjustment: can only tighten, not loosen\n     *      3. Cooldown period: at least 1 day between adjustments\n     *      4. Event logging: records all changes\n     * @param newBps New deviation value (basis points, e.g., 100 = 1%)\n     */\n    function setMaxDeviationBps(uint256 newBps) external onlyOwner {\n        // 1. Boundary check\n        require(newBps >= MIN_DEVIATION_FLOOR, \"Deviation too low\");\n        require(newBps <= MAX_DEVIATION_CEILING, \"Deviation too high\");\n\n        // 2. One-way adjustment (can only be stricter)\n        require(newBps < maxDeviationBps, \"Deviation can only tighten\");\n\n        // 3. Cooldown period check\n        if (lastDeviationUpdate > 0) {\n            require(\n                block.timestamp >= lastDeviationUpdate + DEVIATION_UPDATE_COOLDOWN,\n                \"Cooldown not met\"\n            );\n        }\n\n        uint256 old = maxDeviationBps;\n        maxDeviationBps = newBps;\n        lastDeviationUpdate = block.timestamp;\n\n        // 4. Event logging\n        emit MaxDeviationUpdated(old, newBps);\n    }\n\n    /**\n     * @notice Checks if TWAP is enabled\n     * @dev Checks both TWAP switch and whether Oracle address is set\n     * @return true if TWAP is enabled and available\n     */\n    function isTWAPEnabled() external view returns (bool) {\n        return useTWAP && address(twapOracle) != address(0);\n    }\n\n    /**\n     * @notice Gets TWAP Oracle contract address\n     * @dev Returns currently configured TWAP Oracle address\n     * @return TWAP Oracle contract address\n     */\n    function getTWAPOracle() external view returns (address) {\n        return address(twapOracle);\n    }\n\n    // ============ Chainlink Price Queries ============\n\n    /**\n     * @notice Gets Chainlink BTC/USD price\n     * @dev Reads BTC price from Chainlink aggregator, 18 decimals\n     * @return BTC price (18 decimal USD)\n     */\n    function getChainlinkBTCUSD() public view returns (uint256) {\n        return _getChainlinkPrice(core.CHAINLINK_BTC_USD());\n    }\n\n    /**\n     * @notice Internal function to read price from Chainlink aggregator\n     * @dev Uses FeedValidation library for security validation\n     * @param feedAddress Chainlink price feed address\n     * @return Normalized price (18 decimals)\n     */\n    function _getChainlinkPrice(address feedAddress) internal view returns (uint256) {\n        return FeedValidation.readAggregator(feedAddress);\n    }\n\n    /**\n     * @notice Gets WBTC/USD price via Chainlink\n     * @dev Calculates by multiplying WBTC/BTC and BTC/USD from two price feeds\n     * @return WBTC price (18 decimal USD)\n     */\n    function _getChainlinkWBTCUSD() internal view returns (uint256) {\n        uint256 wbtcToBtc = _getChainlinkPrice(core.CHAINLINK_WBTC_BTC());\n        uint256 btcToUsd = getChainlinkBTCUSD();\n        return Math.mulDiv(wbtcToBtc, btcToUsd, 1e18);\n    }\n\n    /**\n     * @notice Gets WBTC/USD price via Pyth\n     * @dev Reads price from Pyth network and normalizes to 18 decimals\n     * @return WBTC price (18 decimal USD)\n     */\n    function _getPythWBTCUSD() internal view returns (uint256) {\n        address pythFeed = core.PYTH_WBTC();\n        require(pythFeed != address(0), \"Pyth feed not set\");\n        require(pythWbtcPriceId != bytes32(0), \"Pyth price id not set\");\n\n        IPyth.Price memory price = IPyth(pythFeed).getPriceUnsafe(pythWbtcPriceId);\n        require(price.price > 0, \"Invalid Pyth price\");\n\n        // Check publishTime freshness (prevent stale prices)\n        require(\n            block.timestamp - price.publishTime <= PYTH_MAX_STALENESS,\n            \"Pyth price stale\"\n        );\n\n        // Check confidence level (conf should be small relative to price)\n        // conf/price < 1% means price uncertainty is acceptable\n        require(\n            price.conf * 100 <= uint64(price.price),\n            \"Pyth confidence too wide\"\n        );\n\n        return _scalePythPrice(price.price, price.expo);\n    }\n\n    /**\n     * @notice Gets WBTC/USD price via Redstone\n     * @dev Reads price from Redstone data service and normalizes to 18 decimals\n     * @return WBTC price (18 decimal USD)\n     */\n    function _getRedstoneWBTCUSD() internal view returns (uint256) {\n        address redstoneFeed = core.REDSTONE_WBTC();\n        require(redstoneFeed != address(0), \"Redstone feed not set\");\n        require(redstoneWbtcDataFeedId != bytes32(0), \"Redstone id not set\");\n        require(redstoneWbtcDecimals > 0, \"Redstone decimals not set\");\n\n        uint256 price = IRedstoneData(redstoneFeed).getValueForDataFeedId(redstoneWbtcDataFeedId);\n        require(price > 0, \"Invalid Redstone price\");\n        return OracleMath.normalizeAmount(price, redstoneWbtcDecimals);\n    }\n\n    /**\n     * @notice Converts Pyth price format to standard 18 decimals\n     * @dev Handles Pyth-specific price and exponent format\n     * @param price Pyth raw price value\n     * @param expo Pyth price exponent\n     * @return Normalized price (18 decimals)\n     */\n    function _scalePythPrice(int64 price, int32 expo) internal pure returns (uint256) {\n        require(price > 0, \"Invalid Pyth value\");\n        int32 exponent = expo + 18;\n        require(exponent > -80 && exponent < 80, \"Pyth exponent out of bounds\");\n        uint256 base = uint256(uint64(price));\n\n        if (exponent >= 0) {\n            return base * (10 ** uint32(uint32(exponent)));\n        }\n\n        uint32 absExp = uint32(uint32(-exponent));\n        return base / (10 ** absExp);\n    }\n\n    // ============ Core Price Queries ============\n\n    /**\n     * @notice Gets token price from Uniswap V2 pool\n     * @dev Chooses TWAP price or spot price based on TWAP switch\n     * @param pool Uniswap V2 pool address\n     * @param base Base token address\n     * @param quote Quote token address\n     * @return Price (18 decimals, representing how much quote per base)\n     */\n    function getPrice(address pool, address base, address quote)\n        public view returns (uint256) {\n        // Use TWAP (if enabled and available)\n        if (useTWAP && address(twapOracle) != address(0)) {\n            return _getPriceTWAP(pool, base, quote);\n        }\n        return _getPriceSpot(pool, base, quote);\n    }\n\n    /**\n     * @notice Gets WBTC/USD price (multi-source validation)\n     * @dev Takes median of Chainlink, Pyth, Redstone three price sources, then validates against Uniswap price\n     * @dev Safety check: Uniswap price must be within 1% of reference price, otherwise reverts\n     * @return WBTC price (18 decimal USD)\n     */\n    function getWBTCPrice() public view returns (uint256) {\n        uint256 chainlinkDerived = _getChainlinkWBTCUSD();\n        uint256 pythPrice = _getPythWBTCUSD();\n        uint256 redstonePrice = _getRedstoneWBTCUSD();\n\n        uint256 referencePrice = PriceBlend.median3(chainlinkDerived, pythPrice, redstonePrice);\n        uint256 uniPrice = getPrice(\n            core.POOL_WBTC_USDC(),\n            core.WBTC(),\n            core.USDC()\n        );\n\n        // Strict 1% deviation check (prevents manipulation + market volatility circuit breaker)\n        require(\n            OracleMath.deviationWithin(uniPrice, referencePrice, maxDeviationBps),\n            \"WBTC price mismatch >1%\"\n        );\n\n        return uniPrice;\n    }\n\n    /**\n     * @notice Gets BTD/USD actual market price\n     * @dev Reads price from Uniswap BTD/USDC pool\n     * @return BTD price (18 decimal USD)\n     */\n    function getBTDPrice() public view returns (uint256) {\n        // Get BTD actual market price from Uniswap (BTD/USDC)\n        return getPrice(\n            core.POOL_BTD_USDC(),\n            core.BTD(),\n            core.USDC()\n        );\n    }\n\n    /**\n     * @notice Gets BTB/USD price\n     * @dev Calculates via BTB/BTD and BTD/USDC two pools: BTB price = (BTB/BTD price) x (BTD/USD price)\n     * @return BTB price (18 decimal USD)\n     */\n    function getBTBPrice() public view returns (uint256) {\n        uint256 btbBtd = getPrice(\n            core.POOL_BTB_BTD(),\n            core.BTB(),\n            core.BTD()\n        );\n        uint256 btdUsdc = getBTDPrice();  // Use BTD actual market price\n        // Use Math.mulDiv to prevent overflow and precision loss (double price multiplication)\n        uint256 price = Math.mulDiv(btbBtd, btdUsdc, 1e18);\n\n        // Return actual price (no limit)\n        // Price capping is handled by Minter contract:\n        // - If BTB price < minPrice, calculate BTB compensation at minPrice, difference compensated with BRS\n        // - This way we get actual market price while protecting users from receiving too many low-priced BTB\n        return price;\n    }\n\n    /**\n     * @notice Gets BRS/USD price\n     * @dev Calculates via BRS/BTD and BTD/USDC two pools: BRS price = (BRS/BTD price) x (BTD/USD price)\n     * @return BRS price (18 decimal USD)\n     */\n    function getBRSPrice() public view returns (uint256) {\n        uint256 brsBtd = getPrice(\n            core.POOL_BRS_BTD(),\n            core.BRS(),\n            core.BTD()\n        );\n        uint256 btdUsdc = getBTDPrice();  // Use BTD actual market price\n        // Use Math.mulDiv to prevent overflow and precision loss (double price multiplication)\n        uint256 price = Math.mulDiv(brsBtd, btdUsdc, 1e18);\n\n        return price;\n    }\n\n    /**\n     * @notice Gets WETH price (ETH/USD)\n     * @dev Testnet uses fixed price $3000, production uses Chainlink oracle\n     * @return WETH price (18 decimal USD)\n     */\n    function getWETHPrice() public pure returns (uint256) {\n        // Testnet: fixed price $3000\n        return 3000e18;\n\n        // Production: use Chainlink ETH/USD feed\n        // IAggregatorV3 feed = IAggregatorV3(config.chainlinkETHUSD());\n        // (, int256 price, , , ) = feed.latestRoundData();\n        // require(price > 0, \"Invalid Chainlink ETH price\");\n        // return uint256(price) * 1e10; // Chainlink uses 8 decimals, convert to 18\n    }\n\n    /**\n     * @notice Gets stBTD price (BTD share price including accumulated interest)\n     * @dev Uses ERC4626 formula: (totalAssets / totalSupply) x BTD price\n     * @return stBTD price (18 decimal USD)\n     */\n    function getStBTDPrice() public view returns (uint256) {\n        address stBTDAddr = core.ST_BTD();\n        require(stBTDAddr != address(0), \"stBTD not configured\");\n\n        IERC4626 stBTDVault = IERC4626(stBTDAddr);\n        uint256 totalShares = stBTDVault.totalSupply();\n\n        // Initial state: no deposits yet, 1:1 pegged to BTD\n        if (totalShares == 0) {\n            return getBTDPrice();\n        }\n\n        // Get total underlying assets (includes accumulated interest)\n        uint256 totalAssets = stBTDVault.totalAssets();\n\n        // Assets per share (18 decimals)\n        // assetsPerShare = totalAssets / totalShares\n        uint256 assetsPerShare = Math.mulDiv(totalAssets, 1e18, totalShares);\n\n        // stBTD price = assets per share x BTD price\n        uint256 btdPrice = getBTDPrice();\n        return Math.mulDiv(assetsPerShare, btdPrice, 1e18);\n    }\n\n    /**\n     * @notice Gets stBTB price (BTB share price including accumulated interest)\n     * @dev Uses ERC4626 formula: (totalAssets / totalSupply) x BTB price\n     * @return stBTB price (18 decimal USD)\n     */\n    function getStBTBPrice() public view returns (uint256) {\n        address stBTBAddr = core.ST_BTB();\n        require(stBTBAddr != address(0), \"stBTB not configured\");\n\n        IERC4626 stBTBVault = IERC4626(stBTBAddr);\n        uint256 totalShares = stBTBVault.totalSupply();\n\n        // Initial state: no deposits yet, 1:1 pegged to BTB\n        if (totalShares == 0) {\n            return getBTBPrice();\n        }\n\n        // Get total underlying assets (includes accumulated interest)\n        uint256 totalAssets = stBTBVault.totalAssets();\n\n        // Assets per share (18 decimals)\n        // assetsPerShare = totalAssets / totalShares\n        uint256 assetsPerShare = Math.mulDiv(totalAssets, 1e18, totalShares);\n\n        // stBTB price = assets per share x BTB price\n        uint256 btbPrice = getBTBPrice();\n        return Math.mulDiv(assetsPerShare, btbPrice, 1e18);\n    }\n\n    /**\n     * @notice Gets IUSD (Ideal USD) price\n     * @dev Queries from IdealUSDManager contract, IUSD adjusts with inflation\n     * @return IUSD price (18 decimals)\n     */\n    function getIUSDPrice() public view returns (uint256) {\n        address manager = core.IDEAL_USD_MANAGER();\n        require(manager != address(0), \"IUSD manager not set\");\n\n        uint256 price = IIdealUSDManager(manager).getCurrentIUSD();\n        require(price > 0, \"Invalid IUSD price\");\n        return price;\n    }\n\n    /**\n     * @notice Universal price query function (returns USD price based on token address)\n     * @dev Supports price queries for all major tokens in the system, including stablecoins, equity tokens, interest-bearing tokens\n     * @param token Token contract address\n     * @return Price (18 decimal USD)\n     */\n    function getPrice(address token) public view returns (uint256) {\n        if (token == core.WBTC()) return getWBTCPrice();\n        if (token == core.BTD()) return getBTDPrice();\n        if (token == core.BTB()) return getBTBPrice();\n        if (token == core.BRS()) return getBRSPrice();\n        if (token == core.WETH()) return getWETHPrice();\n        if (token == core.ST_BTD()) return getStBTDPrice();\n        if (token == core.ST_BTB()) return getStBTBPrice();\n        if (token == core.USDC()) return 1e18;  // $1\n        if (token == core.USDT()) return 1e18;  // $1\n\n        revert(\"Price not available for this token\");\n    }\n\n    // ============ Internal Implementation: TWAP Price Queries ============\n\n    /**\n     * @notice Gets TWAP price (time-weighted average price)\n     * @dev Reads 30-minute time-weighted average price from TWAP Oracle, prevents flash loan attacks\n     * @param pool Uniswap V2 pool address\n     * @param base Base token address\n     * @param quote Quote token address\n     * @return Price (18 decimals)\n     */\n    function _getPriceTWAP(address pool, address base, address quote)\n        internal view returns (uint256) {\n        require(address(twapOracle) != address(0), \"TWAP oracle not set\");\n        require(twapOracle.isTWAPReady(pool), \"TWAP not ready\");\n\n        IUniswapV2Pair pair = IUniswapV2Pair(pool);\n        address token0 = pair.token0();\n        address token1 = pair.token1();\n\n        require(\n            (token0 == base && token1 == quote) ||\n                (token0 == quote && token1 == base),\n            \"Invalid base/quote for pool\"\n        );\n\n        // Determine token decimals\n        uint8 baseDecimals = _getTokenDecimals(base);\n        uint8 quoteDecimals = _getTokenDecimals(quote);\n\n        // Get TWAP price (already 18 decimals)\n        if (token0 == base) {\n            // token0/token1 = base/quote, we want quote/base\n            uint256 baseQuotePrice = twapOracle.getTWAPPrice(pool, baseDecimals, quoteDecimals);\n            return OracleMath.inversePrice(baseQuotePrice);\n        } else {\n            // token0/token1 = quote/base, exactly what we want\n            return twapOracle.getTWAPPrice(pool, quoteDecimals, baseDecimals);\n        }\n    }\n\n    // ============ Internal Implementation: Spot Price Queries ============\n\n    /**\n     * @notice Gets spot price (based on current pool reserves)\n     * @dev Vulnerable to flash loan attacks, only for testing environment or when TWAP unavailable\n     * @param pool Uniswap V2 pool address\n     * @param base Base token address\n     * @param quote Quote token address\n     * @return Price (18 decimals)\n     */\n    function _getPriceSpot(address pool, address base, address quote)\n        internal view returns (uint256) {\n        IUniswapV2Pair pair = IUniswapV2Pair(pool);\n        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n        address token0 = pair.token0();\n        address token1 = pair.token1();\n\n        require(\n            (token0 == base && token1 == quote) ||\n                (token0 == quote && token1 == base),\n            \"Invalid base/quote for pool\"\n        );\n\n        uint256 reserveBase = (token0 == base) ? uint256(reserve0) : uint256(reserve1);\n        uint256 reserveQuote = (token0 == base) ? uint256(reserve1) : uint256(reserve0);\n\n        uint8 baseDecimals = _getTokenDecimals(base);\n        uint8 quoteDecimals = _getTokenDecimals(quote);\n        return OracleMath.spotPrice(reserveBase, reserveQuote, baseDecimals, quoteDecimals);\n    }\n\n    // ============ Helper Functions ============\n\n    /**\n     * @notice Internal helper function to get token decimals\n     * @dev WBTC: 8, USDC: 6, others: 18\n     * @param token Token address\n     * @return Token decimals\n     */\n    function _getTokenDecimals(address token) internal view returns (uint8) {\n        if (token == core.WBTC()) {\n            return 8;\n        } else if (token == core.USDC()) {\n            return 6;\n        } else {\n            return 18;\n        }\n    }\n}\n"
      },
      "project/contracts/StakingRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IFarmingPool.sol\";\nimport \"./libraries/Constants.sol\";\n\n/// @title StakingRouter\n/// @notice Users interact with InterestPool/FarmingPool through this unified staking entry to receive dual rewards\n/// @dev Logic:\n///      - BTD/BTB: First deposit to stBTD/stBTB (vault accrues interest), then stake stToken to FarmingPool to earn BRS\n///      - Other pools: Directly stake to FarmingPool, only earn BRS\ncontract StakingRouter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IFarmingPool public immutable farmingPool;\n\n    // stToken vault contracts\n    IERC4626 public immutable stBTD;\n    IERC4626 public immutable stBTB;\n\n    // Pool IDs for stBTD and stBTB in FarmingPool (regular pools, not virtual)\n    uint256 public stBTDPoolId;\n    uint256 public stBTBPoolId;\n\n    // Track user's pool participation for batch operations\n    mapping(address => uint256[]) private userPools;\n\n    event Staked(address indexed user, address indexed token, uint256 amount);\n    event Withdrawn(address indexed user, address indexed token, uint256 amount);\n    event RewardsClaimed(address indexed user, uint256 btdInterest, uint256 btbInterest, uint256 brsReward);\n\n    /** @notice Constructor */\n    constructor(\n        address _farmingPool,    // FarmingPool address\n        address _stBTD,          // stBTD vault\n        address _stBTB,          // stBTB vault\n        uint256 _stBTDPoolId,    // stBTD pool ID in FarmingPool\n        uint256 _stBTBPoolId     // stBTB pool ID in FarmingPool\n    ) Ownable(msg.sender) {\n        require(_farmingPool != address(0), \"Invalid FarmingPool address\");\n        require(_stBTD != address(0), \"Invalid stBTD address\");\n        require(_stBTB != address(0), \"Invalid stBTB address\");\n\n        farmingPool = IFarmingPool(_farmingPool);\n        stBTD = IERC4626(_stBTD);\n        stBTB = IERC4626(_stBTB);\n        stBTDPoolId = _stBTDPoolId;\n        stBTBPoolId = _stBTBPoolId;\n    }\n\n    // --- BTD Staking (Dual Rewards: BTD Interest + BRS) ---\n\n    /// @notice Stakes BTD to earn dual rewards\n    /// @dev Flow: BTD -> deposit to stBTD vault -> stake stBTD to FarmingPool\n    ///      Earns BTD interest (via stBTD appreciation) + BRS mining rewards\n    /// @param amount BTD amount to stake, precision 1e18, must be >= minimum stake amount\n    function stakeBTD(uint256 amount) external nonReentrant {\n        _stakeViaVault(stBTD, stBTDPoolId, amount);\n    }\n\n    /// @notice Redeems BTD\n    /// @dev Flow: withdraw stBTD from FarmingPool -> redeem BTD from vault -> transfer to user\n    ///      Redemption amount includes accumulated BTD interest\n    /// @param amount BTD amount to redeem, precision 1e18\n    function withdrawBTD(uint256 amount) external nonReentrant {\n        _withdrawViaVault(stBTD, stBTDPoolId, amount);\n    }\n\n    // --- BTB Staking (Dual Rewards: BTB Interest + BRS) ---\n\n    /// @notice Stakes BTB to earn dual rewards\n    /// @dev Flow: BTB -> deposit to stBTB vault -> stake stBTB to FarmingPool\n    ///      Earns BTB interest (via stBTB appreciation) + BRS mining rewards\n    /// @param amount BTB amount to stake, precision 1e18, must be >= minimum stake amount\n    function stakeBTB(uint256 amount) external nonReentrant {\n        _stakeViaVault(stBTB, stBTBPoolId, amount);\n    }\n\n    /// @notice Redeems BTB\n    /// @dev Flow: withdraw stBTB from FarmingPool -> redeem BTB from vault -> transfer to user\n    ///      Redemption amount includes accumulated BTB interest\n    /// @param amount BTB amount to redeem, precision 1e18\n    function withdrawBTB(uint256 amount) external nonReentrant {\n        _withdrawViaVault(stBTB, stBTBPoolId, amount);\n    }\n\n    // --- Single Token Staking (BRS Rewards Only) ---\n\n    /// @notice Stakes other tokens to earn BRS rewards\n    /// @dev Supports staking stBTD, stBTB, USDC, USDT, WBTC, BRS, LP tokens, etc.\n    ///      Only earns BRS mining rewards (unlike BTD/BTB which have dual rewards)\n    ///      Note: min/max USD value checks are handled by FarmingPool._deposit\n    /// @param poolId Pool ID in FarmingPool\n    /// @param amount Stake amount, precision depends on token\n    function stakeToken(uint256 poolId, uint256 amount) external nonReentrant {\n        require(amount > 0, \"Amount must be > 0\");\n\n        // Note: Due to different token precisions (6/8/18 decimals),\n        // specific min/max USD value validation is handled by FarmingPool._deposit\n\n        // Get pool token\n        (IERC20 lpToken, , , , , , , ) = farmingPool.poolInfo(poolId);\n\n        // Transfer token from user to this router (using SafeERC20)\n        IERC20(address(lpToken)).safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve and deposit to FarmingPool (on behalf of user)\n        IERC20(address(lpToken)).forceApprove(address(farmingPool), amount);\n        farmingPool.depositFor(poolId, amount, msg.sender);\n\n        // Track user's pool participation\n        _addUserPool(msg.sender, poolId);\n\n        emit Staked(msg.sender, address(lpToken), amount);\n    }\n\n    /// @notice Withdraws staked tokens from specified pool\n    /// @dev Withdraws staked tokens, automatically claims accumulated BRS rewards\n    ///      Note: min USD value check is handled by FarmingPool._withdraw\n    /// @param poolId Pool ID in FarmingPool\n    /// @param amount Withdraw amount\n    function withdrawToken(uint256 poolId, uint256 amount) external nonReentrant {\n        require(amount > 0, \"Amount must be > 0\");\n\n        // Note: Due to different token precisions (6/8/18 decimals),\n        // specific min USD value validation is handled by FarmingPool._withdraw\n\n        // Get pool token\n        (IERC20 lpToken, , , , , , , ) = farmingPool.poolInfo(poolId);\n\n        // Withdraw from FarmingPool (on behalf of user, send to router)\n        farmingPool.withdrawFor(poolId, amount, msg.sender, address(this));\n\n        // Transfer token back to user (using SafeERC20)\n        IERC20(address(lpToken)).safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, address(lpToken), amount);\n    }\n\n    // --- Reward Claiming ---\n\n    // NOTE: BTD/BTB interest is auto-accrued in stBTD/stBTB tokens.\n    // When you withdraw, you automatically receive the appreciated BTD/BTB amount.\n    // No separate interest claiming needed!\n\n    /// @notice Claims BRS rewards from stToken pools\n    /// @dev Claims BRS rewards from stBTD pool and stBTB pool\n    ///      Note: BTD/BTB interest auto-accumulates in stBTD/stBTB shares, no separate claiming needed\n    function claimBRSFromStTokenPools() external nonReentrant {\n        // Claim from stBTD pool (on behalf of user, rewards sent directly to them)\n        try farmingPool.claimFor(stBTDPoolId, msg.sender) {} catch {}\n\n        // Claim from stBTB pool (on behalf of user, rewards sent directly to them)\n        try farmingPool.claimFor(stBTBPoolId, msg.sender) {} catch {}\n    }\n\n    /// @notice Claims BRS rewards from specified pool\n    /// @dev Claims BRS rewards from a single pool without affecting staked principal\n    /// @param poolId Pool ID in FarmingPool\n    function claimBRSFromPool(uint256 poolId) external nonReentrant {\n        // Claim on behalf of user, rewards sent directly to them\n        farmingPool.claimFor(poolId, msg.sender);\n    }\n\n    /// @notice One-click claim all BRS rewards\n    /// @dev Claims BRS rewards from all pools the user participates in\n    ///      BTD/BTB interest auto-accumulates in stBTD/stBTB, no separate claiming needed\n    ///      Rewards sent directly to user via claimFor\n    function claimAll() external nonReentrant {\n        // Claim BRS from stToken pools (rewards sent directly to user)\n        try farmingPool.claimFor(stBTDPoolId, msg.sender) {} catch {}\n        try farmingPool.claimFor(stBTBPoolId, msg.sender) {} catch {}\n\n        // Claim BRS from user's other pools (rewards sent directly to user)\n        uint256[] memory pools = userPools[msg.sender];\n        for (uint256 i = 0; i < pools.length; i++) {\n            try farmingPool.claimFor(pools[i], msg.sender) {} catch {}\n        }\n    }\n\n    // --- View Functions ---\n\n    /// @notice Queries all pending BRS rewards for user\n    /// @dev Aggregates pending BRS rewards from all pools the user participates in\n    ///      Note: BTD/BTB interest is automatically reflected in stBTD/stBTB exchange rate\n    /// @param user User address\n    /// @return pendingBRS Total pending BRS amount, precision 1e18\n    function pendingRewards(address user) external view returns (uint256 pendingBRS) {\n        // Pending BRS from stToken pools\n        pendingBRS = farmingPool.pendingReward(stBTDPoolId, user)\n                   + farmingPool.pendingReward(stBTBPoolId, user);\n\n        // Pending BRS from user's other pools\n        uint256[] memory pools = userPools[user];\n        for (uint256 i = 0; i < pools.length; i++) {\n            pendingBRS += farmingPool.pendingReward(pools[i], user);\n        }\n    }\n\n    /// @notice Queries user's staked BTD/BTB equivalent amounts\n    /// @dev Converts stBTD/stBTB shares to equivalent BTD/BTB amounts (includes accumulated interest)\n    /// @param user User address\n    /// @return stakedBTD BTD equivalent amount (stBTD shares x exchange rate), precision 1e18\n    /// @return stakedBTB BTB equivalent amount (stBTB shares x exchange rate), precision 1e18\n    function stakedAmounts(address user) external view returns (\n        uint256 stakedBTD,\n        uint256 stakedBTB\n    ) {\n        // Get user's stBTD shares in FarmingPool\n        (uint256 stBTDShares, ) = farmingPool.userInfo(stBTDPoolId, user);\n        // Convert stBTD shares to BTD amount\n        stakedBTD = stBTD.convertToAssets(stBTDShares);\n\n        // Get user's stBTB shares in FarmingPool\n        (uint256 stBTBShares, ) = farmingPool.userInfo(stBTBPoolId, user);\n        // Convert stBTB shares to BTB amount\n        stakedBTB = stBTB.convertToAssets(stBTBShares);\n    }\n\n    /// @notice Queries user's staked amount in specified pool\n    /// @dev Returns user's staked amount in FarmingPool specified pool\n    /// @param user User address\n    /// @param poolId Pool ID\n    /// @return Staked amount, precision depends on token\n    function stakedInPool(address user, uint256 poolId) external view returns (uint256) {\n        (uint256 amount, ) = farmingPool.userInfo(poolId, user);\n        return amount;\n    }\n\n    // --- Internal Functions ---\n\n    /// @dev Internal function to stake tokens via ERC4626 vault for dual rewards\n    /// @param vault ERC4626 vault contract (stBTD or stBTB)\n    /// @param poolId Pool ID in FarmingPool\n    /// @param amount Underlying asset amount to stake (BTD or BTB)\n    function _stakeViaVault(\n        IERC4626 vault,\n        uint256 poolId,\n        uint256 amount\n    ) internal {\n        require(amount > 0, \"Amount must be > 0\");\n\n        // Check min/max operation value (BTD/BTB are 18 decimal stablecoins)\n        require(\n            amount >= Constants.MIN_STABLECOIN_18_AMOUNT,\n            \"Stake amount too small\"\n        );\n        require(\n            amount <= Constants.MAX_STABLECOIN_18_AMOUNT,\n            \"Stake amount too large\"\n        );\n\n        address assetAddress = address(vault.asset());\n        IERC20 asset = IERC20(assetAddress);\n\n        // Transfer asset from user to this router (using SafeERC20)\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve vault to take asset (using SafeERC20)\n        asset.forceApprove(address(vault), amount);\n\n        // Deposit asset to vault and receive shares\n        uint256 shares = vault.deposit(amount, address(this));\n\n        // Approve FarmingPool to take vault shares (using SafeERC20)\n        IERC20(address(vault)).forceApprove(address(farmingPool), shares);\n\n        // Stake vault shares in FarmingPool to earn BRS (on behalf of user)\n        farmingPool.depositFor(poolId, shares, msg.sender);\n\n        // Track user's pool participation\n        _addUserPool(msg.sender, poolId);\n\n        emit Staked(msg.sender, assetAddress, amount);\n    }\n\n    /// @dev Internal function to withdraw tokens via ERC4626 vault\n    /// @param vault ERC4626 vault contract (stBTD or stBTB)\n    /// @param poolId Pool ID in FarmingPool\n    /// @param amount Underlying asset amount to withdraw (BTD or BTB)\n    function _withdrawViaVault(\n        IERC4626 vault,\n        uint256 poolId,\n        uint256 amount\n    ) internal {\n        require(amount > 0, \"Amount must be > 0\");\n\n        // Check min operation value (BTD/BTB are 18 decimal stablecoins)\n        require(\n            amount >= Constants.MIN_STABLECOIN_18_AMOUNT,\n            \"Withdraw amount too small\"\n        );\n\n        // Calculate vault shares needed for this amount of asset\n        uint256 shares = vault.previewWithdraw(amount);\n\n        // Withdraw vault shares from FarmingPool (on behalf of user, send to router)\n        farmingPool.withdrawFor(poolId, shares, msg.sender, address(this));\n\n        // Redeem vault shares for asset (send asset directly to user)\n        vault.redeem(shares, msg.sender, address(this));\n\n        emit Withdrawn(msg.sender, address(vault.asset()), amount);\n    }\n\n    function _addUserPool(address user, uint256 poolId) internal {\n        uint256[] storage pools = userPools[user];\n        for (uint256 i = 0; i < pools.length; i++) {\n            if (pools[i] == poolId) return; // Already tracked\n        }\n        pools.push(poolId);\n    }\n}\n"
      },
      "project/contracts/stBTB.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ERC4626} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title stBTB - BTB Staking Receipt (Pure ERC4626 Implementation)\n * @notice Standard ERC4626 vault, holding BTB as underlying asset\n * @dev Contains no business logic, serves only as share token\n *      - Users deposit BTB, receive stBTB shares\n *      - stBTB can be transferred, traded, used in DeFi composables\n *      - Redeeming stBTB returns BTB\n *      - Interest logic is managed by external contracts (e.g., InterestPool)\n *\n * Architecture Design Principles:\n *      - Single responsibility: only manages BTB share accounting\n *      - No external dependencies: does not depend on any business contracts\n *      - Composability: can be used by any contract or user\n */\ncontract stBTB is ERC4626, ERC20Permit {\n    /**\n     * @notice Constructor\n     * @param btb BTB token address\n     */\n    constructor(IERC20 btb)\n        ERC20(\"Staked Bitcoin Bond\", \"stBTB\")\n        ERC20Permit(\"Staked Bitcoin Bond\")\n        ERC4626(btb)\n    {}\n\n    /**\n     * @notice Gets token decimals (18 digits)\n     * @dev Overrides decimals function from ERC20 and ERC4626\n     * @return Decimal places\n     */\n    function decimals() public view override(ERC20, ERC4626) returns (uint8) {\n        return super.decimals();\n    }\n}\n"
      },
      "project/contracts/stBTD.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ERC4626} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title stBTD - BTD Staking Receipt (Pure ERC4626 Implementation)\n * @notice Standard ERC4626 vault, holding BTD as underlying asset\n * @dev Contains no business logic, serves only as share token\n *      - Users deposit BTD, receive stBTD shares\n *      - stBTD can be transferred, traded, used in DeFi composables\n *      - Redeeming stBTD returns BTD\n *      - Interest logic is managed by external contracts (e.g., InterestPool)\n *\n * Architecture Design Principles:\n *      - Single responsibility: only manages BTD share accounting\n *      - No external dependencies: does not depend on any business contracts\n *      - Composability: can be used by any contract or user\n */\ncontract stBTD is ERC4626, ERC20Permit {\n    /**\n     * @notice Constructor\n     * @param btd BTD token address\n     */\n    constructor(IERC20 btd)\n        ERC20(\"Staked Bitcoin Dollar\", \"stBTD\")\n        ERC20Permit(\"Staked Bitcoin Dollar\")\n        ERC4626(btd)\n    {}\n\n    /**\n     * @notice Gets token decimals (18 digits)\n     * @dev Overrides decimals function from ERC20 and ERC4626\n     * @return Decimal places\n     */\n    function decimals() public view override(ERC20, ERC4626) returns (uint8) {\n        return super.decimals();\n    }\n}\n"
      },
      "project/contracts/Treasury.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./ConfigCore.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./libraries/Constants.sol\";\n\ninterface IUniswapV2Router {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n}\n\n/**\n * @title Treasury - Bitres System Treasury Contract\n * @notice Manages WBTC/BTD/BRS assets, provides liquidity support for Minter\n * @dev Core functions: WBTC deposit/withdraw, BRS compensation, BTD buyback BRS\n */\ncontract Treasury is Ownable, ReentrancyGuard, ITreasury {\n    using SafeERC20 for IERC20;\n\n    ConfigCore public immutable core;\n    address public override router;\n\n    /// @notice Router address update event\n    /// @param oldRouter Old Router address\n    /// @param newRouter New Router address\n    event RouterUpdated(address indexed oldRouter, address indexed newRouter);\n\n    /**\n     * @notice Constructor\n     * @dev Initializes treasury with owner, Config contract and Uniswap Router\n     */\n    constructor(\n        address initialOwner,  // Contract owner address, cannot be zero address\n        address _core,         // ConfigCore contract address, cannot be zero address\n        address routerAddr     // Uniswap V2 Router address (for swap), cannot be zero address\n    ) Ownable(initialOwner) {\n        require(initialOwner != address(0), \"Treasury: invalid owner\");\n        require(_core != address(0), \"Treasury: invalid core\");\n        require(routerAddr != address(0), \"Treasury: invalid router\");\n        core = ConfigCore(_core);\n        router = routerAddr;\n    }\n\n    /**\n     * @notice Modifier allowing only Minter contract to call\n     * @dev Protects core functions like WBTC deposit/withdraw and BRS compensation\n     * @dev Production must strictly limit - only Minter can call\n     */\n    modifier onlyMint() {\n        require(\n            msg.sender == core.MINTER(),\n            \"Treasury: only Minter\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Get ConfigCore contract address\n     * @dev Implements ITreasury interface\n     * @return ConfigCore contract address\n     */\n    function configCore() public view override returns (address) {\n        return address(core);\n    }\n\n    /**\n     * @notice Get WBTC token contract instance\n     * @dev Reads WBTC address from ConfigCore\n     * @return WBTC token contract interface\n     */\n    function WBTC() internal view returns (IERC20) {\n        return IERC20(core.WBTC());\n    }\n\n    /**\n     * @notice Get BRS token contract instance\n     * @dev Reads BRS address from ConfigCore\n     * @return BRS token contract interface\n     */\n    function BRS() internal view returns (IERC20) {\n        return IERC20(core.BRS());\n    }\n\n    /**\n     * @notice Get BTD token contract instance\n     * @dev Reads BTD address from ConfigCore\n     * @return BTD token contract interface\n     */\n    function BTD() internal view returns (IERC20) {\n        return IERC20(core.BTD());\n    }\n\n    /**\n     * @notice Deposit WBTC to treasury\n     * @dev Only Minter can call, used for storing collateral when minting BTD\n     * @dev Security: onlyMint modifier, reentrancy guard, amount validation, anti-hack limits\n     * @param amt WBTC amount (8 decimals)\n     */\n    function depositWBTC(uint256 amt) external override onlyMint nonReentrant {\n        require(amt >= Constants.MIN_BTC_AMOUNT, \"Treasury: amount too small\");\n        require(amt <= Constants.MAX_WBTC_AMOUNT, \"Treasury: exceeds max WBTC\");\n        WBTC().safeTransferFrom(msg.sender, address(this), amt);\n        emit ITreasury.WBTCDeposited(msg.sender, amt);\n    }\n\n    /**\n     * @notice Withdraw WBTC from treasury\n     * @dev Only Minter can call, used for returning collateral when redeeming BTD\n     * @dev Security: onlyMint modifier, reentrancy guard, balance check, anti-hack limits\n     * @param amt WBTC amount (8 decimals)\n     */\n    function withdrawWBTC(uint256 amt) external override onlyMint nonReentrant {\n        require(amt >= Constants.MIN_BTC_AMOUNT, \"Treasury: amount too small\");\n        require(amt <= Constants.MAX_WBTC_AMOUNT, \"Treasury: exceeds max WBTC\");\n        require(WBTC().balanceOf(address(this)) >= amt, \"Treasury: insufficient WBTC\");\n        WBTC().safeTransfer(msg.sender, amt);\n        emit ITreasury.WBTCWithdrawn(msg.sender, amt);\n    }\n\n    /**\n     * @notice Compensate users with BRS\n     * @dev Only Minter can call, used for compensation when CR<100%, actual payout limited by treasury BRS balance\n     * @dev Security: onlyMint modifier, reentrancy guard, address validation, amount validation, balance clamping\n     * @param to Address receiving compensation\n     * @param amt Requested BRS compensation amount (18 decimals), actual payout may be less\n     */\n    function compensate(address to, uint256 amt) external override onlyMint nonReentrant {\n        require(to != address(0), \"Treasury: zero address\");\n        require(amt >= Constants.MIN_STABLECOIN_18_AMOUNT, \"Treasury: amount too small\");\n        require(amt <= Constants.MAX_STABLECOIN_18_AMOUNT, \"Treasury: exceeds max BRS\");\n        uint256 balance = BRS().balanceOf(address(this));\n        uint256 payout = amt > balance ? balance : amt;\n        if (payout > 0) {\n            BRS().safeTransfer(to, payout);\n            emit ITreasury.BRSCompensated(to, payout);\n        }\n    }\n\n    /**\n     * @notice Buyback BRS with BTD on Uniswap\n     * @dev Only owner can call, used to replenish treasury BRS reserves when market conditions allow\n     * @dev Security: onlyOwner modifier, reentrancy guard, amount validation, slippage protection\n     * @param btdAmount BTD amount for buyback (18 decimals)\n     * @param minBRSOut Minimum BRS to receive (18 decimals), slippage protection\n     */\n    function buybackBRS(uint256 btdAmount, uint256 minBRSOut) external override onlyOwner nonReentrant {\n        require(btdAmount >= Constants.MIN_STABLECOIN_18_AMOUNT, \"Treasury: BTD amount too small\");\n        require(btdAmount <= Constants.MAX_STABLECOIN_18_AMOUNT, \"Treasury: BTD amount too large\");\n        require(minBRSOut >= Constants.MIN_STABLECOIN_18_AMOUNT, \"Treasury: minBRSOut too small\");\n        require(minBRSOut <= Constants.MAX_STABLECOIN_18_AMOUNT, \"Treasury: minBRSOut too large\");\n        require(BTD().balanceOf(address(this)) >= btdAmount, \"Treasury: insufficient BTD\");\n\n        BTD().forceApprove(router, btdAmount);\n        address[] memory path = new address[](2);\n        path[0] = core.BTD();\n        path[1] = core.BRS();\n\n        uint256 beforeBal = BRS().balanceOf(address(this));\n        IUniswapV2Router(router).swapExactTokensForTokens(\n            btdAmount,\n            minBRSOut,\n            path,\n            address(this),\n            block.timestamp + 600\n        );\n        uint256 received = BRS().balanceOf(address(this)) - beforeBal;\n        emit ITreasury.BRSBuyback(btdAmount, received);\n    }\n\n    /**\n     * @notice Set Uniswap Router address\n     * @dev Only owner can call, used to update or fix Router configuration\n     * @param newRouter New Uniswap V2 Router address, cannot be zero address\n     */\n    function setRouter(address newRouter) external override onlyOwner {\n        require(newRouter != address(0), \"Treasury: invalid router\");\n        address old = router;\n        router = newRouter;\n        emit RouterUpdated(old, newRouter);\n    }\n\n    /**\n     * @notice Query all token balances in treasury\n     * @dev Returns WBTC, BRS, BTD balances at once\n     * @return wbtcBalance WBTC balance (8 decimals)\n     * @return brsBalance BRS balance (18 decimals)\n     * @return btdBalance BTD balance (18 decimals)\n     */\n    function getBalances()\n        external\n        view\n        override\n        returns (uint256 wbtcBalance, uint256 brsBalance, uint256 btdBalance)\n    {\n        wbtcBalance = WBTC().balanceOf(address(this));\n        brsBalance = BRS().balanceOf(address(this));\n        btdBalance = BTD().balanceOf(address(this));\n    }\n}\n"
      },
      "project/contracts/UniswapV2TWAPOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IUniswapV2TWAPOracle.sol\";\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint256);\n    function price1CumulativeLast() external view returns (uint256);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}\n\n/// @title UniswapV2TWAPOracle\n/// @notice Time-Weighted Average Price (TWAP) oracle for Uniswap V2\n/// @dev Uses cumulative price differences to defend against flash loans, requires periodic updates to maintain observations\ncontract UniswapV2TWAPOracle is IUniswapV2TWAPOracle {\n    using Math for uint256;\n\n    // TWAP observation period (recommended: 10-30 minutes for security)\n    uint256 public constant PERIOD = 30 minutes;\n\n    struct Observation {\n        uint32 timestamp;  // Note: uint32 will overflow in February 2106, contract upgrade needed by then\n        uint256 price0Cumulative;\n        uint256 price1Cumulative;\n    }\n\n    // pair address => observations\n    mapping(address => Observation[2]) public pairObservations;\n\n    // Events\n    event ObservationUpdated(address indexed pair, uint256 price0Cumulative, uint256 price1Cumulative, uint32 timestamp);\n\n    /// @notice Updates TWAP observation for a trading pair\n    /// @dev Should be called at least every 30 minutes to maintain valid observation window\n    ///      Cumulative price overflow is safely handled by Uniswap's Q112 format (expected behavior)\n    /// @param pair Uniswap V2 Pair contract address\n    function update(address pair) external {\n        IUniswapV2Pair uniswapPair = IUniswapV2Pair(pair);\n\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = uniswapPair.getReserves();\n        uint256 price0Cumulative = uniswapPair.price0CumulativeLast();\n        uint256 price1Cumulative = uniswapPair.price1CumulativeLast();\n\n        // Handle Uniswap's cumulative price update logic\n        uint32 timeElapsed = blockTimestampLast - pairObservations[pair][1].timestamp;\n\n        if (timeElapsed > 0 && reserve0 != 0 && reserve1 != 0) {\n            // Overflow is desired and handled correctly\n            unchecked {\n                price0Cumulative += uint256((uint224(reserve1) << 112) / reserve0) * timeElapsed;\n                price1Cumulative += uint256((uint224(reserve0) << 112) / reserve1) * timeElapsed;\n            }\n        }\n\n        // Shift observations: [1] -> [0], new -> [1]\n        pairObservations[pair][0] = pairObservations[pair][1];\n        pairObservations[pair][1] = Observation({\n            timestamp: uint32(block.timestamp),\n            price0Cumulative: price0Cumulative,\n            price1Cumulative: price1Cumulative\n        });\n\n        emit ObservationUpdated(pair, price0Cumulative, price1Cumulative, uint32(block.timestamp));\n    }\n\n    /// @notice Gets TWAP price in Q112 precision\n    /// @dev Calculates time-weighted average price of token0 relative to token1\n    ///      Requires observation time interval >= 30 minutes to ensure TWAP validity\n    /// @param pair Uniswap V2 Pair contract address\n    /// @return price TWAP price (Q112 format, right shift 112 bits to convert to floating point)\n    function getTWAP(address pair) public view returns (uint256) {\n        Observation memory older = pairObservations[pair][0];\n        Observation memory newer = pairObservations[pair][1];\n\n        require(newer.timestamp > 0, \"No observations\");\n\n        uint32 timeElapsed = newer.timestamp - older.timestamp;\n        require(timeElapsed >= PERIOD, \"Observation period too short\");\n\n        // Calculate TWAP using cumulative prices\n        // overflow is desired and handled correctly\n        unchecked {\n            uint256 priceCumulativeDelta = newer.price0Cumulative - older.price0Cumulative;\n            return priceCumulativeDelta / timeElapsed;\n        }\n    }\n\n    /// @notice Gets TWAP price in standard 18 decimal precision\n    /// @dev Converts Q112 format TWAP to standard 1e18 precision\n    ///      Automatically handles different token decimal differences\n    /// @param pair Uniswap V2 Pair contract address\n    /// @param token0Decimals Decimal places of token0 (e.g., USDC is 6)\n    /// @param token1Decimals Decimal places of token1 (e.g., WETH is 18)\n    /// @return price Price of token0 relative to token1, precision 1e18\n    function getTWAPPrice(\n        address pair,\n        uint8 token0Decimals,\n        uint8 token1Decimals\n    ) external view returns (uint256) {\n        uint256 twapQ112 = getTWAP(pair);\n\n        // Convert Q112 format to 18 decimals\n        // price = (twap / 2^112) * (10^token1Decimals / 10^token0Decimals) * 10^18\n        uint256 price;\n\n        if (token1Decimals >= token0Decimals) {\n            uint256 decimalAdjust = 10 ** (token1Decimals - token0Decimals);\n            price = (twapQ112 * decimalAdjust * 1e18) >> 112;\n        } else {\n            uint256 decimalAdjust = 10 ** (token0Decimals - token1Decimals);\n            price = (twapQ112 * 1e18) / decimalAdjust >> 112;\n        }\n\n        return price;\n    }\n\n    /// @notice Checks if TWAP is ready for querying\n    /// @dev Verifies if there is sufficient observation window (>= 30 minutes) to safely query TWAP\n    /// @param pair Uniswap V2 Pair contract address\n    /// @return ready true means TWAP can be safely queried, false means more observation data needed\n    function isTWAPReady(address pair) external view returns (bool) {\n        Observation memory older = pairObservations[pair][0];\n        Observation memory newer = pairObservations[pair][1];\n\n        if (newer.timestamp == 0) return false;\n\n        uint32 timeElapsed = newer.timestamp - older.timestamp;\n        return timeElapsed >= PERIOD;\n    }\n\n    /// @notice Gets observation info details\n    /// @dev Returns observation window information for the trading pair, used for diagnostics and verification\n    /// @param pair Uniswap V2 Pair contract address\n    /// @return olderTimestamp Timestamp of older observation point\n    /// @return newerTimestamp Timestamp of newer observation point\n    /// @return timeElapsed Observation window duration (seconds)\n    function getObservationInfo(address pair) external view returns (\n        uint32 olderTimestamp,\n        uint32 newerTimestamp,\n        uint32 timeElapsed\n    ) {\n        Observation memory older = pairObservations[pair][0];\n        Observation memory newer = pairObservations[pair][1];\n\n        olderTimestamp = older.timestamp;\n        newerTimestamp = newer.timestamp;\n        timeElapsed = newer.timestamp - older.timestamp;\n    }\n}\n"
      }
    }
  }
}